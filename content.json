[{"title":"离散数学笔记","date":"2020-07-31T02:31:36.000Z","path":"2020/07/31/离散数学笔记/","text":"离散数学笔记谓词逻辑US ES 去量词 UG EG 添量词 第1章 集合论空集 空集是一切集合的子集。 空集值是绝对唯一的. 集合基数集合$A$中元素的数目称为集合$A$的基数，记为$|A|$。 m元子集如果一个集合$A$含有$n$个元素，则称集合$A$为$n$元集，称$A$的含有$m$个$(0≤m≤n)$元素的子集为$A$的$m$元子集。 幂集设$A$为任意集合，把$A$的所有不同子集为元素构成的集合叫做$A$的幂集，记为$P(A)$或$2^A$。 有$|P(A)|＝ 2^{|A|}$ 等势设$A，B$是两个集合，若在$A，B$之间存在$1-1$对应的关系：$ψ：A→B$ 则称$A$与$B$是等势的，记为：$A$~$B$。 凡是与自然数集合等势的集合，均称为可数集合(可列集)。可数集合的基数记为：$\\aleph_0$(读作阿列夫零) 。 不可数集合 开区间 $(0, 1)$ 称为不可数集合，其基数记为为$\\aleph$ (读作阿列夫)； 凡是与开区间 $(0, 1)$ 等势的集合都是不可数集合。 集合运算定理设$A、B、C$为任意集合，$Ｕ$为全集，$Φ$为空集 幂等律: $A∪A=A$； $A∩A=A$； 恒等律: $A∪Φ =A$；$A∩U =A$； 零 律: $A∪U=U$； $A∩Φ=Φ$； 否定律：$\\overline{\\overline{A}}=A$； 矛盾律： $A∩\\overline{A}＝Φ$； 排中律：$A∪\\overline{A}＝U$ 交换律: $A∪B=B∪A$; $A∩B=B∩A$ 吸收律: $A∩(A∪B)=A$;$A∪(A∩B)=A$； DeMorgAn律：$\\overline{A∪B}=\\overline{A}∩\\overline{B}$，$\\overline{A∩B}=\\overline{A}∪\\overline{B}$ 结合律：$A∪(B∪C)=(A∪B)∪C$；$A∩(B∩C)=(A∩B)∩C$； 分配律：$A∩(B∪C)=(A∩B)∪(A∩C)$$A∪(B∩C)=(A∪B)∩(A∪C)$ 第2章 计数问题鸽笼原理若有$n+1$只鸽子住进$n$个鸽笼，则有一个鸽笼至少住进$2$只鸽子。 第3章 命题逻辑基本等价公式设$G，H，S$是任何的公式，则： E1：$G∨(H∨S)＝(G∨H)∨S$ (结合律) E2：$G∧(H∧S)＝(G∧H)∧S$ E3：$G∨H＝H∨G$ (交换律) E4：$G∧H＝H∧G$ E5：$G∨G＝G$ (幂等律) E6：$G∧G＝G$ E7：$G∨(G∧H)＝ G$ (吸收律) E8：$G∧(G∨H)＝ G$ E9：$G∨(H∧S)＝(G∨H)∧(G∨S)$ (分配律） E10：$G∧(H∨S)＝(G∧H)∨(G∧S)$ E11：$G∨0＝G$ (同一律) E12：$G∧1＝G$ E13：$G∨1＝1$ (零律) E14：$G∧0＝0$ E15：$G∨┐G ＝ 1$ (排中律) E16：$G∧┐G ＝0$ (矛盾律) E17：$┐(┐G)＝G$ (双重否定律) E18：$┐(G∨H)＝┐G∧┐H$ (德·摩根律) E19：$┐(G∧H)＝┐G∨┐H$ E20：$G→H＝┐G∨H$ (蕴涵式) E21: $G\\leftrightarrow H＝(G→H)∧(H→G)$ (等价式) E22：$G →H＝┐H→┐G$ (假言易位) E23：$G\\leftrightarrow H＝┐G\\leftrightarrow ┐H$ (等价否定等式) E24：$(G →H) ∧(G→┐H)＝┐G$ (归谬论) 第4章 谓词逻辑谓词演算中的基本等价公式 E25：$(\\exists x)G(x) = (\\exists y)G(y)$ E26：$(\\forall x)G(x) = (\\forall y)G(y)$ E27： $\\neg(\\exists x)G(x) = (\\forall x)\\neg G(x)$ E28：$\\neg(\\forall x)G(x) = (\\exists x)\\neg G(x)$ E29：$(\\forall x)(G(x)∨S) = (\\forall x)G(x)∨S$ E30：$(\\forall x)(G(x)∧S) = (\\forall x)G(x)∧S$ E31：$(\\exists x)(G(x)∨S) = (\\exists x)G(x)∨S$ E32：$(\\exists x)(G(x)∧S) = (\\exists x)G(x)∧S$ E33：$(\\forall x)(G(x)∧H(x)) = (\\forall x)G(x)∧(\\forall x)H(x)$ E34：$(\\exists x)(G(x)∨H(x)) = (\\exists x)G(x)∨(\\exists x)H(x)$(量词分配律) E35：$(\\forall x)G(x)∨(\\forall x)H(x) = (\\forall x)(\\forall y)(G(x)∨H(y))$ E36：$(\\exists x)G(x)∧(\\exists x)H(x) = (\\exists x)(\\exists y)(G(x)∧H(y))$ 第5章 证明技术演绎法证明符号： P：条件； T，，，I：由→推理得到； T，，，E：有蕴涵式可得； P（附加前提）：附加条件； CP：使用附加前提要用CP规则； US：去任意量词 ES：去存在量词 UG：加任意量词 EG：加存在量词 数学归纳法第6章 二元关系自反性和反自反性如果对任意$x∈A$，都有$&lt;x, x&gt;∈R$，那么称$R$在$A$上是自反的。 如果对任意$x∈A$，都有$&lt;x, x&gt;\\not\\in R$，那么称$R$在$A$上是反自反的。 对称性和反对称性对任意$x, y∈A$，如果$&lt;x, y&gt;∈R$，那么$&lt;y,x&gt; ∈R$，则称关系$R$是对称的。 对任意$x, y∈A$，如果$&lt;x, y&gt;∈R$且$&lt;y,x&gt;∈R$，那么$x＝y$，则称关系$R$是反对称的。 传递性对任意$x, y, z∈A$，如果$&lt;x, y&gt;∈R$且$&lt;y, z&gt;∈R$，那么$&lt;x, z&gt;∈R$，则称关系$R$是传递的。 关系性质的保守性设$R, S$是定义在$A$上的二元关系，则： 若$R,S$是自反的，则$R^{-1},R∪S,R∩S,RoS$也是自反的 若$R, S$是反自反的，则$R^{-1}, R∪S, R∩S, RoS$也是反自反的 若$R,S$是对称的，则$R^{-1},R∪S,R∩S,RoS$也是对称的 若$R,S$是反对称的，则$R^{-1}, R∩S, RoS$也是反对称的 若$R,S$是传递的，则$R{-1}, R∩S$也是传递的 关系的闭包设$R$是定义在$A$上的关系，若存在$A$上的另一个关系$R′$，使得$R\\subseteq R′$，满足： 1.$R′$是自反的（对称的、或传递的）； 2.任何自反的（对称的、或传递的）关系$R〞$，如果$R\\subseteq R$〞，就有$R′\\subseteq R〞$， 则称$R′$为$R$的自反闭包（对称闭包或传递闭包），分别记为$r(R)$ （$s(R)$或$t(R)$）。 关系的闭包是增加最少元素，使其具备所需性质的扩充。 第7章 特殊关系等价关系设R是定义在非空集合A上的关系，如果R是自反的、对称的、传递的，则称R为A上的等价关系。 等价类设$R$是非空集合$A$上的等价关系，对任意$x∈A$，称集合 $[x]_R = {y|y∈A∧&lt;x,y&gt;∈R}$ 为$x$关于$R$的等价类，其中$x$称为$[x]_R$的生成元 。 $R$具有自反性意味着对任意$x∈A，[x]_R ≠ Φ$。 $R$具有对称性意味着对任意$x, y∈A$，若有$y∈[x]R$，则一定有$x∈[y]_R$。 商集设$R$是非空集合$A$上的等价关系，由$R$确定的一切等价类为元素构成的集合，称为集合$A$关于$R$的商集，记为$A/R$，即$A/R = { [x]R | x∈A }$ 等价关系与划分给定集合A的一个划分$П = {A1, A2, …, An}$， 则由该划分确定的关系$R = (A1×A1)∪(A2×A2)∪…∪(An×An)$是$A$上的等价关系。我们称该关系$R$为由划分$П$所导出的等价关系。 拟序关系设$R$是非空集合$A$上的关系，如果$R$是反自反、反对称和传递的，则称$R$是$A$上的拟序关系，简称拟序，记为“$＜$”，读作“小于”，并将“$&lt;a, b&gt;∈＜$”记为“$a＜b$”。 序偶&lt;A, ＜&gt;称为拟序集。拟序“$＜$”的逆关系“$＜^{-1}$”也是拟序，用“$＞$”表示，读作“大于”。 偏序关系设$R$是非空集合$A$上的关系，如果$R$是自反的、反对称的和传递的，则称$R$是$A$上的偏序关系，简称偏序，记为“$≤$”。 偏序“$≤$”的逆关系“$≤-1$”也是一个偏序，我们用“$≥$”表示，读作“大于等于”；$(≤-I_A)$为$A$上的拟序关系，$(＜∪I_A)$为$A$上的偏序关系。 哈斯图 用小圆圈或点表示A中的元素，省掉关系图中所有的环； （因自反性) 对任意$x, y∈A$，若$x＜y$，则将$x$画在$y$的下方，可省掉关系图中所有边的箭头；（因反对称性）对任意$x, y∈$A，若$x＜y$，且不存在$z∈A$，使得 $x＜z, z＜y$，则$x$与$y$之间用一条线相连，否则无线相连。（因传递性） 偏序集的特殊元素设$&lt;A, ≤&gt;$是偏序集，$B$是$A$的任何一个子集。若存在元素$a∈A$，使得 对任意$x∈B$，都有$x ≤ a$，则称$a$为$B$的上界； 对任意$x∈B$，都有$a ≤ x$，则称$a$为$B$的下界； 若元素$a′∈A$是$B$的上界，元素$a∈A$是$B$的任何一个上界，均有$a′ ≤ a$，则称$a′$为$B$的最小上界或上确界，记为SupB； 若元素$a′∈A$是$B$的下界，元素$a∈A$是$B$的任何一个下界，均有$a ≤ a′$，则称$a′$为$B$的最大下界或下确界，记为InfB。 全序关系设$&lt;A, ≤ &gt;$为偏序集，若对任意$x, y∈A$，总有$x ≤ y$或$y ≤ x$，二者必居其一，则称关系“$≤$”为全序关系(Total Order Relation)，简称全序，或者线序关系，简称线序。称$&lt;A, ≤ &gt;$为全序集(Total Order Set)，或者线序集，或者链(Chain)。 良序关系设$&lt;A, ≤ &gt;$是一偏序集，若$A$的每个非空子集都有最小元，则称“$≤$”为良序关系，简称良序，此时$&lt;A, ≤ &gt;$称为良序集。良序关系一定是全序关系，反之则不然。 第8章 函数函数的定义设$f$是集合$A$到$B$的关系，如果对每个$x∈A$，都存在惟一的$y∈B$，使得$&lt;x, y&gt;∈f$，则称关系f为A到B的函数(Function)(或映射(Mapping)、变换(Transform))，记为$f: A→B$。 当$&lt;x, y&gt;∈f$时，通常记为$y = f(x)$，这时称$x$为函数$f$的自变量，$y$为$x$在$f$下的函数值(或象)， 也称$x$为$y$在$f$下的原象 。 称$A$为函数$f$的定义域，记为$domf$称$f(A) = y| y = f(x), x∈A$为函数 $f$ 的值域，记为$ranf$若$A = B$，则称$f$为$A$上的函数 函数的类型设$f$是从$A$到$B$的函数，对任意$x1, x2∈A$， 如果$x1 ≠ x2$，有$f(x1) ≠ f(x2)$，则称$f$为从$A$到$B$的单射（不同的$x$对应不同的$y)$ 如果$ranf = B$，则称$f$为从$A$到$B$的满射 若$f$是满射且是单射，则称$f$为从$A$到$B$的双射 当$A$上的函数$f$是双射时，称$f$为变换 定理设$A, B$是有限集合，且$|A| = |B|$，$f$是$A$到$B$的函数，则$f$是单射当且仅当f是满射。 函数的运算考虑$f: A→B，g: B→C$是两个函数，则fog = { &lt;x, z&gt; | x∈A{∧}z∈C{∧}(\\exist y)(y∈B{∧}&lt;x, y&gt;∈f{∧}&lt;y, z&gt;∈g)从$A$到$C$的函数，记为$fog: A→C$ ，称为函数$f$与$g$的复合函数。对任意$x∈A，fog(x) = g(f(x))$。 定理若$f$是$A$到$B$的双射，则$f$的逆函数$f^{-1}$也是$B$到$A$的双射。 第9章 图特殊图 仅由孤立结点组成的图称为零图(Null Graph) 仅含一个结点的零图称为平凡图(Trivial Graph) 含有n个结点，m条边的图，称为(n, m)图 图的分类在有向图中，两结点间(包括结点自身间)若有同始点和同终点的几条边，则这几条边称为平行边，在无向图中，两结点间(包括结点自身间)若有几条边，则这几条边称为平行边。两结点a、b间相互平行的边的条数称为边(a, b)或&lt;a, b&gt;的重数(Repeated Number)。 含有平行边的图称为多重图(Multigraph) 非多重图称为线图(Line Graph)； 无环的线图称为简单图(Simple Graph) 子图和补图 若V1 =V，E1包含于 E，则称G1是G的生成子图(Spanning Subgraph) 设V2 包含于V且V2 ≠ 空集，以V2为结点集，以两个端点均在V2中的边的全体为边集的G的子图，称为V2导出的G的子图，简称V2的导出子图(Induced Subgraph) 设$G = &lt;V, E&gt;$为一个具有n个结点的无向简单图，如果G中任意两个结点间都有边相连，则称G为无向完全图(Undirected Complete Graph)，简称G为完全图(Complete Graph)，记为Kn。 设$G = &lt;V, E&gt;$为一个具有n个结点的有向简单图，如果G中任意两个结点间都有两条方向相反的有向边相连，则称G为有向完全图(directed Complete Graph)，在不发生误解的情况下，也记为Kn。 结点的度数与握手定理对于图G = &lt;V, E&gt;，度数为1的结点称为悬挂结点(Hanging Point)，以悬挂结点为端点的边称为悬挂边(Hanging Edge)。 握手定理图中结点度数的总和等于边数的二倍，即设图G $= &lt;V, E&gt;$，则有$$\\sum_{v\\in V}deg(v)=2|E|$$ 推论图中度数为奇数的结点个数为偶数。 第11章 特殊图欧拉图设G是无孤立结点的图，若存在一条通路(回路)，经过图中每边一次且仅一次，则称此通路(回路)为该图的一条欧拉通路(回路)(Eulerian Entry/Circuit)。具有欧拉回路的图称为欧拉图(Eulerian Graph)。 规定：平凡图为欧拉图。以上定义既适合无向图，又适合有向图。 欧拉图的判定定理11.2.1 无向图$G = &lt;V, E&gt;$具有一条欧拉通路，当且仅当$G$是连通的，且仅有零个或两个奇度数结点。规定：平凡图为欧拉图。以上定义既适合无向图，又适合有向图。 定理11.2.2 有向图$G$具有欧拉通路，当且仅当$G$是连通的，且除了两个结点以外，其余结点的入度等于出度，而这两个例外的结点中，一个结点的入度比出度大1，另一个结点的出度比入度大1。 欧拉图的算法设$G = &lt;V, E&gt;，e∈E$，如果$p(G-e)＞p(G)$,称$e$为$G$的桥(Bridge)或割边(Cut edge)。 其中，$p$表示连通分量的个数。 求欧拉图$G = &lt;V, E&gt;$的欧拉回路的Fleury算法：任取$v_0∈V，令P_0 = v_0，i = 0$； 按下面的方法从$E-{e1, e2, …, ei}$中选取$ei+1$：要求：$ei+1$与$vi$相关联；除非无别的边可选取，否则$ei+1$不应该为$ G’ = G - {e1, e2, …, ei}$中的桥； 将边$ei+1$加入通路$P0$中，令$P0 = v0e1v1e2…eiviei+1vi+1， i = i+1$； 如果$i = |E|$，结束，否则转(2)。 “一笔画问题”本质上就是一个无向图是否存在欧拉通路(回路)的问题。 哈密顿图的定义经过图中每个结点一次且仅一次的通路(回路)称为哈密顿通路(回路)(Hamiltonian Entry/circuit)。存在哈密顿回路的图称为哈密顿图(Hamiltonian Graph)。规定：平凡图为哈密顿图。以上定义既适合无向图，又适合有向图。 哈密顿图的判定定理11.3.1 设无向图$G = &lt;V, E&gt;$是哈密顿图，$V_1$是$V$的任意非空子集，则$p(G-V_1) ≤ |V_1|$ 其中$p(G-V_1)$是从$G$中删除$V_1$后所得到图的连通分支数。 定理11.3.1在应用中它本身用处不大，但它的逆否命题却非常有用。我们经常利用定理11.3.1的逆否命题来判断某些图不是哈密顿图，即：若存在$V$的某个非空子集$V_1$使得 $p(G-V_1)＞|V_1|$，则$G$不是哈密顿图。 (以下为充分条件) 定理11.3.2 设$G = &lt;V, E&gt;$是具有$n$个结点的简单无向图。如果对任意两个不相邻的结点$u, v∈V$，均有$deg(u) + deg(v) ≥ n - 1$,则$G$中存在哈密顿通路。 推论11.3.2 设$G = &lt;V, E&gt;$是具有$n$个结点的简单无向图。如果对任意两个不相邻的结点$u, v∈V$，均有$deg(u) + deg(v) ≥ n$,则$G$中存在哈密顿回路。 推论11.3.3 设$G = &lt;V, E&gt;$是具有$n$个结点的简单无向图，$n ≥ 3$。如果对任意$v∈V$，均有$deg(v) ≥ n/2$，则$G$是哈密顿图。 偶图定义11.4.1 若无向图$G = &lt;V, E&gt;$的结点集$V$能够划分为两个子集$V1, V2$，满足$V1∩V2 = Φ$，$且V1∪V2 = V$，使得$G$中任意一条边的两个端点，一个属于$V1$，另一个属于$V2$，则称$G$为偶图(Bipartite Graph)或二分图(Bigraph)。$V1$和$V2$称为互补结点子集，偶图通常记为$G=&lt;V1, E, V2&gt;$。 定义11.4.2 在偶图$G = &lt;V1, E, V2&gt;$中，若$V1$中的每个结点与$V2$中的每个结点都有且仅有一条边相关联，则称偶图$G$为完全偶图(Complete Bipartite Graph)或完全二分图(Complete Bigraph)，记为$Ki, j$，其中，$i = |V1|，j = |V2|$。 偶图的判断 定理11.4.1 无向图$G = &lt;V, E&gt;$为偶图的充分必要条件是$G$的所有回路的长度均为偶数。 一般：我们常使用它的逆否命题来判断一个图不是偶图：无向图$G$不是偶图的充分必要条件是$G$中存在长度为奇数的回路。 匹配定义11.4.2 在偶图$G = &lt;V1, E, V2$&gt;中，$V1 = {v1, v2, …, vq}$，若存在$E$的子集E’ = {(v1, v1’)，(v2, v2’)，…，(vq, vq’)，其中$v1’, v2’, …, vq’ $是$V2$中的$q$个不同的结点}，则称$G$的子图$G’ = &lt;V1, E’, V2&gt;$为从$V1$到$V2$的一个完全匹配(Complete Matching)，简称匹配。 定理11.4.2 (霍尔定理) 偶图$G = &lt;V1, E, V2&gt;$中存在从$V1$到$V2$的匹配的充分必要条件是$V1$中任意$k$个结点至少与$V2$中的$k$个结点相邻，$k = 1, 2, …, |V1|$.定理11.4.2中的条件通常称为相异性条件(Diversity Condition)。 定理11.4.3 设$G = &lt;V1,E,V2&gt;$是一个偶图。如果满足条件 （1）$V1$中每个结点至少关联$t$条边； （2）$V2$中每个结点至多关联$t$条边；则$G$中存在从$V1$到$V2$的匹配。其中$t$为正整数。 平面图如果能把一个无向图$G$的所有结点和边画在平面上，使得任何两边除公共结点外没有其他交叉点，则称$G$为平面图(Plane Graph)，否则称$G$为非平面图(Nonplanar Graph)。 欧拉公式 由边所包围的其内部不包含图的结点和边的区域，称为$G$的一个面(Surface) 包围该面的边所构成的回路称为这个面的边界(Bound) 面$r$的边界的长度称为该面的次数(Degree)，记为$D(r)$ 区域面积有限的面称为有限面(Finite Surface)，区域面积无限的面称为无限面(Infinite Surface) 平面图有且仅有一个无限面 定理11.5.1 平面图中所有面的次数之和等于边数的二倍。怎么理解？每条边会被用两次 定理11.5.2 设$G = &lt;V, E&gt;$是连通平面图，若它有$n$个结点、$m$条边和$r$个面，则有 $$n – m + r = 2$$ 推论11.5.1 设$G$是一个$(n, m)$简单连通平面图，若$m＞1$，则有$m ≤ 3n - 6$。 一般使用逆否命题，即一个简单连通图，若不满足 $m ≤ 3n - 6$，则一定是非平面图。 推论11.5.2 设$G$是一个$(n, m)$简单连通平面图，若每个面的次数至少为$k (k ≥ 3)$，则有 $m\\leq\\dfrac{k}{k-2}(n-2)$ 完全图$K_5$，$k_{3,3}$是非平面图。 库拉托夫斯基定理定理11.5.3(库拉托夫斯基定理) 一个图是平面图的充分必要条件是它的任何子图都不可能收缩为$K5$或$K3, 3$。 推论11.5.3 一个图是非平面图的充分必要条件是它存在一个能收缩为$K5$或$K3, 3$的子图。 $K5$和$K3,3$称为库拉托夫斯基图(Kuratowski Graph)。 离散数学题型笔记选择题计算题主析取范式和主合取范式进行化简。 通过添加P∧P，P∨P，来凑取。 求得一个可以推下一个。 确定是析取还是合取。 证明题演绎推理通过演绎推理，注意P-&gt;Q 与 P∨Q的区别。 证明符号： P：条件； T，，，I：由→推理得到； T，，，E：有蕴涵式可得； P（附加前提）：附加条件； CP：使用附加前提要用CP规则； US：去任意量词 ES：去存在量词 UG：加任意量词 EG：加存在量词","tags":[{"name":"Math","slug":"Math","permalink":"ronpay.xyz/tags/Math/"}]},{"title":"2020嵌入式工作室招新Linux方向招新题","date":"2020-07-01T14:32:54.000Z","path":"2020/07/01/Linux Learning/","text":"第一关：初识Linux基础篇Linux是一种自由和开放源码的类UNIX操作系统。 Linux的优势在于开源，系统的源码是共享的，方便我们自行修改Linux系统，增加或修改所需要的功能，从而得到定制化的系统。服务器端的系统也常常是Linux，使用Linux作为环境，便于软件的调试。Linux 的强大的定制功能和低廉的成本，使得它在嵌入式系统得到广泛的运用。 因选修课使用过Ubuntu 16.04TLS，因此选择了VMware Workstation 安装 Ubuntu 20.04TLS。选择新版本的原因在于新的Linux版本会采用新的Linux内核。 首先在软件与更新中，更换软件源，提高下载速度。 安装chrome,vscode,typora,安装的方式看官网的步骤便可。 1234#install chromewget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.debsudo apt install ./google-chrome-stable_current_amd64.debcat /etc/apt/sources.list.d/google-chrome.list 设置网络代理 在主机的代理软件（Clash for Windows）上勾选允许LAN连接，然后在Ubuntu的网络代理中，设置手动，对所有的项，将地址设置为主机IP，端口设置为代理软件的端口，从而实现科学上网。 美化安装必要的程序 123sudo apt updatesudo apt install gnome-tweakssudo apt install chrome-gnome-shell 安装gnome的chrome扩展，启用User Theme。 然后更换主题、图标、鼠标，这些东西我全都选了Mac OS的主题，顺便换了壁纸。 在gnome主题网站，下载MccainMojave-circle图标、MoMojave主题、McMojave cursors，分别解压缩复制到./~/.themes 和 ./~/.icons目录，在优化中，启用相应主题、图标和鼠标。 在gnome网站上，下载Dash to dock美化dock栏。 效果如下： image-20200630213057555.png 加分项使用了Github+Hexo博客的搭建方式，使用了Hexo的Next主题。 第二关：知识积累Linux 常用命令 cd命令 123回到上一次目录 cd -回到要目录 cd &#x2F;回到home目录 cd ~ mkdir命令 ls命令 12#所有文件 ls -a mv命令 12重命名 mv src dest移动 mv filename pathname(.&#x2F;表示当前位置，) rm命令 12删除文件 rm filename删除文件夹 rm -rf filename tar命令 1解压 tar -zxvf filename.tar.bz2 vim命令 1进入&#x2F;创造文件 vim filename make命令（编译） chmod命令（更改访问权限） Ctrl+C ，在后面讲述到，其实是通过终端向程序发出SIGINT信号，终止当前的进程。 ln命令（功能是为某一个文件在另外一个位置建立一个同步的链接） 1ln [参数][源文件或目录][目标文件或目录] Ubuntu常用命令12345678#安装软件 sudo apt-get install package#更新源 sudo apt-get update#更新已安装的包 sudo apt-get upgrade#安装deb包的方式sudo dpkg -i [deb包] GCC 安装及 编译C语言安装一般GCC的方法12345678#输入下面的命令，安装想要的 GCC 和 G++ ：sudo apt install gcc-8 g++-8 gcc-9 g++-9 gcc-10 g++-10#下面的命令配置每一个版本，并且设置了优先级。默认的版本是拥有最高优先级的那个，在我们的场景中是gcc-10。sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-10 100 --slave /usr/bin/g++ g++ /usr/bin/g++-10 --slave /usr/bin/gcov gcov /usr/bin/gcov-10sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 90 --slave /usr/bin/g++ g++ /usr/bin/g++-9 --slave /usr/bin/gcov gcov /usr/bin/gcov-9sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-8 80 --slave /usr/bin/g++ g++ /usr/bin/g++-8 --slave /usr/bin/gcov gcov /usr/bin/gcov-8#以后，如果你想修改默认的版本，使用update-alternatives命令：sudo update-alternatives --config gcc 编译C语言1234567#编译C语言#命名为helloworldgcc -o helloworld helloworld.c #执行./helloworld#自动生成hello.o，但不会生成二进制执行文件，等待后续链接。gcc -c hello.c 安装特定版本的GCC的方法（编译）（去Google上搜相应的方法，十分麻烦都要分别安装依赖项。最后找了一个英文网页，没几行命令，然后再等待几十分钟的编译就行了。） 123456789101112131415#下载GCC源码wget https://ftpmirror.gnu.org/gcc/gcc-10.1.0/gcc-10.1.0.tar.xz#解压tar -zxvf gcc-10.1.0.tar.xz#下载依赖项cd gcc-10.1.0contrib/download_prerequisites#建立编译输出目录mkdir gcc-build#进入输出目录，执行命令，生成makefile文件../gcc-10.1.0/configure -v --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu --prefix=/usr/local/gcc-10.1.0 --enable-checking=release --enable-languages=c,c++,fortran --disable-multilib --program-suffix=-10.1#编译make -j 4#安装sudo make install-strip GCC-10.1编译安装效果，如下：（弄了好久也不知道怎么把它当作默认的gcc，估计安装路径有点问题） image-20200630213259310.png vimsudo apt-get install vim安装vim. vi/vim的使用刚启动vi/vim时，进入命令模式，输入i，切换输入模式， 输入模式常见命令 Esc进入命令模式 底线命令模式常见命令 q 退出程序 q!强制退出不保存 w 保存文件 wq 保存文件并退出程序 按ESC键退出底线命令模式 一般命令模式常见命令： i,o,a切换到输入模式，以输入字符。 x 向后删除一个字符(del),X 为向前删除一个字符（backspace) dd 删除整行的字符。 :,/,?切换到底线命令模式，以在最底一行输入命令。 gg 移动到第一行 dG删除光标所在处到最后一行所有数据 (n)yy复制光标那一行(光标往下n行) u回复前一个操作 ctrl+r重做上一个操作 /word向下寻找word ?word向上寻找word :sp filename 若打开同一个文件则无需filename。用ctrl+w+上 向上翻，用ctrl+w+下 向下翻 Ctrl x + ctrl n关键词补全 vim缓存与恢复打开不正常结束的vim时会出现缓存警告，可输入o,e,r,d,q,a分别表示只读open，编辑edit，加载缓存recover，删除缓存delete，停止quit，同停止abort。 vim 美化与插件 下载 molokai 主题 将 colors/molokai.vim 拷贝到 ~/.vim/colors/ 新建~/.vimrc文件，在 ~/.vimrc 中添加：colorscheme molokai （vim得安装很多插件才能有VSCode的intellisense、代码补全、自动格式化的功能，还不太习惯，不想折腾了，后面就用VSCode写了） vim-plug vim插件管理器，用于安装、管理插件。 The NERDTree 文件目录可视化的插件，使用vim-plug插件管理器安装，安装方法见vim-plug的GitHub页码。使用方式：在vim命令行形式，输入NERDTree。 安装教程在如上的Github页面都很详细，就不赘述了。 vim编写Hello.c和BST.c image-20200627122923712.png image-20200628113025534.png image-20200628114709524.png image-20200628114742290.png 第三关：进阶篇基础篇CPUCPU是一个具有特殊功能的芯片，里面含有指令集。内分为两个主要的单元，分别为算术逻辑单元，控制单元。CPU内部含有一些微指令，而指令集的设计分成两种设计理念，分别为两种CPU架构：精简指令集，复杂指令集。我们常用的Intel、AMD所用的便是复杂指令集，基于X86架构。 CPU频率：每秒钟可以进行的工作次数。（因为指令集、架构、二级缓存及其运算机制的不同、每一此频率可以运行的指令数不同，故不能单纯使用CPU频率来比较CPU性能。 现在CPU已经没有北桥，其中的内存控制器已经被整合到CPU内部了，使得CPU可以直接与内存、显卡进行通信，提高了效率 64位、32位的说法来自CPU每次能够处理的数据量，即字长。 超线程技术为何会有这种技术？因CPU命令执行周期太短，CPU内核长时间处于空置状态，同时系统是多任务系统，因此让多个任务使用同一内核，可以提高效率。 如何实现？把每个内核中的寄存器分成两组，让程序分别使用两组寄存器，从而使得内核数加倍，同时操作系统可以检测刀两倍的内核数，从而使得每个内核逻辑上分离。 此技术在大多数情况下都可以提高效率，但是其实本质上只有一个运算单元，故性能其实没有改变。 内核有什么用？ 是操作系统的最底层，驱动硬件，提高系统所需要的内核功能，包括防火墙、是否支持LVM等。 是什么？系统中的一个文件，包括驱动主机各个硬件的检查程序和驱动模块。 内核模块化？将一些不常见的类似于驱动程序的东西独立出内核，编译成模块。 进程pid：process id,进程id tid：线程id 程序被触发，执行者的权限和属性、程序的代码与所需数据会被加载到内存中，操作系统会给予这块内存一个PID，即进程是正在运行的一个程序。 12345678910111213141516#include &lt;unistd.h&gt;//获取进程pidpid_t getpid(void);//pthread_t 为 long unsigned int,lu.#include&lt;pthread.h&gt;//获取线程tidpthread_t pthread_self(void);int pthread_equal(pthread_t tid1,pthread_t tid2);int pthread_create(pthread_t *restrict tidp,const pthread_attr_t *restrict attr,void *(*start_vin)(void),void *restrict arg);//中止线程void pthread_exit(void *status);//等待某个线程退出int pthread_join(pthread_t tid,void **status);//gcc 编译 -pthread不可或缺gcc -pthread filename pthread_create用于创建一个线程，成功返回0，否则返回Exxx（为正数）。 pthread_t *tid：线程id的类型为thread_t，通常为无符号整型，当调用pthread_create成功时，通过*tid指针返回。 const pthread_attr_t *attr：指定创建线程的属性，如线程优先级、初始栈大小、是否为守护进程等。可以使用NULL来使用默认值，通常情况下我们都是使用默认值。 void *(*func) (void *)：函数指针func，指定当新的线程创建之后，将执行的函数。 void *arg：线程将执行的函数的参数。如果想传递多个参数，请将它们封装在一个结构体中。 pthread_join用于等待某个线程退出，成功返回0，否则返回Exxx（为正数）。 pthread_t tid：指定要等待的线程ID void ** status：如果不为NULL，那么线程的返回值存储在status指向的空间中（这就是为什么status是二级指针的原因！这种才参数也称为“值-结果”参数）。 pthread_self用于返回当前线程的ID。 pthread_detach用于是指定线程变为分离状态，就像进程脱离终端而变为后台进程类似。成功返回0，否则返回Exxx（为正数）。变为分离状态的线程，如果线程退出，它的所有资源将全部释放。而如果不是分离状态，线程必须保留它的线程ID，退出状态直到其它线程对它调用了pthread_join。 pthread_exit用于终止线程，可以指定返回值，以便其他线程通过pthread_join函数获取该线程的返回值。 void *status：指针线程终止的返回值。 进程与线程线程是比进程更小的单位，进程由多个线程组成。 进程有独立的地址空间，线程没有独立的地址空间。 尝试一个简单的多线程打印123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;//pthread开头的函数#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;//sleep()void* thread1(void *);void* thread2(void *);int main()&#123; printf(\"enter main\\n\"); pthread_t tid1,tid2; // 创建线程 pthread_create(&amp;tid1,NULL,thread1,NULL); pthread_create(&amp;tid2,NULL,thread2,NULL); sleep(1); printf(\"leave main\\n\"); exit(0); return 0;&#125;//线程1void* thread1(void *arg)&#123; printf(\"enter thread1\\n\"); printf(\"thread1 id is %lu\",pthread_self()); printf(\"leave thread1\\n\"); pthread_exit(0);&#125;//线程2void* thread2(void *arg)&#123; printf(\"enter thread2\\n\"); printf(\"thread2 id is %lu\",pthread_self()); printf(\"leave thread2\\n\"); pthread_exit(0);&#125; 运行截图如下： image-20200630214750801.png 双线程打印ABABABAB（使用互斥锁与条件变量）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#define COUNT 20int i=1;//互斥锁宏初始化pthread_mutex_t mutex=PTHREAD_MUTEX_INITIALIZER;//条件变量宏初始化pthread_cond_t even=PTHREAD_COND_INITIALIZER;pthread_cond_t uneven=PTHREAD_COND_INITIALIZER;//线程1函数定义void* thread1(void *arg)&#123; while(i&lt;=COUNT)&#123; pthread_mutex_lock(&amp;mutex);//上锁 if(i%2==1)&#123; printf(\"thread1:A\\n\"); i++; pthread_cond_signal(&amp;uneven);//发出信号 &#125; else&#123; pthread_cond_wait(&amp;even,&amp;mutex);//等待信号 &#125; pthread_mutex_unlock(&amp;mutex);//解锁 &#125;&#125;//除条件变量略有不同，其它类似void* thread2(void *arg)&#123; while(i&lt;=COUNT)&#123; pthread_mutex_lock(&amp;mutex); if(i%2==0)&#123; printf(\"thread2:B\\n\"); i++; pthread_cond_signal(&amp;even); &#125; else&#123; pthread_cond_wait(&amp;uneven,&amp;mutex); &#125; pthread_mutex_unlock(&amp;mutex); &#125;&#125;int main()&#123; pthread_t tid1,tid2; pthread_create(&amp;tid1,NULL,thread1,NULL); pthread_create(&amp;tid2,NULL,thread2,NULL); //等待进程退出 pthread_join(tid1,NULL); pthread_join(tid2,NULL); return 0;&#125; 运行截图如下： image-20200630214836749.png 内核的模块化设计用处？因为Linux内核庞大复杂，内核编译是很麻烦的事情，因此Linux使用模块化设计，将不常用的东西独立出内核，编译成模块。从而使得，在系统运行中，内核可以加载模块。最终提高了扩展性，功能的灵活性。 意思？模块化设计意思为内核中各个功能模块在代码上彼此独立的，没有变量、函数的相互调用。 插入模块创建内核线程，打印Hello，WorldhelloWorld.c 1234567891011121314151617#include &lt;linux/kernel.h&gt;#include &lt;linux/module.h&gt;//printk()#include &lt;linux/init.h&gt;//使用了linux/init.h中定义的宏init和exit//内核中打印函数为printk，static int __init init_my_module(void)&#123; printk(KERN_INFO \"Hello, World!\\n\"); return 0;&#125;static void __exit exit_my_module(void)&#123; printk(KERN_INFO \"Bye, World!\\n\");&#125;//内核加载时执行module_init(init_my_module);//内核卸载时执行module_exit(exit_my_module); Makefile文件 12345678#编译生成可加载模块，即将helloWorld.c编译成hello.koobj-m += helloWorld.oall:#-C 指定内核源码位置，/lib/modules/$(shell uname -r)/build#M= 指定需要编译的内核源文件地址 [target]:modules(可选) make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modulesclean: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean 12345$ lsmod #现实所有内核模块$ make $ sudo insmod helloWorld.ko#运行内核模块$ dmesg #查询/var/log/messages，查看打印的信息$ sudo rmmod helloWorld.ko#卸载模块 运行截图如下： image-20200630215108549.png 加分项互斥锁在变量修改时间多于一个存储器访问周期的情况下，存储器读写周期会交叉，出现变量不一致的情况。 为了解决线程同步的问题，所以线程需要使用锁，同一时间只允许一个线程访问变量。 1234567#include &lt;pthread.h&gt; //宏初始化（适用于静态分配的互斥量）static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;//操作先加锁int pthread_mutex_lock(pthread_mutex_t * mptr); //操作后解锁int pthread_mutex_unlock(pthread_mutex_t * mptr); 互斥锁可以让线程按照顺序执行，从而使得一次只执行一次代码。 死锁如果线程尝试对同一个互斥量加锁两次，本身就会进入死锁状态。 若两个分别占有一个互斥量的线程，试图锁住对方的互斥量是，就会进入死锁状态。 线程同步互斥锁总是与条件变量一起使用。 1234567#include &lt;pthread.h&gt;//宏初始化static pthread_cond_t cond = PTHREAD_COND_INITIALIZER; //等待唤醒int pthread_cond_wait(pthread_cond_t *cptr, pthread_mutex_t *mptr); //通知int pthread_cond_signal(pthread_cond_t *cptr); 标准IO与重定向符号的使用标准输入、标准输出、标准错误分别为stdin,stdout,stderr。在默认情况下，标准输出和标准输入都是终端。stdin的文件描述符为0，stdout的文件描述符为1，stderrr的文件描述符为2。 12345678910111213141516#将stdout重定向到file,若追加在file后，运算符为 &gt;&gt;command &gt; file#将stderr重定向到file,2为文件描述符。command 2 &gt; file#将stdin重定向到filecommand &lt; file#例 输出hello, Linux!的可执行文件.\\hello &gt; hello.txtcat hello.txt#输出hello, Linux!#例 比较大小输出最大值的可执行文件 input.txt: 3 5.\\fmax &lt; input.txt#输出5 第四关：BOSS基础篇信号是一种软中断，信号体制是进程间通信的一种方式，采用异步通信机制。原理是上，一个进程收到信号类似于处理器收到中断请求，故它是在软件层次上对中断机制的一种模拟。 信号在signal.h头文件中被定义，通过kill -l可以查看编号和信号名的映射关系。对于信号，通常有三种处理方式：忽略；默认动作；捕捉信号。 SIG_IGN,SIG_分别表示忽略某一信号；按默认动作处理。 一般信号触发可分为几类：在终端通过组合按键触发，然后发送给前台，如Ctrl+C发送SIGINT信号；硬件异常产生信号，通知内核然后发送给进程信号；通过软件层面，如kill(),raise()等函数，或检测到某种软件条件发生产生信号。 signal()函数用于对进程中某个特定信号（signum）注册一个对应的处理函数。 12typedef void(*sighandle_t)(int); //sighandle_t被定义为指向void()(int)函数类型的指针sighandle_t signal(int signum,sighandler_t handler); kill(),raise()前者用来给指定进程发送信号，后者用来给当前进程发送信号 123int kill(pid_t pid,int signo);int raise(int signo)；//kill(getpid(),signo) equals raise(signo) pause()用来挂起进程，直到信号触发。针对不同的处理行为，表现不同，pause返回不同。若终止进程，则没有返回；若忽略，进程保持挂起状态，没有返回；若有信号处理函数，则调用该函数，返回-1。 加分项中断和异常中断被定义为一种事件，该事件改变处理器执行的指令顺序。中断通常分为同步中断（异常）和异步中断（中断）。同步中断是由CPU产生的，只有在一条指令中止执行后CPU才会产生中断。异步中断是由其它硬件设备依照CPU时钟信号随机产生的。 在嵌入式中，中断很重要，在几乎所有芯片中都有中断功能。每个外接设备申请一个唯一的中断号，让外设发生中断时，向CPU报告自己的中断号，CPU知道是哪个设备发生中断，然后执行相对应的操作。 如何处理？发生中断后，CPU暂停执行当前的程序，处理中断，因为中断执行后要恢复之前的额代码，故进入中断后CPU还要保护源程序断点信息，然后从中断控制器中取出中断向量，转到相应的处理程序，对中断进行处理，中断处理完成后返回，继续执行当前的程序。 好处？提高CPU的利用率，使CPU及时处理各种软硬件故障。若没有中断，CPU需要对设备进行循环的访问，才能得到设备的状态。中断则使得硬件如要与CPU联系，便向CPU发出中断请求信号，从而使得CPU停止当前程序的执行，处理硬件发出的请求。 中断向量是中断服务程序的入口地址，即指向中断服务程序的指针。系统维护一份中断向量表，中断向量是其中的元素。当异常产生时，硬件产生一个中断标记，CPU根据中断标记获得相应的中断向量号，在由CPU根据中断向量表的地址和中断向量号去查找中断向量表获得相应中断号的中断程序地址，进一步执行对应的中断处理程序。 RTC中断程序rtc_alarm.c 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;stdio.h&gt;#include &lt;linux/rtc.h&gt;#include &lt;sys/ioctl.h&gt;//ioctl()#include &lt;sys/time.h&gt;//struct rtc_time#include &lt;sys/types.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;//perror()#include &lt;stdlib.h&gt;//exit()int main(void)&#123; int i, fd, retval, irqcount = 0; unsigned long tmp, data; errno = 0; struct rtc_time rtc_tm; //打开rtc fd = open(\"/dev/rtc\", O_RDONLY); if(fd==-1)&#123; perror(\"/dev/rtc\"); exit(errno); &#125; //读取RTC retval = ioctl(fd, RTC_RD_TIME, &amp;rtc_tm); if(retval==-1)&#123; perror(\"ioctl\"); exit(errno); &#125; //打印当前时间 fprintf(stderr,\"Current RTC data/time is %d-%d-%d,%02d:%02d:%02d.\\n\", rtc_tm.tm_mday, rtc_tm.tm_mon + 1, rtc_tm.tm_year + 1900,rtc_tm.tm_hour, rtc_tm.tm_min, rtc_tm.tm_sec); //设置10min alarm rtc_tm.tm_min += 10; if(rtc_tm.tm_sec&gt;=60)&#123; rtc_tm.tm_sec %= 60; rtc_tm.tm_min++; &#125; if(rtc_tm.tm_min&gt;=60)&#123; rtc_tm.tm_min %= 60; rtc_tm.tm_hour++; &#125; if(rtc_tm.tm_hour==24)&#123; rtc_tm.tm_hour = 0; &#125; //设置 alarm retval = ioctl(fd, RTC_ALM_SET, &amp;rtc_tm); if(retval==-1)&#123; perror(\"ioctl\"); exit(errno); &#125; fprintf(stderr,\"Alarm time now set to %02d:%02d:%02d.\\n\",rtc_tm.tm_hour, rtc_tm.tm_min, rtc_tm.tm_sec); //启用 alarm retval = ioctl(fd, RTC_AIE_ON, 0); if(retval==-1)&#123; perror(\"iotle\"); exit(errno); &#125; //调用read()，因rtc不能被两个线程调用，故阻塞直到alarm，从而实现闹钟功能。 retval = read(fd, &amp;data, sizeof(unsigned long)); if(retval==-1)&#123; perror(\"read\"); exit(errno); &#125; irqcount++; fprintf(stderr, \"okay.Alarm rang.\\n\");&#125; 运行截图如下：（因10min的alarm太久了，故将rtc_tm.tm_min += 10;改为rtc_tm.tm_min += 1;，设置1min的alarm） image-20200630220826329.png","tags":[{"name":"Linux","slug":"Linux","permalink":"ronpay.xyz/tags/Linux/"}]},{"title":"Git 笔记","date":"2020-07-01T14:31:36.000Z","path":"2020/07/01/Git-笔记/","text":"Git笔记基本操作git init12345678#该命令执行完后会在当前目录生成一个 .git 目录。git init#初始化后，会在 newrepo 目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。git init newrepo#如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：$ git add *.c$ git add README$ git commit -m '初始化项目版本' git clone12345678#克隆仓库的命令格式为：git clone &lt;repo&gt;#如果我们需要克隆到指定的目录，可以使用以下命令格式：git clone &lt;repo&gt; &lt;directory&gt;#比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令：$ git clone git://github.com/schacon/grit.git#如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：$ git clone git://github.com/schacon/grit.git mygrit","tags":[{"name":"Git","slug":"Git","permalink":"ronpay.xyz/tags/Git/"}]},{"title":"Github+Hexo 博客搭建","date":"2020-07-01T14:28:50.000Z","path":"2020/07/01/Github-Hexo-博客搭建/","text":"Github+Hexo 博客搭建必要组件安装Node.js，添加国内源npm config set registry https://registry.npm.taobao.org 安装Git，并加入命令提示符 Github操作新建repo，名为：”name.github.io”，并初始化README 安装Hexo右键 Git Bash Here，打开git控制台窗口 123456789101112#安装Hexonpm i hexo-cli -g#初始化文件夹hexo init#安装必要组件npm install#生成静态网页hexo g#打开本地服务器，在localhost:4000/中预览hexo s#关闭本地服务器ctrl+c 连接Github与本地12345678910#在git控制台窗口git config --global user.name \"yourname\"git config --global user.email \"youremail\"#生成密匙SSH keyssh-keygen -t rsa -C \"youremail\"#输入cat ~/.ssh/id_rsa.pub#将输出的文件保存在下方的SSH中#输入ssh -T git@github.com 打开github，在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便。 打开博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。 修改最后一行的配置： 1234deploy: type: git repository: https://github.com/yourname/yourname.github.io branch: master 写文章12345678910#安装拓展npm i hexo-deployer-git#新建一篇文章hexo new post \"article title\"#生成静态网页hexo g#本地浏览hexo s#上传到githubhexo d","tags":[{"name":"Hexo","slug":"Hexo","permalink":"ronpay.xyz/tags/Hexo/"}]}]