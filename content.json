[{"title":"大学物理笔记","date":"2020-08-03T00:45:58.000Z","path":"2020/08/03/大学物理笔记/","text":"力学刚体力学力矩的瞬时效应——刚体转动定理转动惯量$$I=\\int_V{r^2dm}=r^2m$$ 力矩$$\\vec{M}=\\vec{r}\\times\\vec{F}=I\\vec{\\beta}$$其中，$\\beta$是角加速。 平行轴定理：$$I=I_c+ml^2$$其中，$I_c$是转轴过质心的转动惯量。$l$是与过质心转轴相距为$l$且与之平行的另一转轴。 垂直轴定理：$$I=I_x+I_y$$即一个平面薄板刚体对垂直于平面的任一转轴的转动惯量，等于刚体对在平面内并与该垂直轴相交的任二正交轴转动惯量之和。 力矩的时间累积效应——角动量定理冲量矩:$$J=\\int{Mdt}$$角动量：$$L=I\\omega=mr\\times{v}$$角动量守恒：当外力冲量矩的矢量和为零时，刚体的角动量保持不变，即$$I_2\\omega_2=I_1\\omega_1$$ 摩擦力矩的角动量不一定守恒。 在有心力作用下，角动量守恒。 所有有心力都是保守力，机械能守恒。 力矩的空间累积效应——刚体的机械能守恒定律力矩的功：$A=\\int{Md\\theta}$ 动能：$E_k=\\frac{1}{2}I\\omega^2$ 振动力学振动方程$y(t)=Acos(\\omega t-\\phi)$ 波动方程$\\phi(x,t)=Acos[\\omega(t-\\dfrac{x}{v})+\\varphi]=Acos(\\omega t-\\dfrac{\\omega }{v}x+\\varphi)=Acos(\\omega t-kx+\\phi)$ 其中$k=\\dfrac{\\omega}{v}=\\dfrac{2\\pi}{\\lambda}$ 电磁学符号详解电流密度矢量：$j=\\dfrac{I}{S}$ 电位移矢量：$D=\\varepsilon E$ 静电场$k=\\dfrac{1}{4\\pi\\varepsilon_0}$ $e=1.602\\times10^{-19}C$ $\\vec{F}=\\dfrac{1}{4\\pi \\varepsilon_0}\\dfrac{Q_1Q_2}{r^2}\\vec{r_0}$ 电偶极子中垂线上任意点的场强：$\\vec E=\\dfrac{1}{4\\pi\\varepsilon_0}\\dfrac{-\\vec p} {r^3}$。 线密度$\\mu$，面密度$\\sigma$，体密度$\\rho$ 电通量：通过某一面积的电力线条数 $\\phi=\\int_S\\vec{E}\\cdot d\\vec{s}=\\int_sEdscos\\theta$ 高斯定理：$$\\oint_s\\vec{E}\\cdot d\\vec{s}=\\dfrac{1}{\\varepsilon_0}\\sum_{inside,i}q_i=\\dfrac{1}{\\varepsilon_0}\\int_V \\rho dV$$求场强： 用库仑公式积分 用高斯公式算 结合上述两种方法 常用电场强度： 电偶极子中垂线上任意点的场强：$\\vec E=\\dfrac{1}{4\\pi\\varepsilon_0}\\dfrac{-\\vec p} {r^3}$ 电荷均匀分布的带电圆盘轴线上的电场强度：$E=\\dfrac{\\sigma}{2\\varepsilon_0}(1-\\dfrac{x}{r^2+x^2})$ 电荷均匀分布的无限大平面轴线上的电场强度：$E=\\dfrac{\\sigma}{2\\varepsilon_0}$ 电荷均匀分布的带电圆环轴线上的电场强度：$E=\\dfrac{1}{4\\pi\\varepsilon_0}\\dfrac{qx}{(x^2+r^2)^{\\frac{3}{2}}}$ 电势：$U_a=\\dfrac{E_a}{q}=\\int_a^b\\vec{E}\\cdot d\\vec{l}$ 求电势： 点电荷微元求解法：$U_a=\\int_a^b\\dfrac{1}{4\\pi \\varepsilon_0}\\dfrac{dq}{r}$ 电势定义求解方法：场强沿积分路径积分 静电平衡导体空腔场强分布：$E=\\dfrac{\\sigma}{\\varepsilon_0}$ 极化强度矢量：单位体积内分子电偶极矩的矢量和$$\\vec{p}=\\dfrac{\\sum_i\\vec{p_i}}{\\Delta V}$$极化强度的实验定律：$\\vec{p}=\\varepsilon_0\\chi_e\\vec{E}$ $\\chi_e$介质极化率 $\\varepsilon$=$\\varepsilon_0 \\varepsilon_r$ 其中，$\\varepsilon_r$为相对介电常数 介质中的高斯定理$$q_p=-\\oiint_s\\vec{P}\\cdot d\\vec{s}$$ $$\\oint_s{(\\vec{E_f}+\\vec{E_p})}\\cdot d\\vec{s}=\\dfrac{q_f+q_p}{\\varepsilon_0}$$ 得到：$$\\oint_s\\vec{E}\\cdot d\\vec{s}=\\dfrac{q_f}{\\varepsilon_0}-\\dfrac{1}{\\varepsilon_0}\\oint_s\\vec{P}\\cdot d\\vec{s}$$电位移矢量 $\\vec{D}=\\varepsilon_0\\vec{E}+\\vec{P}$ $\\vec{D}=\\varepsilon_0\\varepsilon_r\\vec{E}=\\varepsilon\\vec{E}$$$\\oint_S\\vec{D}\\cdot d\\vec{S}=\\sum_{S内}q_0$$称为电介质中的高斯定理 —— 电位移矢量通过静电场中任意封闭曲面的通量等于曲面内自由电荷的代数和。 稳恒电场毕奥—萨伐尔定律$$d\\vec{B}=\\dfrac{\\mu_0}{4\\pi}\\dfrac{Idl\\times\\vec{e_r}}{r^2}​$$ 其中，$Idl$表示电流方向的电流微元，$r$距离电流微元的位矢。 无限长直导线的磁场分布：$B=\\dfrac{\\mu_0 I}{4\\pi a}({cos\\theta_1-cos\\theta_2})$ 环形电流在轴线上的磁场分布：$B=\\dfrac{\\mu_0}{4\\pi}\\dfrac{2\\pi I R^2}{(R^2+x^2)^\\frac{3}{2}}$ 无限长导线沿磁力线闭合回路积分值：$\\oint_l\\vec{B}\\cdot d\\vec{l}=\\mu_0I$ 安培环路定律$$\\oint_l\\vec{B}\\cdot dl=\\mu_0\\sum I_内$$ 洛伦兹力$$\\vec{F}=q\\vec{v}\\times\\vec{B}$$ 安培定律$$\\vec{F}=\\int Id\\vec{l}\\times\\vec{B}$$ 磁场对线圈力矩 $$\\vec{M}=\\vec{p_m}\\times\\vec{B};M=p_m\\cdot B\\sin\\varphi$$ 其中，$\\vec{p_m}=IS\\vec{n}$，$S$为线圈的面积。 有磁介质的安培环路定理$$\\oint_l{\\vec{H}\\cdot d\\vec{l}}=\\sum I_{o内}$$ 其中，$\\vec{H}=\\dfrac{\\vec{B}}{\\mu_0}-\\vec{M}$（磁场强度矢量） 动生电动势$$\\varepsilon_i=\\int_a^b d\\varepsilon_i=\\int_a^b(\\vec{v}\\times\\vec{B})\\cdot\\vec{l}​$$ $$\\varepsilon_i=-\\dfrac{d\\Phi_m}{dt}$$ 适用于在垂直于磁场平面内匀速转动的导线：$\\varepsilon_i=\\dfrac{1}{2}B\\omega l^2$ 感生电动势$$\\oint_s\\vec{E_i}\\cdot d\\vec{l}=-\\int_s\\dfrac{\\partial\\vec{B}}{\\partial t}\\cdot d\\vec{S}$$ 绕N匝长直螺线管中，变化电流产生的磁场为$$B=\\mu_0NI$$ 无限长直导线，产生的磁场为$$B=\\dfrac{\\mu_0 I}{2\\pi r}$$其中，$r$为距离。 自感$$\\varepsilon_L=-\\dfrac{d(N\\Phi_m)}{dt}=-L\\dfrac{dI}{dt}$$ 互感$$\\varepsilon_L=-M\\dfrac{dI}{dt},$$ $$M=\\dfrac{N\\Phi_m}{I}$$ 线圈的磁能$$W_m=\\dfrac{1}{2}LI^2$$ 磁场能量密度： $$\\omega_m=\\dfrac{1}{2}\\dfrac{B^2}{\\mu}=\\dfrac{1}{2}\\mu H^2=\\dfrac{1}{2}BH$$ 位移电流位移电流密度：$$\\vec{j_d}=\\dfrac{d\\vec{D}}{dt}$$位移电流强度：$$I=_d\\dfrac{d\\varphi_D}{dt}$$其中，$\\varphi_D$为电位移矢量的通量。 安培环路定律的一般形式：$$\\oint_l\\vec{H}\\cdot d\\vec{l}=\\sum I_{0内}+\\dfrac{d\\varphi_d}{dt}$$","tags":[{"name":"Math","slug":"Math","permalink":"ronpay.xyz/tags/Math/"}]},{"title":"微积分II笔记","date":"2020-08-01T02:31:36.000Z","path":"2020/08/01/微积分II笔记/","text":"(MathJax不支持\\oiit，渲染不了🤣) 重要知识积化和差 正余余正，正加正减； 余余正正，余加负余减。 和差化积 正加正，正在前； 正减正，余在前； 余加余，余并肩； 余减余，负正弦。 海伦公式$S=\\sqrt{p(p-a)(p-b)(p-c)}$ 其中，$p=\\dfrac{a+b+c}{2}$。 微积分知识 Image result for 求导公式 $n$为奇数时：$\\int^\\frac{\\pi}{2}_0{sin^nx}=\\frac{1}{2}\\times\\frac{3}{4}\\times…\\times\\frac{n-1}{n}$ $n$为偶数时：$\\int^\\frac{\\pi}{2}_0{sin^nx}=\\frac{1}{2}\\times\\frac{3}{4}\\times…\\times\\frac{n-1}{n}\\times\\frac{\\pi}{2}$ $\\int^\\frac{\\pi}{2}_0{sinx}$=$\\int^\\frac{\\pi}{2}_0{cosx}$ 常微分方程一阶微分方程可分离变量的方程形如$$\\dfrac{dy}{dx}=f(x)g(y)$$的方程，可将方程改写为$\\dfrac{dy}{g(y)}=f(x)dx$，再对两端积分即可，略。 齐次方程如方程可变为形如$$\\dfrac{dy}{dx}=\\varphi(\\dfrac{y}{x})$$得方程，则可引入函数$u=\\dfrac{y}{x}$，即$y=xu$，有$\\dfrac{dy}{dx}=u+x\\frac{du}{dx}$，带入方程得到$u+x\\dfrac{du}{dx}=\\varphi(u)$，再分离变量得$\\dfrac{du}{\\varphi(u)-u}=\\dfrac{dx}{x}$,再对两端积分即可，略。 一阶线性方程可变为形如$$\\dfrac{dy}{dx}+P(x)y=Q(x)$$的方程，如果$Q(x)\\equiv0$，称为一阶齐次线性微分方程；如果$Q(x)\\not\\equiv0$，称为一阶非齐次线性微分方程。 对于，一阶齐次线性方程，可用可分离变量的方程求解，略。 下面求一阶非齐次线性方程的通解：(常数变易法) 通解为$$y=e^{-\\int{P(x)dx}}[\\int Q(x)e^{\\int{P(x)}dx}dx+C]$$ 伯努利方程形如$$\\frac{dy}{dx}+P(x)y=Q(x)y^n(n\\not=0,1)$$的方程称为伯努利方程，可通过变换$z=y^{1-n}$转化为一阶线性微分方程，令$z=y^{1-n}$，则$\\frac{dz}{dx}=(1-n)y^{-n}\\dfrac{dy}{dx}$,即$y^{-n}\\dfrac{dy}{dx}=\\dfrac{1}{1-n}\\dfrac{dz}{dx}$。以$y^n$除以方程两端，得$y^{-n}\\dfrac{dy}{dx}+P(x)y^{1-n}=Q(x)$,将上面所求的关系式带入，得$\\dfrac{dz}{dx}+(1-n)P(x)z=(1-n)Q(x)$,然后按照一阶线性微分方程得方法求解。 可降阶的高阶微分方程$y^{(n)}=f(x)$型 连续积分即可。 $y’’=f(x,y’)$型 令$p=y’$，然后用一阶微分方程的方法，解出$p$，然后再计算即可。 $y’’=f(y,y’)$型 令$p=y’$，然后再将$y’’$化为$p$对$y$的导数，然后用一阶微分方程的方法，解出$p$，然后再计算即可。 二阶齐次线性方程一般形式：$$\\dfrac{d^2y}{dx}+P(x)\\dfrac{dy}{dx}+Q(x)y=0$$二阶常系数齐次线性方程的解法： 令$P(x)\\equiv p，Q(x)\\equiv q$，则其对应的特征方程为：$r^2+pr+q=0$，$r_1,r_2$为特征方程的根，则 特征方程的根 微分方程的通解 两个不等实根$r_1，r_2$ $y=C_1e^{r_1x}+C_2e^{r_2x}$ 两个相等实根$r_1=r_2$ $y=(C_1+C_2x)e^{r_1x}$ 一对共轭复根$r_{1,2}=\\alpha \\pm i\\beta$ $y=e^{\\alpha x}(C_1cos{\\beta x}+C_2sin\\beta x)$ 二阶非齐次线性方程第五章 多元函数微分学5.1多元函数二元函数二重极限是否存在 5.2偏导数偏导数的概念 在多元函数中，即使$f$在某点对某个变量的偏导数都存在，也不能由此断定$f$在该点连续，甚至不能断定$f$在该点存在极限。 5.3全微分及其应用判断是否可全微分定理：若在点可微，则偏导数必存在，函数必连续。若偏导数在领域存在，且在点连续，则点可微。 5.4多元复合函数的求导法则5.5隐函数求导法一个函数的情形$$ F_y(x_0,y_0)=0; $$ 方程组的情形 推导 记忆方程组的情形的公式 5.6偏导数在几何上的应用空间曲线的切线和法平面由参数方程表示的情况切向量$\\vec{s}=[x’(t_0),y’(t_0),z’(t_0)]$ 在$M_0(x_0,y_0,z_0)$处 切线：$\\dfrac{x-x_0}{x’(t_0)}=\\dfrac{y-y_0}{y’(t_0)}=\\dfrac{z-z_0}{z’(t_0)}$ 法平面：$x’(t_0)(x-x_0)+y’(t_0)(y-y_0)+z’(t_0)(z-z_0)=0$ 由两个曲面的交线表现的情况设空间曲面L的一般方程为$F(x,y,z)=0,G(x,y,z)=0$，则 切向量：$\\vec{s}=(1,y’(x),z’(x))|_{M_0}$ 其中，方程组对$x$求导，得到$y’(x),z’(x)$ 空间曲面的切平面和法线由隐式给出的情况曲线$S:F(x,y,z)=0$在$M_0(x_0,y_0,z_0)$处的 切平面：$F_x(M_0)(x-x_0)+F_y(M_0)(y-y_0)+F_z(M_0)(z-z_0)=0$ 法直线：$\\dfrac{x-x_0}{F_x(M_0)}=\\dfrac{y-y_0}{F_y(M_0)}=\\dfrac{z-z_0}{F_z(M_0)}$ 由显式给出的情况曲线$z=f(x,y)$ 令$F(x,y,z)=f(x,y)-z$，则 法向量：$\\vec{n}=(f_x(x,y),f_y(x,y),-1)$ 5.7方向导数与梯度如果函数$z=f(x,y)$在点$P(x,y)$可全微分，则函数在点$P$沿任意方向$l$的方向导数都存在，且有 $$\\dfrac{\\partial f}{\\partial l}=\\dfrac{\\partial f}{\\partial x}cos\\alpha+\\dfrac{\\partial f}{\\partial y}cos\\beta$$ 其中$cos\\alpha,cos\\beta$为$l$的方向余弦梯度$$gradf=\\dfrac{\\partial f}{\\partial x}i+\\dfrac{\\partial f}{\\partial y}j$$ 5.8二次函数的泰勒公式略 5.9多元函数的极值无条件极值极值的必要条件设$z=f(x,y)$在点$P_0(x_0,y_0)$处具有连续偏导数$f_x,f_y$，且在点$P_0(x_0,y_0)$处取得极值，则$$f_x(x_0,y_0)=0,f_y(x_0,y_0)=0$$ 极值的充分条件设设$z=f(x,y)$在点$(x_0,y_0)$处的某一领域内有二阶连续偏导数，且满足$$f_x(x_0,y_0)=0,f_y(x_0,y_0)=0$$令$A=f_{xx}(x_0,y_0),B=f_{yy}(x_0,y_0),C=f_{zz}(x_0,y_0)$，则 当$AC-B^2&gt;0$时，函数有极值，其中，$A&lt;0$时有极大值，$A&gt;0$时有极小值； 当$AC-B^2&lt;0$时，函数无极值； 当$AC-B^2=0$时，未定。 有界闭区域上函数的最大最小值有界闭区域上函数的最大最小值的求解步骤: 求出$f(x,y)$在$D$内的所有驻点及驻点处的函数值； 求出$f(x,y)$在在边界上的最大（小）值； 比较以上各值其最大（小）者为$D$上的最大（小）值。 条件极值设目标函数$u=f(x,y)$，约束条件$\\varphi(x,y)=0$，构造拉格朗日函数$F(x,y,\\lambda)=f(x,y)+\\lambda\\mu(x,y)$，其中$\\lambda$为某一常数，对三变量$x,y,\\lambda$分别求导得，$F_x,F_y,F_\\lambda$，求出驻点即可。 可推广至三元函数，则多加一变量$z$一常数$\\lambda_2$。 第六章 多元数量值函数积分学6.1多元数量值函数积分的概念与性质估值定理 夹在最小值 最大值 之间，即$m\\cdot(\\Omega的度量)\\leq\\int_{\\Omega}f(M)d\\Omega\\leq M\\cdot(\\Omega的度量)$ 积分中值定理 取绝对值 对称性当积分区域$\\Omega$关于$x=0$对称时， $f(M)$关于$x$为奇函数，则$\\int_\\Omega f(M)d\\Omega=0$。 $f(M)$关于$x$为偶函数，则$\\int_\\Omega f(M)d\\Omega=2\\int_{\\Omega’} f(M)d\\Omega$ 6.2二重积分的计算直角坐标系下极坐标系下$dxdy=rdrd\\theta$ 相关知识双纽线：$r^2=2a^2cos2\\theta$ 四叶玫瑰线：$r=4sin2\\theta$ 6.3三重积分的计算在直角坐标系中计算三重积分从函数表示的上面到函数表示的下面的累加 平行截面法计算三重积分算一截面的面积，然后对积分上下限常数$z$累加。 使用范围总结 被积表达式最好仅为$z$的函数 截面为规则的图形 以上两种方法主要是$r$与$z$的不同。 柱坐标系下计算三重积分$\\iiint f(x,y,z)dV=\\iiint f(rcos\\theta,rsin\\theta,z)rdrd\\theta dz$ 球坐标系下计算三重积分$\\iiint f(x,y,z)dV=\\iiint f(\\rho sin\\varphi cos\\theta,\\rho sin\\varphi sin\\theta,\\rho cos\\varphi)\\rho^2 sin\\varphi d\\rho d\\varphi d\\theta$ 换元法计算三重积分常用式子： $\\iiint f(x,y,z)dV=\\iiint f(a\\rho sin\\varphi cos\\theta,b\\rho sin\\varphi sin\\theta,c\\rho cos\\varphi)abc\\rho^2 sin\\varphi d\\rho d\\varphi d\\theta$ 6.4第一类曲线积分的计算曲线的弧长直角坐标系下：$s=\\int^b_a\\sqrt{1+[y’(x)]^2}dx $ 其中参数方程表示：$s=\\int^\\beta_\\alpha\\sqrt{x’(t)^2+y’(t)^2}dt$ 极坐标系下：$s=\\int^\\beta_\\alpha\\sqrt{r^2(\\theta)+r’^2(\\theta)}d\\theta$ 第一类曲线积分参数方程的形式：$\\int_Lf(x,y)ds=\\int^{\\beta}_{\\alpha}f[x(t),y(t)]\\sqrt{x’^2(t)+y’^2(t)}dt$ 特殊情况：$L:y=y(x)$，则 $\\int_Lf(x,y)ds=\\int^{b}_{a}f[x,y(x)]\\sqrt{1+y’^2(x)}dx$ 6.5第一类曲面积分的计算曲面的面积若曲面$S$的方程为$z=z(x,y)$，在$xOy$面上的投影为$D_{xy}$面上的投影为$D_{xy}$，则$$S=\\iint_{D_{xy}}\\sqrt{1+z_x^2(x,y)+z_y^2(x,y)}dxdy$$投影在其它坐标面的情况类似。 特别地，对于半球面，$z=\\sqrt{R^2-x^2-y^2}$，有$$dS=\\sqrt{1+z_x^2+z_y^2}dxdy=\\dfrac{R^2}{\\sqrt{R^2-x^2-y^2}}dxdy$$ 第一类曲面积分的计算若曲面$S$的方程为$z=z(x,y)$，S在$xOy$面上的投影为$D_{xy}$面上的投影为$D_{xy}$，$f(x,y,z)$在$S$上连续，则$$S=\\iint_Sf(x,y,z)dS=\\iint_{D_{xy}}f[x,y,z(x,y)]\\sqrt{1+z_x^2(x,y)+z_y^2(x,y)}dxdy$$ 总结 确定投影方向，找出曲面$S $的方程及其微分$dS$。 找出曲面的投影区域。 利用公式求解。 参数方程曲面上的第一类曲面积分特别地，对于半径为$R$的球面参数方程，有$$\\iint_Sf(x,y,z)dS=\\iint_{D_{\\phi\\theta}}f(\\rho sin\\varphi cos\\theta,\\rho sin\\varphi sin\\theta,\\rho cos\\varphi)\\rho^2 sin\\varphi d\\rho d\\varphi d\\theta$$ 6.6积分在物理上的应用物体的重心当物体均匀时，有质心坐标，$$\\bar x=\\dfrac{\\int_\\Omega xd\\Omega}{\\int_\\Omega d\\Omega},\\bar y=\\dfrac{\\int_\\Omega yd\\Omega}{\\int_\\Omega d\\Omega},\\bar z=\\dfrac{\\int_\\Omega zd\\Omega}{\\int_\\Omega d\\Omega}$$，$y,z$坐标同理可得。 且有，$\\int_\\Omega xd\\Omega=\\bar x\\int_\\Omega d\\Omega$ 转动惯量设物体分布在空间几何体$\\Omega$上，其密度函数为$\\mu(M)$，则物体绕$x,y,z$轴的转动惯量为$$I_x=\\int_\\Omega(z^2+y^2)\\mu(M)d\\Omega,I_y=\\int_\\Omega(x^2+z^2)\\mu(M)d\\Omega,I_z=\\int_\\Omega(x^2+y^2)\\mu(M)d\\Omega$$设物体分布在平面区域$D$上，其密度函数为$\\mu(M)$，则物体绕$x,y$轴的转动惯量为$$I_x=\\iint_Dy^2\\mu(M)dxdy,I_y=\\iint_Dx^2\\mu(M)dxdy$$注意到，$x,y,z$的对称性。 引力设几何体$\\Omega$密度函数为$\\mu(P)$，引力$F$在三个坐标轴上的分量$F_x,F_y,F_z$分别为$$F_x=G\\int_\\Omega\\dfrac{\\mu(P)(x-x_0)}{r^3}d\\Omega,F_x=G\\int_\\Omega\\dfrac{\\mu(P)(y-y_0)}{r^3}d\\Omega,F_z=G\\int_\\Omega\\dfrac{\\mu(P)(z-z_0)}{r^3}d\\Omega$$其中，$r=\\sqrt{(x-x_0)^2+(y-y_0)^2+(z-z_0)^2}$。 6.7含参变量的积分有限区间上的含参变量积分设$f(x,y)$在闭区间$D={(x,y)|a\\leq x\\leq b,c\\leq y\\leq d}$上连续，则对$[a,b]$上任一固定的$x$，$f(x,y)$是$y$函数，故$f(x,y)$在$[c,d]$上可积，积分$$\\varphi(x)=\\int_c^d f(x,y)dy$$称$\\varphi(x)$为含参变量$x$的积分，称$x$为参变量。 莱布尼兹公式$$\\varphi’(x)=\\dfrac{d}{dx}\\int_{\\alpha(x)}^{\\beta(x)}f(x,y)dy=\\int_{\\alpha(x)}^{\\beta(x)}f_x(x,y)dy+f[x,\\beta(x)]\\beta’(x)-f[x,\\alpha(x)]\\alpha’(x)$$各条定理总结：求导与积分的顺序可对调， 积分计算的例子：$I=\\int_0^1\\dfrac{x^b-x^a}{lnx}dx$ 含参变量广义积分各条定理总结：可交换积分顺序 欧拉-泊松积分$$J=\\int^{+\\infty}_0e^{-x^2}dx=\\dfrac{\\sqrt{\\pi}}{2}$$ 菲涅尔积分$J=\\int_0^{+\\infty}sinx^2dx=\\dfrac{1}{2}\\sqrt{\\dfrac{\\pi}{2}}$ 第七章 多元向量值函数积分学7.1第二类曲线积分第二类曲线积分的背景求变力沿曲线所作的功 记为$\\int_L(F\\cdot\\tau_0)ds=\\int_LF\\cdot dr$。 第二类曲线积分的性质 $\\int_L(k_1F_1+k_2F_2)=k_1\\int_LF_1dr+k_2\\int_LF_2dr$ $L=L_1+L_2$，且方向一致，则$\\int_LF\\cdot dr=\\int_{L_1}F\\cdot dr+\\int_{L_2}F\\cdot dr$ $\\int_LF\\cdot dr=-\\int_{-L}F\\cdot dr$ 对坐标的曲线积分：$\\int_LF\\cdot dr=\\int_LF\\cdot ds=\\int_LP(x,y,z)dx+Q(x,y,z)dy+R(x,y,z)dz$ 第二类曲线积分的计算设曲线的参数方程为$x=x(t),y=y(t)$，其实$t:\\alpha\\to\\beta$，则$$\\int_LP(x,y)dx+Q(x,y)dy=\\int_\\alpha^\\beta {P[x(t),y(t)]x’(t)+Q[x(t),y(t)]y’(t)}dt$$特殊情况：$L:y=y(x)$，则$$\\int_LP(x,y)dx+Q(x,y)dy=\\int_\\alpha^\\beta {P[x,y(x)]dx+Q[x,y(x)]y’(x)}dx$$其它情况类似。 7.2第二类曲面积分第二类曲面积分(也称对坐标的曲面积分)$$\\iint_SF\\cdot d\\vec{S}=\\iint_S(Pcos\\alpha+Qcos\\beta+Rcos\\gamma)dS=\\iint_S P(x,y,z) dydz+Q(x,y,z) dzdx+R(x,y,z) dxdy$$ 第二类曲面积分的性质与第二类曲线积分的性质类似。 第二类曲面积分的计算（合一投影）若曲面方程为$z=z(x,y),(x,y)\\in D_{xy}$，则$$\\iint_SF\\cdot d\\vec{S}=\\iint_S P dydz+Q dzdx+Rdxdy=\\pm\\iint_{D_{x,y}}{F[x,y,z(x,y)]\\cdot n(x,y)dxdy}$$ 其中，$n(x,y)=(-z_x,-z_y,1)$。 曲面取$z$轴的上侧取正，下侧取负。 当$y=y(z,x),x=(y,z)$的情况类似。 计算步骤 定方向 定向量 定正负 定积分 第二类曲面积分的计算（分面投影）利用变量的对等性，$x,y,z$对等，可用一个替代。 若曲面方程为$z=z(x,y),(x,y)\\in D_{xy}$，则$$\\iint_SR(x,y,z)dxdy=\\pm\\iint_{D_{sy}}(0,0,R(x,y,z(x,y)))\\cdot (-z_x,-z_y,1)dxdy=\\pm\\iint_{D_{xy}}R(x,y,z(x,y))dxdy$$当曲面的侧与$z$轴的正向夹角成锐角时取正号，反之钝角取负号。 当$y=y(z,x),x=(y,z)$的情况类似。 两类曲面积分之间的联系$$\\oiint{F\\cdot d\\vec{S}}=\\oiint F\\cdot n_0 dS$$ 其中$n_0$为与曲面侧一致的单位法向量。 $$cos\\alpha=\\dfrac{\\mp z_2}{\\sqrt{1+z_x^2+z_y^2}},\\iint_SP(x,y,z)dydz=\\iint_SP(x,y,z)cos\\alpha dS$$ 其它情况类似。 7.3积分基本定理区域连通性的分类设$D$为平面区域， 如果$D$内任一闭曲线所围成的部分都属于$D$，则称$D$为平面单连通区域， 否则称为复连通区域。 设空间区域$G$，如果$G$内任一闭曲面所围成的区域全属于$G$，则称$G$是空间二维单连通域；如果$G$内任一闭曲线总可以张一片完全属于$G$的曲面，则称$G$为空间一维单连通区域。 设$L$为平面区域$D$的边界曲线，当一个人沿着$L$行走，如果$D$的内部区域总位于这个人的左侧，称这个人行走的方向为$L$的正方向，另一方向为负方向。 格林公式定理1：设设闭区域$D$由分段光滑的曲线$L$围成函数，函数$P(x,y),Q(x,y)$在$D$上有一阶连续偏导数，则$$\\oint_LPdx+Qdy=\\iint_D(\\dfrac{\\partial Q}{\\partial x}-\\dfrac{\\partial P}{\\partial y})dxdy$$其中$L$是$D$的正向边界曲线。 实质：沟通了沿闭合曲线的积分与二重积分之间的联系。 推论：设$D$是由分段光滑的曲线$L_1$与$L_2$围成的平面复连通区域，函数$P(x,y),Q(x,y)$在$D$上有一阶连续偏导数，则$$\\iint_D(\\dfrac{\\partial Q}{\\partial x}-\\dfrac{\\partial P}{\\partial y})dxdy=\\oint_{L_1}Pdx+Qdy+\\oint_{L_2}Pdx+Qdy$$特别地，当$\\dfrac{\\partial Q}{\\partial x}=\\dfrac{\\partial P}{\\partial y}$时，$$\\oint_{L_1}Pdx+Qdy=-\\oint_{L_2}Pdx+Qdy=\\oint_{L_2-}Pdx+Qdy$$ 高斯公式定理1：设空间闭区域$V$是由分片光滑的闭曲线$S$围成，函数$P(x,y,z),Q(x,y,z),R(x,y,z)$是$V$上有一阶连续偏导数，则有$$\\iiint_V(\\dfrac{\\partial P}{\\partial x}+\\dfrac{\\partial Q}{\\partial y}+\\dfrac{\\partial R}{\\partial z})dV=\\oiint_SPdydz+Qdzdx+Rdxdy$$其中，$S$为$V$的边界曲面的外侧。 实质：表达了空间闭区域上的三重积分与其边界曲面上的曲面积分之间的关系。 高斯公式的使用条件 曲面S为闭曲面 曲面S的方向为外侧 函数P,Q,R在V上一阶连续可导 斯托克斯公式定理：设$\\varGamma$是分段光滑的空间有向闭曲线，$S$是以$\\varGamma$为界的分片光滑的有向曲面，$\\varGamma$的正向与$S$的侧向符合右手法则，函数$P(x,y,z),Q(x,y,z),R(x,y,z)$在包含曲面$S$在内的一个空间区域内具有一阶连续偏导数，则有斯托克斯公式$$\\iint_S(\\dfrac{\\partial R}{\\partial y}-\\dfrac{\\partial Q}{\\partial z})dydz+(\\dfrac{\\partial P}{\\partial z}-\\dfrac{\\partial R}{\\partial x})dzdx+(\\dfrac{\\partial Q}{\\partial x}-\\dfrac{\\partial P}{\\partial y})dxdy=\\oint_{\\varGamma}Pdx+Qdy+Rdz$$实质：斯托克斯公式表达了有向曲面上的曲面积分与其边界曲线上的曲线积分之间的关系。 斯托克斯公式的特殊情况是格林公式。 7.4曲线积分与路径无关积分与路径无关的定义如果在区域$G$内有$$\\int_{L_1}Pdx+Qdy=\\int_{L_2}Pdx+Qdy$$称曲线积分$\\int_{L}Pdx+Qdy$在$G$内与路径无关，否则称积分与路径有关。 曲线积分与路径无关的条件定理1：设$D$为平面上的单连通区域，函数$P(x,y),Q(x,y)$在D上有一阶连续偏导数，则下四命题等价： 沿D内任一条闭曲线L，有$\\oint_L{P(x,y)dx+Q(x,y)dy}=0。$ $\\int_L{P(x,y)dx+Q(x,y)dy}$在$D$内积分与路径无关。 ${P(x,y)dx+Q(x,y)dy}$为$D$内某函数$u(x,y)$的全微分，$du(x,y)=P(x,y)dx+Q(x,y)dy$。 在$D$内每一点有$\\dfrac{\\partial{Q}}{\\partial{x}}=\\dfrac{\\partial{P}}{\\partial{y}}$。 全微分方程定义：对于一阶常微分方程$P(x,y)dx+Q(x,y)dy=0$，若存在一函数$u(x,y)$，使$du(x,y)=P(x,y)dx+Q(x,y)dy$，称此方程为全微分方程。 定理：$u(x,y)=C$为全微分方程$P(x,y)dx+Q(x,y)dy=0$的通解。 积分因子：对于方程$Pdx+Qdy=0$不是全微分方程，若存在函数$\\mu(x,y)$，使$\\mu Pdx+\\mu Qdy=0$为全微分方程，称$\\mu(x,y)$为积分因子。 7.5场论初步场的概念分布着某种物理量的平面或空间区域称为场。若物理量为数量，称此场为数量场。若物理量为向量，称此场为向量场。 不随时间变化的场称为稳定场。 随时间变化的场称为不稳定场。 梯度：$gradu=\\dfrac{\\partial u}{\\partial x}i+\\dfrac{\\partial u}{\\partial y}j+\\dfrac{\\partial u}{\\partial z}k$ 散度：$divA=\\dfrac{\\partial P}{\\partial x}+\\dfrac{\\partial Q}{\\partial y}+\\dfrac{\\partial R}{\\partial z}$ 旋度：$rotA=(\\dfrac{\\partial R}{\\partial y}-\\dfrac{\\partial Q}{\\partial z})i+(\\dfrac{\\partial P}{\\partial z}-\\dfrac{\\partial R}{\\partial x})j+(\\dfrac{\\partial Q}{\\partial x}-\\dfrac{\\partial P}{\\partial y})k$ 其中，$u=u(x,y,z),A=Pi+Qj+Rk$ 第八章 无穷级数8.1常数项级数的概念级数的定义：给定数列$u_1,u_2,…,u_n,…,$则由这个数列构成的表达式$u_1+u_2+u_3+…+u_n+…$称为无穷级数，简称级数，记为$$\\sum_{n=1}^{\\infty}u_n=u_1+u_2+u_3+…+u_n+…$$称每一项$u_n$为常数的级数$\\sum_{n=1}^{\\infty}u_n$为常数项级数。 称每一项$u_n$为函数的级数$\\sum_{n=1}^{\\infty}u_n$为函数项级数。 称级数$\\sum_{n=1}^{\\infty}u_n$的前n项之和$S_n$，为级数的部分和。 常用方法：裂项法 级数的基本性质若级数$\\sum_{n=1}^{\\infty}u_n$收敛，则$\\sum_{n=1}^{\\infty}ku_n$也收敛。 若两收敛级数$s=\\sum_{n=1}^{\\infty}u_n$,$\\sigma=\\sum_{n=1}^{\\infty}v_n$，则级数$\\sum_{n=1}^{\\infty}{u_n\\pm v_n}$收敛，其和为$s\\pm\\sigma$。 等等… 级数收敛的必要条件若$n$无限增大时，他的一般项$u_n$趋于零，即级数$\\sum_{n=1}^{\\infty}u_n$收敛，则$lim_{n\\to \\infty}u_n=0$。 （应用）即：若一般项$u_n$不趋于零，则级数发散。 8.2常数项级数的判别法$$\\sum_{n=1}^{\\infty}\\dfrac{1}{n^2}=\\dfrac{\\pi^2}{6}$$ 正项级数与其审敛法定义：若级数$\\sum_{n=1}^{\\infty}u_n$中各项均有$u_n\\geq 0$，称此级数为正项级数。 性质：若$S_n$为有界数列，则$lim_{n\\to \\infty}S_n=S$，则收敛。 若$S_n$为无界数列，则$lim_{n\\to \\infty}S_n=+\\infty$，则发散。 定理：若$\\sum_{n=1}^{\\infty}u_n$为正项级数，则级数$\\sum_{n=1}^{\\infty}u_n$收敛的充分必要条件为它的部分和数列$S_n$有界。 比较审敛法设$\\sum_{n=1}^{\\infty}u_n$和$\\sum_{n=1}^{\\infty}v_n$均为正项级数，且$u_n\\leq v_n$，若$\\sum_{n=1}^{\\infty}v_n$收敛，则$\\sum_{n=1}^{\\infty}u_n$收敛；若$\\sum_{n=1}^{\\infty}u_n$发散，则$\\sum_{n=1}^{\\infty}v_n$发散。 不便：须有参考级数。 极限形式： 设$\\sum_{n=1}^{\\infty}u_n$和$\\sum_{n=1}^{\\infty}v_n$均为正项级数，$v_n&gt;0$，若$lim_{n\\to \\infty}\\dfrac{u_n}{v_n}=l$， 当$0&lt;l&lt;+\\infty$时，两级数有相同的敛散性。 当$l=0$时，若$\\sum_{n=1}^{\\infty}v_n$收敛，则$\\sum_{n=1}^{\\infty}u_n$收敛。 当$l=+\\infty$时，若$\\sum_{n=1}^{\\infty}v_n$发散，则$\\sum_{n=1}^{\\infty}u_n$发散。 关键之处：找到合适的比较对象 3个重要的参考级数 调和级数：$\\sum_{n=1}^{\\infty}\\dfrac{1}{n}$：发散。 几何级数：$\\sum_{n=1}^{\\infty}aq^n$，$|q|\\geq1$：发散；$|q|&lt;1$：收敛。 p-级数：$\\sum_{n=1}^{\\infty}\\dfrac{1}{n^p}$，$q&gt;1$：发散；$q\\leq1$：收敛。 均值不等式：$ab={a^2}+{b^2}$ 比值审敛法（达朗贝尔判别法）设$\\sum_{n=1}^\\infty u_n$为正项级数，$u_n&gt;0$，若$lim_{n\\to \\infty}\\dfrac{u_{n+1}}{u_n}=\\rho$，则 $\\rho&lt;1$时级数收敛； $\\rho&gt;1$时级数发散； $\\rho=1$时级数敛散性未定。 注意： 比值审敛法优点: 不必找参考级数. 比值审敛法的条件是充分而非必要的. 根值审敛法（Cauchy判别法）设$\\sum_{n=1}^\\infty u_n$为正项级数，如果$lim_{n\\to \\infty}\\sqrt[n]{u_n}=\\rho$，则 $\\rho&lt;1$时级数收敛； $\\rho&gt;1$时级数发散； $\\rho=1$时级数敛散性未定。 注意： 比值审敛法优点: 不必找参考级数. 比值审敛法的条件是充分而非必要的. 交错级数及其审敛法定义：称正，负项交替出现的级数为交错级数. 定理（莱布尼兹判别式）若交错级数$\\sum_{n=1}^\\infty (-1)^{n-1}u_n$满足如下条件： $u_n\\geq u_{n+1}\\geq0$ $lim_{n\\to \\infty} u_n=0$ 则级数$\\sum_{n=1}^\\infty (-1)^{n-1}u_n$收敛，且其和$S\\leq u_1$，其余项$R_n$的绝对值$|R_n|\\leq u_{n+1}$ 绝对收敛与条件收敛任意项级数：正项和负项任意出现的级数。 定理若$\\sum_{n=1}^\\infty |u_n|$收敛，则$\\sum_{n=1}^\\infty u_n$，称$\\sum_{n=1}^\\infty u_n$绝对收敛。 定理的作用：从任意项级数-&gt;正项级数 绝对收敛定义：若$\\sum_{n=1}^\\infty |u_n|$收敛，称$\\sum_{n=1}^\\infty u_n$绝对收敛。 条件收敛定义：若$\\sum_{n=1}^\\infty |u_n|$发散，$\\sum_{n=1}^\\infty u_n$收敛，称$\\sum_{n=1}^\\infty u_n$条件收敛。 定理绝对收敛级数的任一重排级数绝对收敛于原级数的和。 （条件收敛不一定成立） 黎曼定理设级数$\\sum_{n=1}^\\infty u_n$条件收敛，任给$B$（有穷实数或$\\pm\\infty$），都有$\\sum_{n=1}^\\infty u_n$的一个重排$\\sum_{n=1}^\\infty u_n^$，使得$B=\\sum_{n=1}^\\infty u_n^$。 一般项级数的敛散性 一般项级数敛散性的判别过程 8.3幂指数收敛点与收敛域如果$x_0\\in I$，且函数项级数$\\sum_{n=1}^\\infty u_n(x_0)$收敛，称$x_0$为级数$\\sum_{n=1}^\\infty u_n(x)$的收敛点，否则称为级数的发散点。级数$\\sum_{n=1}^\\infty u_n(x)$的所有收敛点的全体称为收敛域，所有发散点的全体称为发散域。 定义称形如$\\sum_{n=0}^\\infty a_n(x-x_0)^n$的级数为幂函数。 定理1（Abel定理）若级数 $\\sum_{n=0}^\\infty a_n x^n$在$x=x_0(x_0\\not =0)$点收敛，则它在满足不等式$|x|&lt;|x_0|$的一切$x$处绝对收敛；若级数 $\\sum_{n=0}^\\infty a_n x^n$在$x=x_0(x_0\\not =0)$点发散，则它在满足不等式$|x|&gt;|x_0|$的一切$x$处发散。 定理2若级数 $\\sum_{n=0}^\\infty a_n x^n$的所有系数$a_n\\not =0$，设$lim_{n\\to\\infty}|\\dfrac{a_{n+1}}{a_n}|=\\rho(lim_{n\\to\\infty}\\sqrt[n]{|a_n|}=\\rho)$，则 当$\\rho\\not =0$时，$R=\\dfrac{1}{\\rho}$； 当$\\rho =0$时，$R=+\\infty$； 当$\\rho =+\\infty$时，$R=0$。 和函数的分析运算性质 极限运算与求和运算可交换顺序； 积分运算与求和运算可交换顺序； 求导运算与求和运算可交换顺序。 已知和函数的幂级数 $$\\sum_{n=0}^ \\infty x^n=\\dfrac{1}{1-x}$$ $$\\sum_{n=0}^\\infty(-1)^n x^{2n}=\\dfrac{1}{1+x^2}$$ $$\\sum_{n=0}^\\infty a x^{2n}=\\dfrac{a}{1-x^2}$$ $$\\sum_{n=0}^\\infty\\dfrac{x^n}{n!}=e^x$$ $$\\sum_{n=1}^\\infty(-1)^{n-1}\\dfrac{x^{2n-1}}{(2n-1)!}=sin{x}$$ $$\\sum_{n=0}^\\infty(-1)^{n-1}\\dfrac{x^{2n}}{(2n)!}=cos{x}$$ $$\\sum_{n=0}^\\infty(-1)^n\\dfrac{x^{n+1}}{n+1}=ln(1+x)$$ 8.4函数展开成幂级数泰勒级数定理1设函数$f(x)$ 在$x_0$的某个邻域U$(x_0,\\delta_0$)内具有任意阶导数，则函数f(x)在该点邻域内能展开成泰勒级数的充要条件是$f(x)$的泰勒公式中的余项$R_n(x)$满足$$lim_{n\\to\\infty}R_n(x)=0;\\forall x\\in N(x_0,\\delta_0)$$ 定理2如果$f(x)$在区间$(-R+x_0,R+x_0)$能展开成泰勒级数$$f(x)=\\sum_{n=0}^\\infty \\dfrac{f^{(n)}(x_0)}{n!}(x-x_0)^n$$则右端的幂级数是唯一的。 函数展开成幂级数 直接法（泰勒级数法）步骤：求$a_n$，讨论$lim_{n\\to\\infty}R_n(x)=0$，写出$f(x)$。 间接法，根据唯一性，利用常见展开式，通过变量代换，四则运算，恒等变形，逐项求导，逐项积分等方法，求展开式。 8.5幂级数的应用欧拉公式$$e^{ix}=cosx+isinx$$ 8.6傅里叶级数三角级数$$\\dfrac{a_0}{2}+\\sum_{n=1}^\\infty(a_ncosnx+b_nsinnx)$$ 函数展开成傅里叶级数$$f(x)=\\dfrac{a_0}{2}+\\sum_{n=1}^\\infty(a_ncosnx+b_nsinnx)$$ 其中，$$a_0=\\dfrac{1}{\\pi}\\int_{-\\pi}^\\pi f(x)dx$$ $$a_n=\\dfrac{1}{\\pi}\\int_{-\\pi}^{\\pi}f(x)cos{nx}dx(n=0,1,2,…)$$ $$b_n=\\dfrac{1}{\\pi}\\int_{-\\pi}^{\\pi}f(x)sin{nx}dx(n=1,2,…)$$ 狄利克雷收敛定理设$f(x)$是以$2\\pi$为周期的周期函数，若它在一个周期内连续或只有有限个第一类间断点，且至多有限个极值点，则$f(x)$的傅立叶级数收敛，而且 当$x$为连续点时，级数收敛于$f(x)$； 当$x$为间断点时，级数收敛于$\\dfrac{f(x-0)+f(x+0)}{2}$； 当$x=\\pm\\pi$是，级数收敛于$\\dfrac{f(-\\pi+0)+f(\\pi-0)}{2}$。 8.7正弦级数和余弦级数奇函数和偶函数的傅里叶级数定理周期为$2\\pi$的奇函数$f(x)$的傅里叶级数的系数为 $$a_n=0,b_n=\\dfrac{2}{\\pi}\\int_{0}^{\\pi}f(x)sin{nx}dx(n=1,2,…),f(x):\\sum_{n=1}^\\infty b_nsinnx$$为正弦级数。 周期为$2\\pi$的偶函数$f(x)$的傅里叶级数的系数为 $$a_n=\\dfrac{2}{\\pi}\\int_{0}^{\\pi}f(x)cos{nx}dx,b_n=0,(n=1,2,…),f(x):\\dfrac{a_0}{2}+\\sum_{n=1}^\\infty a_ncosnx$$为余弦级数。 函数展开成正弦级数或余弦级数非周期函数的周期延拓 设$f(x)$定义在[0,$\\pi$]上，延拓成以$2\\pi$为周期的函数$F(x)$。令$$F(x) = \\begin{cases} f(x) &amp; 0\\leq x\\leq\\pi \\ g(x) &amp; -\\pi&lt;x&lt;0\\end{cases}，且F(x+2\\pi)=F(x)$$则有两种情况，奇延拓和偶延拓。 8.8任意周期函数的傅里叶级数以$2l$为周期的傅里叶级数若周期为$2l$的周期函数$f(x)$满足收敛定理跳条件，则它的傅里叶级数展开式为$$f(x)=\\dfrac{a_0}{2}+\\sum_{n=1}^{\\infty}(a_ncos\\dfrac{n\\pi x}{l}+b_nsin\\dfrac{n\\pi x}{l})$$其中，系数$a_n$,$b_n$为$$a_n=\\dfrac{1}{l}\\int_{-l}^{l}f(x)cos\\dfrac{n\\pi x}{l}dx(n=0,1,2,…)$$ $$b_n=\\dfrac{1}{l}\\int_{-l}^{l}f(x)sin\\dfrac{n\\pi x}{l}dx(n=1,2,…)$$","tags":[{"name":"Math","slug":"Math","permalink":"ronpay.xyz/tags/Math/"}]},{"title":"离散数学笔记","date":"2020-07-31T02:31:36.000Z","path":"2020/07/31/离散数学笔记/","text":"第1章 集合论空集 空集是一切集合的子集。 空集值是绝对唯一的. 集合基数集合$A$中元素的数目称为集合$A$的基数，记为$|A|$。 m元子集如果一个集合$A$含有$n$个元素，则称集合$A$为$n$元集，称$A$的含有$m$个$(0≤m≤n)$元素的子集为$A$的$m$元子集。 幂集设$A$为任意集合，把$A$的所有不同子集为元素构成的集合叫做$A$的幂集，记为$P(A)$或$2^A$。 有$|P(A)|＝ 2^{|A|}$ 等势设$A，B$是两个集合，若在$A，B$之间存在$1-1$对应的关系：$ψ：A→B$ 则称$A$与$B$是等势的，记为：$A$~$B$。 凡是与自然数集合等势的集合，均称为可数集合(可列集)。可数集合的基数记为：$\\aleph_0$(读作阿列夫零) 。 不可数集合 开区间 $(0, 1)$ 称为不可数集合，其基数记为为$\\aleph$ (读作阿列夫)； 凡是与开区间 $(0, 1)$ 等势的集合都是不可数集合。 集合运算定理设$A、B、C$为任意集合，$Ｕ$为全集，$Φ$为空集 幂等律: $A∪A=A$； $A∩A=A$； 恒等律: $A∪Φ =A$；$A∩U =A$； 零 律: $A∪U=U$； $A∩Φ=Φ$； 否定律：$\\overline{\\overline{A}}=A$； 矛盾律： $A∩\\overline{A}＝Φ$； 排中律：$A∪\\overline{A}＝U$ 交换律: $A∪B=B∪A$; $A∩B=B∩A$ 吸收律: $A∩(A∪B)=A$; $A∪(A∩B)=A$； DeMorgan律：$\\overline{A∪B}=\\overline{A}∩\\overline{B}$，$\\overline{A∩B}=\\overline{A}∪\\overline{B}$ 结合律：$A∪(B∪C)=(A∪B)∪C$；$A∩(B∩C)=(A∩B)∩C$； 分配律：$A∩(B∪C)=(A∩B)∪(A∩C)$;$A∪(B∩C)=(A∪B)∩(A∪C)$ 第2章 计数问题鸽笼原理若有$n+1$只鸽子住进$n$个鸽笼，则有一个鸽笼至少住进$2$只鸽子。 第3章 命题逻辑基本等价公式设$G，H，S$是任何的公式，则： E1：$G∨(H∨S)＝(G∨H)∨S$ (结合律) E2：$G∧(H∧S)＝(G∧H)∧S$ E3：$G∨H＝H∨G$ (交换律) E4：$G∧H＝H∧G$ E5：$G∨G＝G$ (幂等律) E6：$G∧G＝G$ E7：$G∨(G∧H)＝ G$ (吸收律) E8：$G∧(G∨H)＝ G$ E9：$G∨(H∧S)＝(G∨H)∧(G∨S)$ (分配律） E10：$G∧(H∨S)＝(G∧H)∨(G∧S)$ E11：$G∨0＝G$ (同一律) E12：$G∧1＝G$ E13：$G∨1＝1$ (零律) E14：$G∧0＝0$ E15：$G∨┐G ＝ 1$ (排中律) E16：$G∧┐G ＝0$ (矛盾律) E17：$┐(┐G)＝G$ (双重否定律) E18：$┐(G∨H)＝┐G∧┐H$ (德·摩根律) E19：$┐(G∧H)＝┐G∨┐H$ E20：$G→H＝┐G∨H$ (蕴涵式) E21: $G\\leftrightarrow H＝(G→H)∧(H→G)$ (等价式) E22：$G →H＝┐H→┐G$ (假言易位) E23：$G\\leftrightarrow H＝┐G\\leftrightarrow ┐H$ (等价否定等式) E24：$(G →H) ∧(G→┐H)＝┐G$ (归谬论) 第4章 谓词逻辑谓词演算中的基本等价公式 E25：$(\\exists x)G(x) = (\\exists y)G(y)$ E26：$(\\forall x)G(x) = (\\forall y)G(y)$ E27： $\\neg(\\exists x)G(x) = (\\forall x)\\neg G(x)$ E28：$\\neg(\\forall x)G(x) = (\\exists x)\\neg G(x)$ E29：$(\\forall x)(G(x)∨S) = (\\forall x)G(x)∨S$ E30：$(\\forall x)(G(x)∧S) = (\\forall x)G(x)∧S$ E31：$(\\exists x)(G(x)∨S) = (\\exists x)G(x)∨S$ E32：$(\\exists x)(G(x)∧S) = (\\exists x)G(x)∧S$ E33：$(\\forall x)(G(x)∧H(x)) = (\\forall x)G(x)∧(\\forall x)H(x)$ E34：$(\\exists x)(G(x)∨H(x)) = (\\exists x)G(x)∨(\\exists x)H(x)$(量词分配律) E35：$(\\forall x)G(x)∨(\\forall x)H(x) = (\\forall x)(\\forall y)(G(x)∨H(y))$ E36：$(\\exists x)G(x)∧(\\exists x)H(x) = (\\exists x)(\\exists y)(G(x)∧H(y))$ 第5章 证明技术演绎法证明符号： P：条件； T，，，I：由→推理得到； T，，，E：有蕴涵式可得； P（附加前提）：附加条件； CP：使用附加前提要用CP规则； US：去任意量词 ES：去存在量词 UG：加任意量词 EG：加存在量词 数学归纳法第6章 二元关系自反性和反自反性如果对任意$x∈A$，都有$&lt;x, x&gt;∈R$，那么称$R$在$A$上是自反的。 如果对任意$x∈A$，都有$&lt;x, x&gt;\\not\\in R$，那么称$R$在$A$上是反自反的。 对称性和反对称性对任意$x, y∈A$，如果$&lt;x, y&gt;∈R$，那么$&lt;y,x&gt; ∈R$，则称关系$R$是对称的。 对任意$x, y∈A$，如果$&lt;x, y&gt;∈R$且$&lt;y,x&gt;∈R$，那么$x＝y$，则称关系$R$是反对称的。 传递性对任意$x, y, z∈A$，如果$&lt;x, y&gt;∈R$且$&lt;y, z&gt;∈R$，那么$&lt;x, z&gt;∈R$，则称关系$R$是传递的。 关系性质的保守性设$R, S$是定义在$A$上的二元关系，则： 若$R,S$是自反的，则$R^{-1},R∪S,R∩S,RoS$也是自反的 若$R, S$是反自反的，则$R^{-1}, R∪S, R∩S, RoS$也是反自反的 若$R,S$是对称的，则$R^{-1},R∪S,R∩S,RoS$也是对称的 若$R,S$是反对称的，则$R^{-1}, R∩S, RoS$也是反对称的 若$R,S$是传递的，则$R^{-1}, R∩S$也是传递的 关系的闭包设$R$是定义在$A$上的关系，若存在$A$上的另一个关系$R′$，使得$R\\subseteq R′$，满足： 1.$R′$是自反的（对称的、或传递的）； 2.任何自反的（对称的、或传递的）关系$R〞$，如果$R\\subseteq R$〞，就有$R′\\subseteq R〞$， 则称$R′$为$R$的自反闭包（对称闭包或传递闭包），分别记为$r(R)$ （$s(R)$或$t(R)$）。 关系的闭包是增加最少元素，使其具备所需性质的扩充。 第7章 特殊关系等价关系设R是定义在非空集合A上的关系，如果R是自反的、对称的、传递的，则称R为A上的等价关系。 等价类设$R$是非空集合$A$上的等价关系，对任意$x∈A$，称集合 $[x]_R = {y|y∈A∧&lt;x,y&gt;∈R}$ 为$x$关于$R$的等价类，其中$x$称为$[x]_R$的生成元 。 $R$具有自反性意味着对任意$x∈A，[x]_R ≠ Φ$。 $R$具有对称性意味着对任意$x, y∈A$，若有$y∈[x]R$，则一定有$x∈[y]_R$。 商集设$R$是非空集合$A$上的等价关系，由$R$确定的一切等价类为元素构成的集合，称为集合$A$关于$R$的商集，记为$A/R$，即$A/R = { [x]R | x∈A }$ 等价关系与划分给定集合A的一个划分$П = {A1, A2, …, An}$， 则由该划分确定的关系$R = (A1×A1)∪(A2×A2)∪…∪(An×An)$是$A$上的等价关系。我们称该关系$R$为由划分$П$所导出的等价关系。 拟序关系设$R$是非空集合$A$上的关系，如果$R$是反自反、反对称和传递的，则称$R$是$A$上的拟序关系，简称拟序，记为“$＜$”，读作“小于”，并将“$&lt;a, b&gt;∈＜$”记为“$a＜b$”。 序偶&lt;A, ＜&gt;称为拟序集。拟序“$＜$”的逆关系“$＜^{-1}$”也是拟序，用“$＞$”表示，读作“大于”。 偏序关系设$R$是非空集合$A$上的关系，如果$R$是自反的、反对称的和传递的，则称$R$是$A$上的偏序关系，简称偏序，记为“$≤$”。 偏序“$≤$”的逆关系“$≤-1$”也是一个偏序，我们用“$≥$”表示，读作“大于等于”；$(≤-I_A)$为$A$上的拟序关系，$(＜∪I_A)$为$A$上的偏序关系。 哈斯图 用小圆圈或点表示A中的元素，省掉关系图中所有的环； （因自反性) 对任意$x, y∈A$，若$x＜y$，则将$x$画在$y$的下方，可省掉关系图中所有边的箭头；（因反对称性）对任意$x, y∈$A，若$x＜y$，且不存在$z∈A$，使得$x＜z, z＜y$，则$x$与$y$之间用一条线相连，否则无线相连。（因传递性） 偏序集的特殊元素设$&lt;A, ≤&gt;$是偏序集，$B$是$A$的任何一个子集。若存在元素$a∈A$，使得 对任意$x∈B$，都有$x ≤ a$，则称$a$为$B$的上界； 对任意$x∈B$，都有$a ≤ x$，则称$a$为$B$的下界； 若元素$a′∈A$是$B$的上界，元素$a∈A$是$B$的任何一个上界，均有$a′ ≤ a$，则称$a′$为$B$的最小上界或上确界，记为SupB； 若元素$a′∈A$是$B$的下界，元素$a∈A$是$B$的任何一个下界，均有$a ≤ a′$，则称$a′$为$B$的最大下界或下确界，记为InfB。 全序关系设$&lt;A, ≤ &gt;$为偏序集，若对任意$x, y∈A$，总有$x ≤ y$或$y ≤ x$，二者必居其一，则称关系“$≤$”为全序关系(Total Order Relation)，简称全序，或者线序关系，简称线序。称$&lt;A, ≤ &gt;$为全序集(Total Order Set)，或者线序集，或者链(Chain)。 良序关系设$&lt;A, ≤ &gt;$是一偏序集，若$A$的每个非空子集都有最小元，则称“$≤$”为良序关系，简称良序，此时$&lt;A, ≤ &gt;$称为良序集。良序关系一定是全序关系，反之则不然。 第8章 函数函数的定义设$f$是集合$A$到$B$的关系，如果对每个$x∈A$，都存在惟一的$y∈B$，使得$&lt;x, y&gt;∈f$，则称关系f为A到B的函数(Function)(或映射(Mapping)、变换(Transform))，记为$f: A→B$。 当$&lt;x, y&gt;∈f$时，通常记为$y = f(x)$，这时称$x$为函数$f$的自变量，$y$为$x$在$f$下的函数值(或象)， 也称$x$为$y$在$f$下的原象 。 称$A$为函数$f$的定义域，记为$domf$称$f(A) = y| y = f(x), x∈A$为函数 $f$ 的值域，记为$ranf$若$A = B$，则称$f$为$A$上的函数 函数的类型设$f$是从$A$到$B$的函数，对任意$x1, x2∈A$， 如果$x1 ≠ x2$，有$f(x1) ≠ f(x2)$，则称$f$为从$A$到$B$的单射（不同的$x$对应不同的$y)$ 如果$ranf = B$，则称$f$为从$A$到$B$的满射 若$f$是满射且是单射，则称$f$为从$A$到$B$的双射 当$A$上的函数$f$是双射时，称$f$为变换 定理设$A, B$是有限集合，且$|A| = |B|$，$f$是$A$到$B$的函数，则$f$是单射当且仅当$f$是满射。 函数的运算考虑$f: A→B，g: B→C$是两个函数，则 $fog = { &lt;x, z&gt; | x∈A{∧}z∈C{∧}(\\exists y)(y∈B{∧}&lt;x, y&gt;∈f{∧}&lt;y, z&gt;∈g)}$从$A$到$C$的函数，记为$fog: A→C$ ，称为函数$f$与$g$的复合函数。对任意$x∈A，fog(x) = g(f(x))$。 定理若$f$是$A$到$B$的双射，则$f$的逆函数$f^{-1}$也是$B$到$A$的双射。 第9章 图特殊图 仅由孤立结点组成的图称为零图(Null Graph) 仅含一个结点的零图称为平凡图(Trivial Graph) 含有n个结点，m条边的图，称为(n, m)图 图的分类在有向图中，两结点间(包括结点自身间)若有同始点和同终点的几条边，则这几条边称为平行边，在无向图中，两结点间(包括结点自身间)若有几条边，则这几条边称为平行边。两结点a、b间相互平行的边的条数称为边(a, b)或&lt;a, b&gt;的重数(Repeated Number)。 含有平行边的图称为多重图(Multigraph) 非多重图称为线图(Line Graph)； 无环的线图称为简单图(Simple Graph) 子图和补图 若$V_1 =V$，$E_1$包含于 $E$，则称$G_1$是$G$的生成子图(Spanning Subgraph) 设$V_2$ 包含于$V$且$V_2$ ≠ 空集，以$V_2$为结点集，以两个端点均在$V_2$中的边的全体为边集的$G$的子图，称为$V_2$导出的$G$的子图，简称$V_2$的导出子图(Induced Subgraph) 设$G = &lt;V, E&gt;$为一个具有$n$个结点的无向简单图，如果$G$中任意两个结点间都有边相连，则称G为无向完全图(Undirected Complete Graph)，简称$G$为完全图(Complete Graph)，记为$K_n$。 设$G = &lt;V, E&gt;$为一个具有$n$个结点的有向简单图，如果$G$中任意两个结点间都有两条方向相反的有向边相连，则称$G$为有向完全图(directed Complete Graph)，在不发生误解的情况下，也记为$K_n$。 结点的度数与握手定理对于图$G = &lt;V, E&gt;$，度数为$1$的结点称为悬挂结点(Hanging Point)，以悬挂结点为端点的边称为悬挂边(Hanging Edge)。 握手定理图中结点度数的总和等于边数的二倍，即设图G $= &lt;V, E&gt;$，则有$$\\sum_{v\\in V}deg(v)=2|E|$$ 推论图中度数为奇数的结点个数为偶数。 第11章 特殊图欧拉图设$G$是无孤立结点的图，若存在一条通路(回路)，经过图中每边一次且仅一次，则称此通路(回路)为该图的一条欧拉通路(回路)(Eulerian Entry/Circuit)。具有欧拉回路的图称为欧拉图(Eulerian Graph)。 规定：平凡图为欧拉图。以上定义既适合无向图，又适合有向图。 欧拉图的判定定理11.2.1 无向图$G = &lt;V, E&gt;$具有一条欧拉通路，当且仅当$G$是连通的，且仅有零个或两个奇度数结点。规定：平凡图为欧拉图。以上定义既适合无向图，又适合有向图。 定理11.2.2 有向图$G$具有欧拉通路，当且仅当$G$是连通的，且除了两个结点以外，其余结点的入度等于出度，而这两个例外的结点中，一个结点的入度比出度大1，另一个结点的出度比入度大1。 欧拉图的算法设$G = &lt;V, E&gt;，e∈E$，如果$p(G-e)＞p(G)$,称$e$为$G$的桥(Bridge)或割边(Cut edge)。 其中，$p$表示连通分量的个数。 求欧拉图$G = &lt;V, E&gt;$的欧拉回路的Fleury算法：任取$v_0∈V，令P_0 = v_0，i = 0$； 按下面的方法从$E-{e_1, e_2, …, e_i}$中选取$e_{i+1}$：要求：$e_{i+1}$与$v_i$相关联；除非无别的边可选取，否则$e_{i+1}$不应该为$ G’ = G - {e_1, e_2, …, e_i}$中的桥； 将边$e_{i+1}$加入通路$P_0$中，令$P_0 = v0e1v1e2…eivie_{i+1}v_{i+1}， i = i+1$； 如果$i = |E|$，结束，否则转(2)。 “一笔画问题”本质上就是一个无向图是否存在欧拉通路(回路)的问题。 哈密顿图的定义经过图中每个结点一次且仅一次的通路(回路)称为哈密顿通路(回路)(Hamiltonian Entry/circuit)。存在哈密顿回路的图称为哈密顿图(Hamiltonian Graph)。规定：平凡图为哈密顿图。以上定义既适合无向图，又适合有向图。 哈密顿图的判定定理11.3.1 设无向图$G = &lt;V, E&gt;$是哈密顿图，$V_1$是$V$的任意非空子集，则$p(G-V_1) ≤ |V_1|$ 其中$p(G-V_1)$是从$G$中删除$V_1$后所得到图的连通分支数。 定理11.3.1在应用中它本身用处不大，但它的逆否命题却非常有用。我们经常利用定理11.3.1的逆否命题来判断某些图不是哈密顿图，即：若存在$V$的某个非空子集$V_1$使得 $p(G-V_1)＞|V_1|$，则$G$不是哈密顿图。 (以下为充分条件) 定理11.3.2 设$G = &lt;V, E&gt;$是具有$n$个结点的简单无向图。如果对任意两个不相邻的结点$u, v∈V$，均有$deg(u) + deg(v) ≥ n - 1$,则$G$中存在哈密顿通路。 推论11.3.2 设$G = &lt;V, E&gt;$是具有$n$个结点的简单无向图。如果对任意两个不相邻的结点$u, v∈V$，均有$deg(u) + deg(v) ≥ n$,则$G$中存在哈密顿回路。 推论11.3.3 设$G = &lt;V, E&gt;$是具有$n$个结点的简单无向图，$n ≥ 3$。如果对任意$v∈V$，均有$deg(v) ≥ n/2$，则$G$是哈密顿图。 偶图定义11.4.1 若无向图$G = &lt;V, E&gt;$的结点集$V$能够划分为两个子集$V_1, V_2$，满足$V_1∩V_2 = Φ$，$且V_1∪V_2 = V$，使得$G$中任意一条边的两个端点，一个属于$V_1$，另一个属于$V_2$，则称$G$为偶图(Bipartite Graph)或二分图(Bigraph)。$V_1$和$V_2$称为互补结点子集，偶图通常记为$G=&lt;V_1, E, V_2&gt;$。 定义11.4.2 在偶图$G = &lt;V_1, E, V_2&gt;$中，若$V_1$中的每个结点与$V_2$中的每个结点都有且仅有一条边相关联，则称偶图$G$为完全偶图(Complete Bipartite Graph)或完全二分图(Complete Bigraph)，记为$K_{i, j}$，其中，$i = |V_1|，j = |V_2|$。（即第一个集合中的所有顶点都与第二个集合中的所有顶点相连） 偶图的判断 定理11.4.1 无向图$G = &lt;V, E&gt;$为偶图的充分必要条件是$G$的所有回路的长度均为偶数。 一般：我们常使用它的逆否命题来判断一个图不是偶图：无向图$G$不是偶图的充分必要条件是$G$中存在长度为奇数的回路。 匹配定义11.4.2 在偶图$G = &lt;V_1, E, V_2$&gt;中，$V_1 = {v_1, v_2, …, v_q}$，若存在$E$的子集$E’ = {(v_1, v_1’)，(v_2, v_2’)，…，(v_q, v_q’)}$，其中$v1’, v2’, …, vq’ $是$V2$中的$q$个不同的结点}，则称$G$的子图$G’ = &lt;V_1, E’, V_2&gt;$为从$V_1$到$V_2$的一个完全匹配(Complete Matching)，简称匹配。 定理11.4.2 (霍尔定理) 偶图$G = &lt;V_1, E, V_2&gt;$中存在从$V_1$到$V_2$的匹配的充分必要条件是$V_1$中任意$k$个结点至少与$V_2$中的$k$个结点相邻，$k = 1, 2, …, |V_1|$.定理11.4.2中的条件通常称为相异性条件(Diversity Condition)。 定理11.4.3 设$G = &lt;V_1,E,V_2&gt;$是一个偶图。如果满足条件 （1）$V_1$中每个结点至少关联$t$条边； （2）$V_2$中每个结点至多关联$t$条边；则$G$中存在从$V_1$到$V_2$的匹配。其中$t$为正整数。 平面图如果能把一个无向图$G$的所有结点和边画在平面上，使得任何两边除公共结点外没有其他交叉点，则称$G$为平面图(Plane Graph)，否则称$G$为非平面图(Nonplanar Graph)。 欧拉公式 由边所包围的其内部不包含图的结点和边的区域，称为$G$的一个面(Surface) 包围该面的边所构成的回路称为这个面的边界(Bound) 面$r$的边界的长度称为该面的次数(Degree)，记为$D(r)$ 区域面积有限的面称为有限面(Finite Surface)，区域面积无限的面称为无限面(Infinite Surface) 平面图有且仅有一个无限面 定理11.5.1 平面图中所有面的次数之和等于边数的二倍。怎么理解？每条边会被用两次 定理11.5.2 设$G = &lt;V, E&gt;$是连通平面图，若它有$n$个结点、$m$条边和$r$个面，则有 $$n – m + r = 2$$ 推论11.5.1 设$G$是一个$(n, m)$简单连通平面图，若$m＞1$，则有$m ≤ 3n - 6$。 一般使用逆否命题，即一个简单连通图，若不满足 $m ≤ 3n - 6$，则一定是非平面图。 推论11.5.2 设$G$是一个$(n, m)$简单连通平面图，若每个面的次数至少为$k (k ≥ 3)$，则有 $m\\leq\\dfrac{k}{k-2}(n-2)$ 完全图$K_5$，$k_{3,3}$是非平面图。 库拉托夫斯基定理定理11.5.3(库拉托夫斯基定理) 一个图是平面图的充分必要条件是它的任何子图都不可能收缩为$K5$或$K3, 3$。 推论11.5.3 一个图是非平面图的充分必要条件是它存在一个能收缩为$K_5$或$K_{3, 3}$的子图。 $K_5$和$K_{3,3}$称为库拉托夫斯基图(Kuratowski Graph)。 离散数学题型笔记选择题计算题主析取范式和主合取范式进行化简。 通过添加P∧P，P∨P，来凑取。 求得一个可以推下一个。 确定是析取还是合取。 证明题演绎推理通过演绎推理，注意P-&gt;Q 与 P∨Q的区别。 证明符号： P：条件； T，序号，序号，I：由→推理得到； T，序号，序号，E：有蕴涵式可得； P（附加前提）：附加条件； CP：使用附加前提要用CP规则； US：去任意量词 ES：去存在量词 UG：加任意量词 EG：加存在量词","tags":[{"name":"Math","slug":"Math","permalink":"ronpay.xyz/tags/Math/"}]},{"title":"2020嵌入式工作室招新Linux方向招新题","date":"2020-07-01T14:32:54.000Z","path":"2020/07/01/Linux Learning/","text":"（因使用外链，部分图片挂了，有空再补） 第一关：初识Linux基础篇Linux是一种自由和开放源码的类UNIX操作系统。 Linux的优势在于开源，系统的源码是共享的，方便我们自行修改Linux系统，增加或修改所需要的功能，从而得到定制化的系统。服务器端的系统也常常是Linux，使用Linux作为环境，便于软件的调试。Linux 的强大的定制功能和低廉的成本，使得它在嵌入式系统得到广泛的运用。 因选修课使用过Ubuntu 16.04TLS，因此选择了VMware Workstation 安装 Ubuntu 20.04TLS。选择新版本的原因在于新的Linux版本会采用新的Linux内核。 首先在软件与更新中，更换软件源，提高下载速度。 安装chrome,vscode,typora,安装的方式看官网的步骤便可。 1234#install chromewget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.debsudo apt install ./google-chrome-stable_current_amd64.debcat /etc/apt/sources.list.d/google-chrome.list 设置网络代理 在主机的代理软件（Clash for Windows）上勾选允许LAN连接，然后在Ubuntu的网络代理中，设置手动，对所有的项，将地址设置为主机IP，端口设置为代理软件的端口，从而实现科学上网。 美化安装必要的程序 123sudo apt updatesudo apt install gnome-tweakssudo apt install chrome-gnome-shell 安装gnome的chrome扩展，启用User Theme。 然后更换主题、图标、鼠标，这些东西我全都选了Mac OS的主题，顺便换了壁纸。 在gnome主题网站，下载MccainMojave-circle图标、MoMojave主题、McMojave cursors，分别解压缩复制到./~/.themes 和 ./~/.icons目录，在优化中，启用相应主题、图标和鼠标。 在gnome网站上，下载Dash to dock美化dock栏。 效果如下： image-20200630213057555.png 加分项使用了Github+Hexo博客的搭建方式，使用了Hexo的Next主题。 第二关：知识积累Linux 常用命令 cd命令 123回到上一次目录 cd -回到要目录 cd &#x2F;回到home目录 cd ~ mkdir命令 ls命令 12#所有文件 ls -a mv命令 12重命名 mv src dest移动 mv filename pathname(.&#x2F;表示当前位置，) rm命令 12删除文件 rm filename删除文件夹 rm -rf filename tar命令 1解压 tar -zxvf filename.tar.bz2 vim命令 1进入&#x2F;创造文件 vim filename make命令（编译） chmod命令（更改访问权限） Ctrl+C ，在后面讲述到，其实是通过终端向程序发出SIGINT信号，终止当前的进程。 ln命令（功能是为某一个文件在另外一个位置建立一个同步的链接） 1ln [参数][源文件或目录][目标文件或目录] Ubuntu常用命令12345678#安装软件 sudo apt-get install package#更新源 sudo apt-get update#更新已安装的包 sudo apt-get upgrade#安装deb包的方式sudo dpkg -i [deb包] GCC 安装及 编译C语言安装一般GCC的方法12345678#输入下面的命令，安装想要的 GCC 和 G++ ：sudo apt install gcc-8 g++-8 gcc-9 g++-9 gcc-10 g++-10#下面的命令配置每一个版本，并且设置了优先级。默认的版本是拥有最高优先级的那个，在我们的场景中是gcc-10。sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-10 100 --slave /usr/bin/g++ g++ /usr/bin/g++-10 --slave /usr/bin/gcov gcov /usr/bin/gcov-10sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 90 --slave /usr/bin/g++ g++ /usr/bin/g++-9 --slave /usr/bin/gcov gcov /usr/bin/gcov-9sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-8 80 --slave /usr/bin/g++ g++ /usr/bin/g++-8 --slave /usr/bin/gcov gcov /usr/bin/gcov-8#以后，如果你想修改默认的版本，使用update-alternatives命令：sudo update-alternatives --config gcc 编译C语言1234567#编译C语言#命名为helloworldgcc -o helloworld helloworld.c #执行./helloworld#自动生成hello.o，但不会生成二进制执行文件，等待后续链接。gcc -c hello.c 安装特定版本的GCC的方法（编译）（去Google上搜相应的方法，十分麻烦都要分别安装依赖项。最后找了一个英文网页，没几行命令，然后再等待几十分钟的编译就行了。） 123456789101112131415#下载GCC源码wget https://ftpmirror.gnu.org/gcc/gcc-10.1.0/gcc-10.1.0.tar.xz#解压tar -zxvf gcc-10.1.0.tar.xz#下载依赖项cd gcc-10.1.0contrib/download_prerequisites#建立编译输出目录mkdir gcc-build#进入输出目录，执行命令，生成makefile文件../gcc-10.1.0/configure -v --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu --prefix=/usr/local/gcc-10.1.0 --enable-checking=release --enable-languages=c,c++,fortran --disable-multilib --program-suffix=-10.1#编译make -j 4#安装sudo make install-strip GCC-10.1编译安装效果，如下：（弄了好久也不知道怎么把它当作默认的gcc，估计安装路径有点问题） image-20200630213259310.png vimsudo apt-get install vim安装vim. vi/vim的使用刚启动vi/vim时，进入命令模式，输入i，切换输入模式， 输入模式常见命令 Esc进入命令模式 底线命令模式常见命令 q 退出程序 q!强制退出不保存 w 保存文件 wq 保存文件并退出程序 按ESC键退出底线命令模式 一般命令模式常见命令： i,o,a切换到输入模式，以输入字符。 x 向后删除一个字符(del),X 为向前删除一个字符（backspace) dd 删除整行的字符。 :,/,?切换到底线命令模式，以在最底一行输入命令。 gg 移动到第一行 dG删除光标所在处到最后一行所有数据 (n)yy复制光标那一行(光标往下n行) u回复前一个操作 ctrl+r重做上一个操作 /word向下寻找word ?word向上寻找word :sp filename 若打开同一个文件则无需filename。用ctrl+w+上 向上翻，用ctrl+w+下 向下翻 Ctrl x + ctrl n关键词补全 vim缓存与恢复打开不正常结束的vim时会出现缓存警告，可输入o,e,r,d,q,a分别表示只读open，编辑edit，加载缓存recover，删除缓存delete，停止quit，同停止abort。 vim 美化与插件 下载 molokai 主题 将 colors/molokai.vim 拷贝到 ~/.vim/colors/ 新建~/.vimrc文件，在 ~/.vimrc 中添加：colorscheme molokai （vim得安装很多插件才能有VSCode的intellisense、代码补全、自动格式化的功能，还不太习惯，不想折腾了，后面就用VSCode写了） vim-plug vim插件管理器，用于安装、管理插件。 The NERDTree 文件目录可视化的插件，使用vim-plug插件管理器安装，安装方法见vim-plug的GitHub页码。使用方式：在vim命令行形式，输入NERDTree。 安装教程在如上的Github页面都很详细，就不赘述了。 vim编写Hello.c和BST.c image-20200627122923712.png image-20200628113025534.png image-20200628114709524.png image-20200628114742290.png 第三关：进阶篇基础篇CPUCPU是一个具有特殊功能的芯片，里面含有指令集。内分为两个主要的单元，分别为算术逻辑单元，控制单元。CPU内部含有一些微指令，而指令集的设计分成两种设计理念，分别为两种CPU架构：精简指令集，复杂指令集。我们常用的Intel、AMD所用的便是复杂指令集，基于X86架构。 CPU频率：每秒钟可以进行的工作次数。（因为指令集、架构、二级缓存及其运算机制的不同、每一此频率可以运行的指令数不同，故不能单纯使用CPU频率来比较CPU性能。 现在CPU已经没有北桥，其中的内存控制器已经被整合到CPU内部了，使得CPU可以直接与内存、显卡进行通信，提高了效率 64位、32位的说法来自CPU每次能够处理的数据量，即字长。 超线程技术为何会有这种技术？因CPU命令执行周期太短，CPU内核长时间处于空置状态，同时系统是多任务系统，因此让多个任务使用同一内核，可以提高效率。 如何实现？把每个内核中的寄存器分成两组，让程序分别使用两组寄存器，从而使得内核数加倍，同时操作系统可以检测刀两倍的内核数，从而使得每个内核逻辑上分离。 此技术在大多数情况下都可以提高效率，但是其实本质上只有一个运算单元，故性能其实没有改变。 内核有什么用？ 是操作系统的最底层，驱动硬件，提高系统所需要的内核功能，包括防火墙、是否支持LVM等。 是什么？系统中的一个文件，包括驱动主机各个硬件的检查程序和驱动模块。 内核模块化？将一些不常见的类似于驱动程序的东西独立出内核，编译成模块。 进程pid：process id,进程id tid：线程id 程序被触发，执行者的权限和属性、程序的代码与所需数据会被加载到内存中，操作系统会给予这块内存一个PID，即进程是正在运行的一个程序。 12345678910111213141516#include &lt;unistd.h&gt;//获取进程pidpid_t getpid(void);//pthread_t 为 long unsigned int,lu.#include&lt;pthread.h&gt;//获取线程tidpthread_t pthread_self(void);int pthread_equal(pthread_t tid1,pthread_t tid2);int pthread_create(pthread_t *restrict tidp,const pthread_attr_t *restrict attr,void *(*start_vin)(void),void *restrict arg);//中止线程void pthread_exit(void *status);//等待某个线程退出int pthread_join(pthread_t tid,void **status);//gcc 编译 -pthread不可或缺gcc -pthread filename pthread_create用于创建一个线程，成功返回0，否则返回Exxx（为正数）。 pthread_t *tid：线程id的类型为thread_t，通常为无符号整型，当调用pthread_create成功时，通过*tid指针返回。 const pthread_attr_t *attr：指定创建线程的属性，如线程优先级、初始栈大小、是否为守护进程等。可以使用NULL来使用默认值，通常情况下我们都是使用默认值。 void *(*func) (void *)：函数指针func，指定当新的线程创建之后，将执行的函数。 void *arg：线程将执行的函数的参数。如果想传递多个参数，请将它们封装在一个结构体中。 pthread_join用于等待某个线程退出，成功返回0，否则返回Exxx（为正数）。 pthread_t tid：指定要等待的线程ID void ** status：如果不为NULL，那么线程的返回值存储在status指向的空间中（这就是为什么status是二级指针的原因！这种才参数也称为“值-结果”参数）。 pthread_self用于返回当前线程的ID。 pthread_detach用于是指定线程变为分离状态，就像进程脱离终端而变为后台进程类似。成功返回0，否则返回Exxx（为正数）。变为分离状态的线程，如果线程退出，它的所有资源将全部释放。而如果不是分离状态，线程必须保留它的线程ID，退出状态直到其它线程对它调用了pthread_join。 pthread_exit用于终止线程，可以指定返回值，以便其他线程通过pthread_join函数获取该线程的返回值。 void *status：指针线程终止的返回值。 进程与线程线程是比进程更小的单位，进程由多个线程组成。 进程有独立的地址空间，线程没有独立的地址空间。 尝试一个简单的多线程打印123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;//pthread开头的函数#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;//sleep()void* thread1(void *);void* thread2(void *);int main()&#123; printf(\"enter main\\n\"); pthread_t tid1,tid2; // 创建线程 pthread_create(&amp;tid1,NULL,thread1,NULL); pthread_create(&amp;tid2,NULL,thread2,NULL); sleep(1); printf(\"leave main\\n\"); exit(0); return 0;&#125;//线程1void* thread1(void *arg)&#123; printf(\"enter thread1\\n\"); printf(\"thread1 id is %lu\",pthread_self()); printf(\"leave thread1\\n\"); pthread_exit(0);&#125;//线程2void* thread2(void *arg)&#123; printf(\"enter thread2\\n\"); printf(\"thread2 id is %lu\",pthread_self()); printf(\"leave thread2\\n\"); pthread_exit(0);&#125; 运行截图如下： image-20200630214750801.png 双线程打印ABABABAB（使用互斥锁与条件变量）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#define COUNT 20int i=1;//互斥锁宏初始化pthread_mutex_t mutex=PTHREAD_MUTEX_INITIALIZER;//条件变量宏初始化pthread_cond_t even=PTHREAD_COND_INITIALIZER;pthread_cond_t uneven=PTHREAD_COND_INITIALIZER;//线程1函数定义void* thread1(void *arg)&#123; while(i&lt;=COUNT)&#123; pthread_mutex_lock(&amp;mutex);//上锁 if(i%2==1)&#123; printf(\"thread1:A\\n\"); i++; pthread_cond_signal(&amp;uneven);//发出信号 &#125; else&#123; pthread_cond_wait(&amp;even,&amp;mutex);//等待信号 &#125; pthread_mutex_unlock(&amp;mutex);//解锁 &#125;&#125;//除条件变量略有不同，其它类似void* thread2(void *arg)&#123; while(i&lt;=COUNT)&#123; pthread_mutex_lock(&amp;mutex); if(i%2==0)&#123; printf(\"thread2:B\\n\"); i++; pthread_cond_signal(&amp;even); &#125; else&#123; pthread_cond_wait(&amp;uneven,&amp;mutex); &#125; pthread_mutex_unlock(&amp;mutex); &#125;&#125;int main()&#123; pthread_t tid1,tid2; pthread_create(&amp;tid1,NULL,thread1,NULL); pthread_create(&amp;tid2,NULL,thread2,NULL); //等待进程退出 pthread_join(tid1,NULL); pthread_join(tid2,NULL); return 0;&#125; 运行截图如下： image-20200630214836749.png 内核的模块化设计用处？因为Linux内核庞大复杂，内核编译是很麻烦的事情，因此Linux使用模块化设计，将不常用的东西独立出内核，编译成模块。从而使得，在系统运行中，内核可以加载模块。最终提高了扩展性，功能的灵活性。 意思？模块化设计意思为内核中各个功能模块在代码上彼此独立的，没有变量、函数的相互调用。 插入模块创建内核线程，打印Hello，WorldhelloWorld.c 1234567891011121314151617#include &lt;linux/kernel.h&gt;#include &lt;linux/module.h&gt;//printk()#include &lt;linux/init.h&gt;//使用了linux/init.h中定义的宏init和exit//内核中打印函数为printk，static int __init init_my_module(void)&#123; printk(KERN_INFO \"Hello, World!\\n\"); return 0;&#125;static void __exit exit_my_module(void)&#123; printk(KERN_INFO \"Bye, World!\\n\");&#125;//内核加载时执行module_init(init_my_module);//内核卸载时执行module_exit(exit_my_module); Makefile文件 12345678#编译生成可加载模块，即将helloWorld.c编译成hello.koobj-m += helloWorld.oall:#-C 指定内核源码位置，/lib/modules/$(shell uname -r)/build#M= 指定需要编译的内核源文件地址 [target]:modules(可选) make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modulesclean: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean 12345$ lsmod #现实所有内核模块$ make $ sudo insmod helloWorld.ko#运行内核模块$ dmesg #查询/var/log/messages，查看打印的信息$ sudo rmmod helloWorld.ko#卸载模块 运行截图如下： image-20200630215108549.png 加分项互斥锁在变量修改时间多于一个存储器访问周期的情况下，存储器读写周期会交叉，出现变量不一致的情况。 为了解决线程同步的问题，所以线程需要使用锁，同一时间只允许一个线程访问变量。 1234567#include &lt;pthread.h&gt; //宏初始化（适用于静态分配的互斥量）static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;//操作先加锁int pthread_mutex_lock(pthread_mutex_t * mptr); //操作后解锁int pthread_mutex_unlock(pthread_mutex_t * mptr); 互斥锁可以让线程按照顺序执行，从而使得一次只执行一次代码。 死锁如果线程尝试对同一个互斥量加锁两次，本身就会进入死锁状态。 若两个分别占有一个互斥量的线程，试图锁住对方的互斥量是，就会进入死锁状态。 线程同步互斥锁总是与条件变量一起使用。 1234567#include &lt;pthread.h&gt;//宏初始化static pthread_cond_t cond = PTHREAD_COND_INITIALIZER; //等待唤醒int pthread_cond_wait(pthread_cond_t *cptr, pthread_mutex_t *mptr); //通知int pthread_cond_signal(pthread_cond_t *cptr); 标准IO与重定向符号的使用标准输入、标准输出、标准错误分别为stdin,stdout,stderr。在默认情况下，标准输出和标准输入都是终端。stdin的文件描述符为0，stdout的文件描述符为1，stderrr的文件描述符为2。 12345678910111213141516#将stdout重定向到file,若追加在file后，运算符为 &gt;&gt;command &gt; file#将stderr重定向到file,2为文件描述符。command 2 &gt; file#将stdin重定向到filecommand &lt; file#例 输出hello, Linux!的可执行文件.\\hello &gt; hello.txtcat hello.txt#输出hello, Linux!#例 比较大小输出最大值的可执行文件 input.txt: 3 5.\\fmax &lt; input.txt#输出5 第四关：BOSS基础篇信号是一种软中断，信号体制是进程间通信的一种方式，采用异步通信机制。原理是上，一个进程收到信号类似于处理器收到中断请求，故它是在软件层次上对中断机制的一种模拟。 信号在signal.h头文件中被定义，通过kill -l可以查看编号和信号名的映射关系。对于信号，通常有三种处理方式：忽略；默认动作；捕捉信号。 SIG_IGN,SIG_分别表示忽略某一信号；按默认动作处理。 一般信号触发可分为几类：在终端通过组合按键触发，然后发送给前台，如Ctrl+C发送SIGINT信号；硬件异常产生信号，通知内核然后发送给进程信号；通过软件层面，如kill(),raise()等函数，或检测到某种软件条件发生产生信号。 signal()函数用于对进程中某个特定信号（signum）注册一个对应的处理函数。 12typedef void(*sighandle_t)(int); //sighandle_t被定义为指向void()(int)函数类型的指针sighandle_t signal(int signum,sighandler_t handler); kill(),raise()前者用来给指定进程发送信号，后者用来给当前进程发送信号 123int kill(pid_t pid,int signo);int raise(int signo)；//kill(getpid(),signo) equals raise(signo) pause()用来挂起进程，直到信号触发。针对不同的处理行为，表现不同，pause返回不同。若终止进程，则没有返回；若忽略，进程保持挂起状态，没有返回；若有信号处理函数，则调用该函数，返回-1。 加分项中断和异常中断被定义为一种事件，该事件改变处理器执行的指令顺序。中断通常分为同步中断（异常）和异步中断（中断）。同步中断是由CPU产生的，只有在一条指令中止执行后CPU才会产生中断。异步中断是由其它硬件设备依照CPU时钟信号随机产生的。 在嵌入式中，中断很重要，在几乎所有芯片中都有中断功能。每个外接设备申请一个唯一的中断号，让外设发生中断时，向CPU报告自己的中断号，CPU知道是哪个设备发生中断，然后执行相对应的操作。 如何处理？发生中断后，CPU暂停执行当前的程序，处理中断，因为中断执行后要恢复之前的额代码，故进入中断后CPU还要保护源程序断点信息，然后从中断控制器中取出中断向量，转到相应的处理程序，对中断进行处理，中断处理完成后返回，继续执行当前的程序。 好处？提高CPU的利用率，使CPU及时处理各种软硬件故障。若没有中断，CPU需要对设备进行循环的访问，才能得到设备的状态。中断则使得硬件如要与CPU联系，便向CPU发出中断请求信号，从而使得CPU停止当前程序的执行，处理硬件发出的请求。 中断向量是中断服务程序的入口地址，即指向中断服务程序的指针。系统维护一份中断向量表，中断向量是其中的元素。当异常产生时，硬件产生一个中断标记，CPU根据中断标记获得相应的中断向量号，在由CPU根据中断向量表的地址和中断向量号去查找中断向量表获得相应中断号的中断程序地址，进一步执行对应的中断处理程序。 RTC中断程序rtc_alarm.c 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;stdio.h&gt;#include &lt;linux/rtc.h&gt;#include &lt;sys/ioctl.h&gt;//ioctl()#include &lt;sys/time.h&gt;//struct rtc_time#include &lt;sys/types.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;//perror()#include &lt;stdlib.h&gt;//exit()int main(void)&#123; int i, fd, retval, irqcount = 0; unsigned long tmp, data; errno = 0; struct rtc_time rtc_tm; //打开rtc fd = open(\"/dev/rtc\", O_RDONLY); if(fd==-1)&#123; perror(\"/dev/rtc\"); exit(errno); &#125; //读取RTC retval = ioctl(fd, RTC_RD_TIME, &amp;rtc_tm); if(retval==-1)&#123; perror(\"ioctl\"); exit(errno); &#125; //打印当前时间 fprintf(stderr,\"Current RTC data/time is %d-%d-%d,%02d:%02d:%02d.\\n\", rtc_tm.tm_mday, rtc_tm.tm_mon + 1, rtc_tm.tm_year + 1900,rtc_tm.tm_hour, rtc_tm.tm_min, rtc_tm.tm_sec); //设置10min alarm rtc_tm.tm_min += 10; if(rtc_tm.tm_sec&gt;=60)&#123; rtc_tm.tm_sec %= 60; rtc_tm.tm_min++; &#125; if(rtc_tm.tm_min&gt;=60)&#123; rtc_tm.tm_min %= 60; rtc_tm.tm_hour++; &#125; if(rtc_tm.tm_hour==24)&#123; rtc_tm.tm_hour = 0; &#125; //设置 alarm retval = ioctl(fd, RTC_ALM_SET, &amp;rtc_tm); if(retval==-1)&#123; perror(\"ioctl\"); exit(errno); &#125; fprintf(stderr,\"Alarm time now set to %02d:%02d:%02d.\\n\",rtc_tm.tm_hour, rtc_tm.tm_min, rtc_tm.tm_sec); //启用 alarm retval = ioctl(fd, RTC_AIE_ON, 0); if(retval==-1)&#123; perror(\"iotle\"); exit(errno); &#125; //调用read()，因rtc不能被两个线程调用，故阻塞直到alarm，从而实现闹钟功能。 retval = read(fd, &amp;data, sizeof(unsigned long)); if(retval==-1)&#123; perror(\"read\"); exit(errno); &#125; irqcount++; fprintf(stderr, \"okay.Alarm rang.\\n\");&#125; 运行截图如下：（因10min的alarm太久了，故将rtc_tm.tm_min += 10;改为rtc_tm.tm_min += 1;，设置1min的alarm） image-20200630220826329.png","tags":[{"name":"Linux","slug":"Linux","permalink":"ronpay.xyz/tags/Linux/"}]},{"title":"Git 笔记","date":"2020-07-01T14:31:36.000Z","path":"2020/07/01/Git-笔记/","text":"Git笔记基本操作git init12345678#该命令执行完后会在当前目录生成一个 .git 目录。git init#初始化后，会在 newrepo 目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。git init newrepo#如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：$ git add *.c$ git add README$ git commit -m '初始化项目版本' git clone12345678#克隆仓库的命令格式为：git clone &lt;repo&gt;#如果我们需要克隆到指定的目录，可以使用以下命令格式：git clone &lt;repo&gt; &lt;directory&gt;#比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令：$ git clone git://github.com/schacon/grit.git#如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：$ git clone git://github.com/schacon/grit.git mygrit","tags":[{"name":"Git","slug":"Git","permalink":"ronpay.xyz/tags/Git/"}]},{"title":"Github+Hexo 博客搭建","date":"2020-07-01T14:28:50.000Z","path":"2020/07/01/Github-Hexo-博客搭建/","text":"Github+Hexo 博客搭建必要组件安装Node.js，添加国内源npm config set registry https://registry.npm.taobao.org 安装Git，并加入命令提示符 Github操作新建repo，名为：”name.github.io”，并初始化README 安装Hexo右键 Git Bash Here，打开git控制台窗口 123456789101112#安装Hexonpm i hexo-cli -g#初始化文件夹hexo init#安装必要组件npm install#生成静态网页hexo g#打开本地服务器，在localhost:4000/中预览hexo s#关闭本地服务器ctrl+c 连接Github与本地12345678910#在git控制台窗口git config --global user.name \"yourname\"git config --global user.email \"youremail\"#生成密匙SSH keyssh-keygen -t rsa -C \"youremail\"#输入cat ~/.ssh/id_rsa.pub#将输出的文件保存在下方的SSH中#输入ssh -T git@github.com 打开github，在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便。 打开博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。 修改最后一行的配置： 1234deploy: type: git repository: https://github.com/yourname/yourname.github.io branch: master 写文章12345678910#安装拓展npm i hexo-deployer-git#新建一篇文章hexo new post \"article title\"#生成静态网页hexo g#本地浏览hexo s#上传到githubhexo d","tags":[{"name":"Hexo","slug":"Hexo","permalink":"ronpay.xyz/tags/Hexo/"}]}]