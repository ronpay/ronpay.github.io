[{"title":"2020嵌入式工作室招新Linux方向招新题","date":"2020-07-01T14:32:54.000Z","path":"2020/07/01/Linux Learning/","text":"第一关：初识Linux基础篇Linux是一种自由和开放源码的类UNIX操作系统。 Linux的优势在于开源，系统的源码是共享的，方便我们自行修改Linux系统，增加或修改所需要的功能，从而得到定制化的系统。服务器端的系统也常常是Linux，使用Linux作为环境，便于软件的调试。Linux 的强大的定制功能和低廉的成本，使得它在嵌入式系统得到广泛的运用。 因选修课使用过Ubuntu 16.04TLS，因此选择了VMware Workstation 安装 Ubuntu 20.04TLS。选择新版本的原因在于新的Linux版本会采用新的Linux内核。 首先在软件与更新中，更换软件源，提高下载速度。 安装chrome,vscode,typora,安装的方式看官网的步骤便可。 1234#install chromewget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.debsudo apt install ./google-chrome-stable_current_amd64.debcat /etc/apt/sources.list.d/google-chrome.list 设置网络代理 在主机的代理软件（Clash for Windows）上勾选允许LAN连接，然后在Ubuntu的网络代理中，设置手动，对所有的项，将地址设置为主机IP，端口设置为代理软件的端口，从而实现科学上网。 美化安装必要的程序 123sudo apt updatesudo apt install gnome-tweakssudo apt install chrome-gnome-shell 安装gnome的chrome扩展，启用User Theme。 然后更换主题、图标、鼠标，这些东西我全都选了Mac OS的主题，顺便换了壁纸。 在gnome主题网站，下载MccainMojave-circle图标、MoMojave主题、McMojave cursors，分别解压缩复制到./~/.themes 和 ./~/.icons目录，在优化中，启用相应主题、图标和鼠标。 在gnome网站上，下载Dash to dock美化dock栏。 效果如下： image-20200630213057555.png 加分项使用了Github+Hexo博客的搭建方式，使用了Hexo的Next主题。 第二关：知识积累Linux 常用命令 cd命令 123回到上一次目录 cd -回到要目录 cd &#x2F;回到home目录 cd ~ mkdir命令 ls命令 12#所有文件 ls -a mv命令 12重命名 mv src dest移动 mv filename pathname(.&#x2F;表示当前位置，) rm命令 12删除文件 rm filename删除文件夹 rm -rf filename tar命令 1解压 tar -zxvf filename.tar.bz2 vim命令 1进入&#x2F;创造文件 vim filename make命令（编译） chmod命令（更改访问权限） Ctrl+C ，在后面讲述到，其实是通过终端向程序发出SIGINT信号，终止当前的进程。 ln命令（功能是为某一个文件在另外一个位置建立一个同步的链接） 1ln [参数][源文件或目录][目标文件或目录] Ubuntu常用命令12345678#安装软件 sudo apt-get install package#更新源 sudo apt-get update#更新已安装的包 sudo apt-get upgrade#安装deb包的方式sudo dpkg -i [deb包] GCC 安装及 编译C语言安装一般GCC的方法12345678#输入下面的命令，安装想要的 GCC 和 G++ ：sudo apt install gcc-8 g++-8 gcc-9 g++-9 gcc-10 g++-10#下面的命令配置每一个版本，并且设置了优先级。默认的版本是拥有最高优先级的那个，在我们的场景中是gcc-10。sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-10 100 --slave /usr/bin/g++ g++ /usr/bin/g++-10 --slave /usr/bin/gcov gcov /usr/bin/gcov-10sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 90 --slave /usr/bin/g++ g++ /usr/bin/g++-9 --slave /usr/bin/gcov gcov /usr/bin/gcov-9sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-8 80 --slave /usr/bin/g++ g++ /usr/bin/g++-8 --slave /usr/bin/gcov gcov /usr/bin/gcov-8#以后，如果你想修改默认的版本，使用update-alternatives命令：sudo update-alternatives --config gcc 编译C语言1234567#编译C语言#命名为helloworldgcc -o helloworld helloworld.c #执行./helloworld#自动生成hello.o，但不会生成二进制执行文件，等待后续链接。gcc -c hello.c 安装特定版本的GCC的方法（编译）（去Google上搜相应的方法，十分麻烦都要分别安装依赖项。最后找了一个英文网页，没几行命令，然后再等待几十分钟的编译就行了。） 123456789101112131415#下载GCC源码wget https://ftpmirror.gnu.org/gcc/gcc-10.1.0/gcc-10.1.0.tar.xz#解压tar -zxvf gcc-10.1.0.tar.xz#下载依赖项cd gcc-10.1.0contrib/download_prerequisites#建立编译输出目录mkdir gcc-build#进入输出目录，执行命令，生成makefile文件../gcc-10.1.0/configure -v --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu --prefix=/usr/local/gcc-10.1.0 --enable-checking=release --enable-languages=c,c++,fortran --disable-multilib --program-suffix=-10.1#编译make -j 4#安装sudo make install-strip GCC-10.1编译安装效果，如下：（弄了好久也不知道怎么把它当作默认的gcc，估计安装路径有点问题） image-20200630213259310.png vimsudo apt-get install vim安装vim. vi/vim的使用刚启动vi/vim时，进入命令模式，输入i，切换输入模式， 输入模式常见命令 Esc进入命令模式 底线命令模式常见命令 q 退出程序 q!强制退出不保存 w 保存文件 wq 保存文件并退出程序 按ESC键退出底线命令模式 一般命令模式常见命令： i,o,a切换到输入模式，以输入字符。 x 向后删除一个字符(del),X 为向前删除一个字符（backspace) dd 删除整行的字符。 :,/,?切换到底线命令模式，以在最底一行输入命令。 gg 移动到第一行 dG删除光标所在处到最后一行所有数据 (n)yy复制光标那一行(光标往下n行) u回复前一个操作 ctrl+r重做上一个操作 /word向下寻找word ?word向上寻找word :sp filename 若打开同一个文件则无需filename。用ctrl+w+上 向上翻，用ctrl+w+下 向下翻 Ctrl x + ctrl n关键词补全 vim缓存与恢复打开不正常结束的vim时会出现缓存警告，可输入o,e,r,d,q,a分别表示只读open，编辑edit，加载缓存recover，删除缓存delete，停止quit，同停止abort。 vim 美化与插件 下载 molokai 主题 将 colors/molokai.vim 拷贝到 ~/.vim/colors/ 新建~/.vimrc文件，在 ~/.vimrc 中添加：colorscheme molokai （vim得安装很多插件才能有VSCode的intellisense、代码补全、自动格式化的功能，还不太习惯，不想折腾了，后面就用VSCode写了） vim-plug vim插件管理器，用于安装、管理插件。 The NERDTree 文件目录可视化的插件，使用vim-plug插件管理器安装，安装方法见vim-plug的GitHub页码。使用方式：在vim命令行形式，输入NERDTree。 安装教程在如上的Github页面都很详细，就不赘述了。 vim编写Hello.c和BST.c image-20200627122923712.png image-20200628113025534.png image-20200628114709524.png image-20200628114742290.png 第三关：进阶篇基础篇CPUCPU是一个具有特殊功能的芯片，里面含有指令集。内分为两个主要的单元，分别为算术逻辑单元，控制单元。CPU内部含有一些微指令，而指令集的设计分成两种设计理念，分别为两种CPU架构：精简指令集，复杂指令集。我们常用的Intel、AMD所用的便是复杂指令集，基于X86架构。 CPU频率：每秒钟可以进行的工作次数。（因为指令集、架构、二级缓存及其运算机制的不同、每一此频率可以运行的指令数不同，故不能单纯使用CPU频率来比较CPU性能。 现在CPU已经没有北桥，其中的内存控制器已经被整合到CPU内部了，使得CPU可以直接与内存、显卡进行通信，提高了效率 64位、32位的说法来自CPU每次能够处理的数据量，即字长。 超线程技术为何会有这种技术？因CPU命令执行周期太短，CPU内核长时间处于空置状态，同时系统是多任务系统，因此让多个任务使用同一内核，可以提高效率。 如何实现？把每个内核中的寄存器分成两组，让程序分别使用两组寄存器，从而使得内核数加倍，同时操作系统可以检测刀两倍的内核数，从而使得每个内核逻辑上分离。 此技术在大多数情况下都可以提高效率，但是其实本质上只有一个运算单元，故性能其实没有改变。 内核有什么用？ 是操作系统的最底层，驱动硬件，提高系统所需要的内核功能，包括防火墙、是否支持LVM等。 是什么？系统中的一个文件，包括驱动主机各个硬件的检查程序和驱动模块。 内核模块化？将一些不常见的类似于驱动程序的东西独立出内核，编译成模块。 进程pid：process id,进程id tid：线程id 程序被触发，执行者的权限和属性、程序的代码与所需数据会被加载到内存中，操作系统会给予这块内存一个PID，即进程是正在运行的一个程序。 12345678910111213141516#include &lt;unistd.h&gt;//获取进程pidpid_t getpid(void);//pthread_t 为 long unsigned int,lu.#include&lt;pthread.h&gt;//获取线程tidpthread_t pthread_self(void);int pthread_equal(pthread_t tid1,pthread_t tid2);int pthread_create(pthread_t *restrict tidp,const pthread_attr_t *restrict attr,void *(*start_vin)(void),void *restrict arg);//中止线程void pthread_exit(void *status);//等待某个线程退出int pthread_join(pthread_t tid,void **status);//gcc 编译 -pthread不可或缺gcc -pthread filename pthread_create用于创建一个线程，成功返回0，否则返回Exxx（为正数）。 pthread_t *tid：线程id的类型为thread_t，通常为无符号整型，当调用pthread_create成功时，通过*tid指针返回。 const pthread_attr_t *attr：指定创建线程的属性，如线程优先级、初始栈大小、是否为守护进程等。可以使用NULL来使用默认值，通常情况下我们都是使用默认值。 void *(*func) (void *)：函数指针func，指定当新的线程创建之后，将执行的函数。 void *arg：线程将执行的函数的参数。如果想传递多个参数，请将它们封装在一个结构体中。 pthread_join用于等待某个线程退出，成功返回0，否则返回Exxx（为正数）。 pthread_t tid：指定要等待的线程ID void ** status：如果不为NULL，那么线程的返回值存储在status指向的空间中（这就是为什么status是二级指针的原因！这种才参数也称为“值-结果”参数）。 pthread_self用于返回当前线程的ID。 pthread_detach用于是指定线程变为分离状态，就像进程脱离终端而变为后台进程类似。成功返回0，否则返回Exxx（为正数）。变为分离状态的线程，如果线程退出，它的所有资源将全部释放。而如果不是分离状态，线程必须保留它的线程ID，退出状态直到其它线程对它调用了pthread_join。 pthread_exit用于终止线程，可以指定返回值，以便其他线程通过pthread_join函数获取该线程的返回值。 void *status：指针线程终止的返回值。 进程与线程线程是比进程更小的单位，进程由多个线程组成。 进程有独立的地址空间，线程没有独立的地址空间。 尝试一个简单的多线程打印123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;//pthread开头的函数#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;//sleep()void* thread1(void *);void* thread2(void *);int main()&#123; printf(\"enter main\\n\"); pthread_t tid1,tid2; // 创建线程 pthread_create(&amp;tid1,NULL,thread1,NULL); pthread_create(&amp;tid2,NULL,thread2,NULL); sleep(1); printf(\"leave main\\n\"); exit(0); return 0;&#125;//线程1void* thread1(void *arg)&#123; printf(\"enter thread1\\n\"); printf(\"thread1 id is %lu\",pthread_self()); printf(\"leave thread1\\n\"); pthread_exit(0);&#125;//线程2void* thread2(void *arg)&#123; printf(\"enter thread2\\n\"); printf(\"thread2 id is %lu\",pthread_self()); printf(\"leave thread2\\n\"); pthread_exit(0);&#125; 运行截图如下： image-20200630214750801.png 双线程打印ABABABAB（使用互斥锁与条件变量）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#define COUNT 20int i=1;//互斥锁宏初始化pthread_mutex_t mutex=PTHREAD_MUTEX_INITIALIZER;//条件变量宏初始化pthread_cond_t even=PTHREAD_COND_INITIALIZER;pthread_cond_t uneven=PTHREAD_COND_INITIALIZER;//线程1函数定义void* thread1(void *arg)&#123; while(i&lt;=COUNT)&#123; pthread_mutex_lock(&amp;mutex);//上锁 if(i%2==1)&#123; printf(\"thread1:A\\n\"); i++; pthread_cond_signal(&amp;uneven);//发出信号 &#125; else&#123; pthread_cond_wait(&amp;even,&amp;mutex);//等待信号 &#125; pthread_mutex_unlock(&amp;mutex);//解锁 &#125;&#125;//除条件变量略有不同，其它类似void* thread2(void *arg)&#123; while(i&lt;=COUNT)&#123; pthread_mutex_lock(&amp;mutex); if(i%2==0)&#123; printf(\"thread2:B\\n\"); i++; pthread_cond_signal(&amp;even); &#125; else&#123; pthread_cond_wait(&amp;uneven,&amp;mutex); &#125; pthread_mutex_unlock(&amp;mutex); &#125;&#125;int main()&#123; pthread_t tid1,tid2; pthread_create(&amp;tid1,NULL,thread1,NULL); pthread_create(&amp;tid2,NULL,thread2,NULL); //等待进程退出 pthread_join(tid1,NULL); pthread_join(tid2,NULL); return 0;&#125; 运行截图如下： image-20200630214836749.png 内核的模块化设计用处？因为Linux内核庞大复杂，内核编译是很麻烦的事情，因此Linux使用模块化设计，将不常用的东西独立出内核，编译成模块。从而使得，在系统运行中，内核可以加载模块。最终提高了扩展性，功能的灵活性。 意思？模块化设计意思为内核中各个功能模块在代码上彼此独立的，没有变量、函数的相互调用。 插入模块创建内核线程，打印Hello，WorldhelloWorld.c 1234567891011121314151617#include &lt;linux/kernel.h&gt;#include &lt;linux/module.h&gt;//printk()#include &lt;linux/init.h&gt;//使用了linux/init.h中定义的宏init和exit//内核中打印函数为printk，static int __init init_my_module(void)&#123; printk(KERN_INFO \"Hello, World!\\n\"); return 0;&#125;static void __exit exit_my_module(void)&#123; printk(KERN_INFO \"Bye, World!\\n\");&#125;//内核加载时执行module_init(init_my_module);//内核卸载时执行module_exit(exit_my_module); Makefile文件 12345678#编译生成可加载模块，即将helloWorld.c编译成hello.koobj-m += helloWorld.oall:#-C 指定内核源码位置，/lib/modules/$(shell uname -r)/build#M= 指定需要编译的内核源文件地址 [target]:modules(可选) make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modulesclean: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean 12345$ lsmod #现实所有内核模块$ make $ sudo insmod helloWorld.ko#运行内核模块$ dmesg #查询/var/log/messages，查看打印的信息$ sudo rmmod helloWorld.ko#卸载模块 运行截图如下： image-20200630215108549.png 加分项互斥锁在变量修改时间多于一个存储器访问周期的情况下，存储器读写周期会交叉，出现变量不一致的情况。 为了解决线程同步的问题，所以线程需要使用锁，同一时间只允许一个线程访问变量。 1234567#include &lt;pthread.h&gt; //宏初始化（适用于静态分配的互斥量）static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;//操作先加锁int pthread_mutex_lock(pthread_mutex_t * mptr); //操作后解锁int pthread_mutex_unlock(pthread_mutex_t * mptr); 互斥锁可以让线程按照顺序执行，从而使得一次只执行一次代码。 死锁如果线程尝试对同一个互斥量加锁两次，本身就会进入死锁状态。 若两个分别占有一个互斥量的线程，试图锁住对方的互斥量是，就会进入死锁状态。 线程同步互斥锁总是与条件变量一起使用。 1234567#include &lt;pthread.h&gt;//宏初始化static pthread_cond_t cond = PTHREAD_COND_INITIALIZER; //等待唤醒int pthread_cond_wait(pthread_cond_t *cptr, pthread_mutex_t *mptr); //通知int pthread_cond_signal(pthread_cond_t *cptr); 标准IO与重定向符号的使用标准输入、标准输出、标准错误分别为stdin,stdout,stderr。在默认情况下，标准输出和标准输入都是终端。stdin的文件描述符为0，stdout的文件描述符为1，stderrr的文件描述符为2。 12345678910111213141516#将stdout重定向到file,若追加在file后，运算符为 &gt;&gt;command &gt; file#将stderr重定向到file,2为文件描述符。command 2 &gt; file#将stdin重定向到filecommand &lt; file#例 输出hello, Linux!的可执行文件.\\hello &gt; hello.txtcat hello.txt#输出hello, Linux!#例 比较大小输出最大值的可执行文件 input.txt: 3 5.\\fmax &lt; input.txt#输出5 第四关基础篇信号是一种软中断，信号体制是进程间通信的一种方式，采用异步通信机制。原理是上，一个进程收到信号类似于处理器收到中断请求，故它是在软件层次上对中断机制的一种模拟。 信号在signal.h头文件中被定义，通过kill -l可以查看编号和信号名的映射关系。对于信号，通常有三种处理方式：忽略；默认动作；捕捉信号。 SIG_IGN,SIG_分别表示忽略某一信号；按默认动作处理。 一般信号触发可分为几类：在终端通过组合按键触发，然后发送给前台，如Ctrl+C发送SIGINT信号；硬件异常产生信号，通知内核然后发送给进程信号；通过软件层面，如kill(),raise()等函数，或检测到某种软件条件发生产生信号。 signal()函数用于对进程中某个特定信号（signum）注册一个对应的处理函数。 12typedef void(*sighandle_t)(int); //sighandle_t被定义为指向void()(int)函数类型的指针sighandle_t signal(int signum,sighandler_t handler); kill(),raise()前者用来给指定进程发送信号，后者用来给当前进程发送信号 123int kill(pid_t pid,int signo);int raise(int signo)；//kill(getpid(),signo) equals raise(signo) pause()用来挂起进程，直到信号触发。针对不同的处理行为，表现不同，pause返回不同。若终止进程，则没有返回；若忽略，进程保持挂起状态，没有返回；若有信号处理函数，则调用该函数，返回-1。 加分项中断和异常中断被定义为一种事件，该事件改变处理器执行的指令顺序。中断通常分为同步中断（异常）和异步中断（中断）。同步中断是由CPU产生的，只有在一条指令中止执行后CPU才会产生中断。异步中断是由其它硬件设备依照CPU时钟信号随机产生的。 在嵌入式中，中断很重要，在几乎所有芯片中都有中断功能。每个外接设备申请一个唯一的中断号，让外设发生中断时，向CPU报告自己的中断号，CPU知道是哪个设备发生中断，然后执行相对应的操作。 如何处理？发生中断后，CPU暂停执行当前的程序，处理中断，因为中断执行后要恢复之前的额代码，故进入中断后CPU还要保护源程序断点信息，然后从中断控制器中取出中断向量，转到相应的处理程序，对中断进行处理，中断处理完成后返回，继续执行当前的程序。 好处？提高CPU的利用率，使CPU及时处理各种软硬件故障。若没有中断，CPU需要对设备进行循环的访问，才能得到设备的状态。中断则使得硬件如要与CPU联系，便向CPU发出中断请求信号，从而使得CPU停止当前程序的执行，处理硬件发出的请求。 中断向量是中断服务程序的入口地址，即指向中断服务程序的指针。系统维护一份中断向量表，中断向量是其中的元素。当异常产生时，硬件产生一个中断标记，CPU根据中断标记获得相应的中断向量号，在由CPU根据中断向量表的地址和中断向量号去查找中断向量表获得相应中断号的中断程序地址，进一步执行对应的中断处理程序。 RTC中断程序rtc_alarm.c 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;stdio.h&gt;#include &lt;linux/rtc.h&gt;#include &lt;sys/ioctl.h&gt;//ioctl()#include &lt;sys/time.h&gt;//struct rtc_time#include &lt;sys/types.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;//perror()#include &lt;stdlib.h&gt;//exit()int main(void)&#123; int i, fd, retval, irqcount = 0; unsigned long tmp, data; errno = 0; struct rtc_time rtc_tm; //打开rtc fd = open(\"/dev/rtc\", O_RDONLY); if(fd==-1)&#123; perror(\"/dev/rtc\"); exit(errno); &#125; //读取RTC retval = ioctl(fd, RTC_RD_TIME, &amp;rtc_tm); if(retval==-1)&#123; perror(\"ioctl\"); exit(errno); &#125; //打印当前时间 fprintf(stderr,\"Current RTC data/time is %d-%d-%d,%02d:%02d:%02d.\\n\", rtc_tm.tm_mday, rtc_tm.tm_mon + 1, rtc_tm.tm_year + 1900,rtc_tm.tm_hour, rtc_tm.tm_min, rtc_tm.tm_sec); //设置10min alarm rtc_tm.tm_min += 10; if(rtc_tm.tm_sec&gt;=60)&#123; rtc_tm.tm_sec %= 60; rtc_tm.tm_min++; &#125; if(rtc_tm.tm_min&gt;=60)&#123; rtc_tm.tm_min %= 60; rtc_tm.tm_hour++; &#125; if(rtc_tm.tm_hour==24)&#123; rtc_tm.tm_hour = 0; &#125; //设置 alarm retval = ioctl(fd, RTC_ALM_SET, &amp;rtc_tm); if(retval==-1)&#123; perror(\"ioctl\"); exit(errno); &#125; fprintf(stderr,\"Alarm time now set to %02d:%02d:%02d.\\n\",rtc_tm.tm_hour, rtc_tm.tm_min, rtc_tm.tm_sec); //启用 alarm retval = ioctl(fd, RTC_AIE_ON, 0); if(retval==-1)&#123; perror(\"iotle\"); exit(errno); &#125; //调用read()，因rtc不能被两个线程调用，故阻塞直到alarm，从而实现闹钟功能。 retval = read(fd, &amp;data, sizeof(unsigned long)); if(retval==-1)&#123; perror(\"read\"); exit(errno); &#125; irqcount++; fprintf(stderr, \"okay.Alarm rang.\\n\");&#125; 运行截图如下：（因10min的alarm太久了，故将rtc_tm.tm_min += 10;改为rtc_tm.tm_min += 1;，设置1min的alarm） image-20200630220826329.png","tags":[{"name":"Linux","slug":"Linux","permalink":"ronpay.xyz/tags/Linux/"}]},{"title":"Git 笔记","date":"2020-07-01T14:31:36.000Z","path":"2020/07/01/Git-笔记/","text":"Git笔记基本操作git init12345678#该命令执行完后会在当前目录生成一个 .git 目录。git init#初始化后，会在 newrepo 目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。git init newrepo#如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：$ git add *.c$ git add README$ git commit -m '初始化项目版本' git clone12345678#克隆仓库的命令格式为：git clone &lt;repo&gt;#如果我们需要克隆到指定的目录，可以使用以下命令格式：git clone &lt;repo&gt; &lt;directory&gt;#比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令：$ git clone git://github.com/schacon/grit.git#如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：$ git clone git://github.com/schacon/grit.git mygrit","tags":[{"name":"Git","slug":"Git","permalink":"ronpay.xyz/tags/Git/"}]},{"title":"Github+Hexo 博客搭建","date":"2020-07-01T14:28:50.000Z","path":"2020/07/01/Github-Hexo-博客搭建/","text":"Github+Hexo 博客搭建必要组件安装Node.js，添加国内源npm config set registry https://registry.npm.taobao.org 安装Git，并加入命令提示符 Github操作新建repo，名为：”name.github.io”，并初始化README 安装Hexo右键 Git Bash Here，打开git控制台窗口 123456789101112#安装Hexonpm i hexo-cli -g#初始化文件夹hexo init#安装必要组件npm install#生成静态网页hexo g#打开本地服务器，在localhost:4000/中预览hexo s#关闭本地服务器ctrl+c 连接Github与本地12345678910#在git控制台窗口git config --global user.name \"yourname\"git config --global user.email \"youremail\"#生成密匙SSH keyssh-keygen -t rsa -C \"youremail\"#输入cat ~/.ssh/id_rsa.pub#将输出的文件保存在下方的SSH中#输入ssh -T git@github.com 打开github，在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便。 打开博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。 修改最后一行的配置： 1234deploy: type: git repository: https://github.com/yourname/yourname.github.io branch: master 写文章12345678910#安装拓展npm i hexo-deployer-git#新建一篇文章hexo new post \"article title\"#生成静态网页hexo g#本地浏览hexo s#上传到githubhexo d","tags":[{"name":"Hexo","slug":"Hexo","permalink":"ronpay.xyz/tags/Hexo/"}]}]