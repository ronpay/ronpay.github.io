<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ronpay&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/21c9991fac13636f56078f411ee9fd11</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="ronpay.xyz/"/>
  <updated>2020-08-07T01:47:57.774Z</updated>
  <id>ronpay.xyz/</id>
  
  <author>
    <name>Ronpay</name>
    <email>365296@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>大学物理笔记</title>
    <link href="ronpay.xyz/2020/08/03/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86%E7%AC%94%E8%AE%B0/"/>
    <id>ronpay.xyz/2020/08/03/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86%E7%AC%94%E8%AE%B0/</id>
    <published>2020-08-03T00:45:58.000Z</published>
    <updated>2020-08-07T01:47:57.774Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力学"><a href="#力学" class="headerlink" title="力学"></a>力学</h2><h3 id="刚体力学"><a href="#刚体力学" class="headerlink" title="刚体力学"></a>刚体力学</h3><h4 id="力矩的瞬时效应——刚体转动定理"><a href="#力矩的瞬时效应——刚体转动定理" class="headerlink" title="力矩的瞬时效应——刚体转动定理"></a>力矩的瞬时效应——刚体转动定理</h4><p>转动惯量<br>$$<br>I=\int_V{r^2dm}=r^2m<br>$$</p><p>力矩<br>$$<br>\vec{M}=\vec{r}\times\vec{F}=I\vec{\beta}<br>$$<br>其中，$\beta$是角加速。</p><p>平行轴定理：<br>$$<br>I=I_c+ml^2<br>$$<br>其中，$I_c$是转轴过质心的转动惯量。$l$是与过质心转轴相距为$l$且与之平行的另一转轴。 </p><p>垂直轴定理：<br>$$<br>I=I_x+I_y<br>$$<br>即一个平面薄板刚体对垂直于平面的任一转轴的转动惯量，等于刚体对在平面内并与该垂直轴相交的任二正交轴转动惯量之和。 </p><h4 id="力矩的时间累积效应——角动量定理"><a href="#力矩的时间累积效应——角动量定理" class="headerlink" title="力矩的时间累积效应——角动量定理"></a>力矩的时间累积效应——角动量定理</h4><p>冲量矩:<br>$$<br>J=\int{Mdt}<br>$$<br>角动量：<br>$$<br>L=I\omega=mr\times{v}<br>$$<br>角动量守恒：当外力冲量矩的矢量和为零时，刚体的角动量保持不变，即<br>$$<br>I_2\omega_2=I_1\omega_1<br>$$</p><p>摩擦力矩的角动量不一定守恒。</p><p>在有心力作用下，角动量守恒。</p><p>所有有心力都是保守力，机械能守恒。</p><h4 id="力矩的空间累积效应——刚体的机械能守恒定律"><a href="#力矩的空间累积效应——刚体的机械能守恒定律" class="headerlink" title="力矩的空间累积效应——刚体的机械能守恒定律"></a>力矩的空间累积效应——刚体的机械能守恒定律</h4><p>力矩的功：$A=\int{Md\theta}$</p><p>动能：$E_k=\frac{1}{2}I\omega^2$</p><h3 id="振动力学"><a href="#振动力学" class="headerlink" title="振动力学"></a>振动力学</h3><p>振动方程$y(t)=Acos(\omega t-\phi)$</p><p>波动方程$\phi(x,t)=Acos[\omega(t-\dfrac{x}{v})+\varphi]=Acos(\omega t-\dfrac{\omega }{v}x+\varphi)=Acos(\omega t-kx+\phi)$</p><p>其中$k=\dfrac{\omega}{v}=\dfrac{2\pi}{\lambda}$</p><h2 id="电磁学"><a href="#电磁学" class="headerlink" title="电磁学"></a>电磁学</h2><h3 id="符号详解"><a href="#符号详解" class="headerlink" title="符号详解"></a>符号详解</h3><p>电流密度矢量：$j=\dfrac{I}{S}$</p><p>电位移矢量：$D=\varepsilon E$</p><h3 id="静电场"><a href="#静电场" class="headerlink" title="静电场"></a>静电场</h3><p>$k=\dfrac{1}{4\pi\varepsilon_0}$</p><p>$e=1.602\times10^{-19}C$</p><p>$\vec{F}=\dfrac{1}{4\pi \varepsilon_0}\dfrac{Q_1Q_2}{r^2}\vec{r_0}$</p><p>电偶极子中垂线上任意点的场强：$\vec E=\dfrac{1}{4\pi\varepsilon_0}\dfrac{-\vec p} {r^3}$。</p><p>线密度$\mu$，面密度$\sigma$，体密度$\rho$</p><p>电通量：通过某一面积的电力线条数</p><p>$\phi=\int_S\vec{E}\cdot d\vec{s}=\int_sEdscos\theta$</p><p>高斯定理：<br>$$<br>\oint_s\vec{E}\cdot d\vec{s}=\dfrac{1}{\varepsilon_0}\sum_{inside,i}q_i=\dfrac{1}{\varepsilon_0}\int_V \rho dV<br>$$<br>求场强：</p><ul><li>用库仑公式积分</li><li>用高斯公式算</li><li>结合上述两种方法</li></ul><p>常用电场强度：</p><ul><li>电偶极子中垂线上任意点的场强：$\vec E=\dfrac{1}{4\pi\varepsilon_0}\dfrac{-\vec p} {r^3}$</li><li>电荷均匀分布的带电圆盘轴线上的电场强度：$E=\dfrac{\sigma}{2\varepsilon_0}(1-\dfrac{x}{r^2+x^2})$</li><li>电荷均匀分布的无限大平面轴线上的电场强度：$E=\dfrac{\sigma}{2\varepsilon_0}$</li><li>电荷均匀分布的带电圆环轴线上的电场强度：$E=\dfrac{1}{4\pi\varepsilon_0}\dfrac{qx}{(x^2+r^2)^{\frac{3}{2}}}$</li></ul><p>电势：$U_a=\dfrac{E_a}{q}=\int_a^b\vec{E}\cdot d\vec{l}$</p><p>求电势：</p><ul><li><p>点电荷微元求解法：$U_a=\int_a^b\dfrac{1}{4\pi \varepsilon_0}\dfrac{dq}{r}$</p></li><li><p>电势定义求解方法：场强沿积分路径积分</p></li></ul><p>静电平衡导体空腔场强分布：$E=\dfrac{\sigma}{\varepsilon_0}$</p><p><del>极化强度矢量：单位体积内分子电偶极矩的矢量和</del><br>$$<br>\vec{p}=\dfrac{\sum_i\vec{p_i}}{\Delta V}<br>$$<br><del>极化强度的实验定律：$\vec{p}=\varepsilon_0\chi_e\vec{E}$</del></p><p><del>$\chi_e$介质极化率</del></p><p>$\varepsilon$=$\varepsilon_0 \varepsilon_r$</p><p>其中，$\varepsilon_r$为相对介电常数</p><p><strong>介质中的高斯定理</strong><br>$$<br>q_p=-\oiint_s\vec{P}\cdot d\vec{s}<br>$$</p><p>$$<br>\oint_s{(\vec{E_f}+\vec{E_p})}\cdot d\vec{s}=\dfrac{q_f+q_p}{\varepsilon_0}<br>$$</p><p>得到：<br>$$<br>\oint_s\vec{E}\cdot d\vec{s}=\dfrac{q_f}{\varepsilon_0}-\dfrac{1}{\varepsilon_0}\oint_s\vec{P}\cdot d\vec{s}<br>$$<br><strong>电位移矢量</strong></p><p>$\vec{D}=\varepsilon_0\vec{E}+\vec{P}$</p><p>$\vec{D}=\varepsilon_0\varepsilon_r\vec{E}=\varepsilon\vec{E}$<br>$$<br>\oint_S\vec{D}\cdot d\vec{S}=\sum_{S内}q_0<br>$$<br>称为电介质中的高斯定理 <strong>——</strong> 电位移矢量通过静电场中任意封闭曲面的通量等于曲面内自由电荷的代数和。</p><h3 id="稳恒电场"><a href="#稳恒电场" class="headerlink" title="稳恒电场"></a>稳恒电场</h3><h5 id="毕奥—萨伐尔定律"><a href="#毕奥—萨伐尔定律" class="headerlink" title="毕奥—萨伐尔定律"></a>毕奥—萨伐尔定律</h5><p>$$<br>d\vec{B}=\dfrac{\mu_0}{4\pi}\dfrac{Idl\times\vec{e_r}}{r^2}​<br>$$</p><p>其中，$Idl$表示电流方向的电流微元，$r$距离电流微元的位矢。</p><p>无限长直导线的磁场分布：$B=\dfrac{\mu_0 I}{4\pi a}({cos\theta_1-cos\theta_2})$</p><p>环形电流在轴线上的磁场分布：$B=\dfrac{\mu_0}{4\pi}\dfrac{2\pi I R^2}{(R^2+x^2)^\frac{3}{2}}$</p><p>无限长导线沿磁力线闭合回路积分值：$\oint_l\vec{B}\cdot d\vec{l}=\mu_0I$</p><h5 id="安培环路定律"><a href="#安培环路定律" class="headerlink" title="安培环路定律"></a>安培环路定律</h5><p>$$<br>\oint_l\vec{B}\cdot dl=\mu_0\sum I_内<br>$$</p><p>洛伦兹力<br>$$<br>\vec{F}=q\vec{v}\times\vec{B}<br>$$</p><p>安培定律<br>$$<br>\vec{F}=\int Id\vec{l}\times\vec{B}<br>$$</p><p>磁场对线圈力矩</p><p>$$<br>\vec{M}=\vec{p_m}\times\vec{B};M=p_m\cdot B\sin\varphi<br>$$</p><p>其中，$\vec{p_m}=IS\vec{n}$，$S$为线圈的面积。</p><h5 id="有磁介质的安培环路定理"><a href="#有磁介质的安培环路定理" class="headerlink" title="有磁介质的安培环路定理"></a>有磁介质的安培环路定理</h5><p>$$<br>\oint_l{\vec{H}\cdot d\vec{l}}=\sum I_{o内}<br>$$</p><p>其中，$\vec{H}=\dfrac{\vec{B}}{\mu_0}-\vec{M}$（磁场强度矢量）</p><h5 id="动生电动势"><a href="#动生电动势" class="headerlink" title="动生电动势"></a>动生电动势</h5><p>$$<br>\varepsilon_i=\int_a^b d\varepsilon_i=\int_a^b(\vec{v}\times\vec{B})\cdot\vec{l}​<br>$$</p><p>$$<br>\varepsilon_i=-\dfrac{d\Phi_m}{dt}<br>$$</p><p>适用于在垂直于磁场平面内匀速转动的导线：$\varepsilon_i=\dfrac{1}{2}B\omega l^2$</p><h5 id="感生电动势"><a href="#感生电动势" class="headerlink" title="感生电动势"></a>感生电动势</h5><p>$$<br>\oint_s\vec{E_i}\cdot d\vec{l}=-\int_s\dfrac{\partial\vec{B}}{\partial t}\cdot d\vec{S}<br>$$</p><p>绕N匝长直螺线管中，变化电流产生的磁场为<br>$$<br>B=\mu_0NI<br>$$</p><p>无限长直导线，产生的磁场为<br>$$<br>B=\dfrac{\mu_0 I}{2\pi r}<br>$$<br>其中，$r$为距离。</p><h5 id="自感"><a href="#自感" class="headerlink" title="自感"></a>自感</h5><p>$$<br>\varepsilon_L=-\dfrac{d(N\Phi_m)}{dt}=-L\dfrac{dI}{dt}<br>$$</p><h5 id="互感"><a href="#互感" class="headerlink" title="互感"></a>互感</h5><p>$$<br>\varepsilon_L=-M\dfrac{dI}{dt},<br>$$</p><p>$$<br>M=\dfrac{N\Phi_m}{I}<br>$$</p><h5 id="线圈的磁能"><a href="#线圈的磁能" class="headerlink" title="线圈的磁能"></a>线圈的磁能</h5><p>$$<br>W_m=\dfrac{1}{2}LI^2<br>$$</p><p>磁场能量密度：</p><p>$$<br>\omega_m=\dfrac{1}{2}\dfrac{B^2}{\mu}=\dfrac{1}{2}\mu H^2=\dfrac{1}{2}BH<br>$$</p><h4 id="位移电流"><a href="#位移电流" class="headerlink" title="位移电流"></a>位移电流</h4><p>位移电流密度：<br>$$<br>\vec{j_d}=\dfrac{d\vec{D}}{dt}<br>$$<br>位移电流强度：<br>$$<br>I=_d\dfrac{d\varphi_D}{dt}<br>$$<br>其中，$\varphi_D$为电位移矢量的通量。</p><p>安培环路定律的一般形式：<br>$$<br>\oint_l\vec{H}\cdot d\vec{l}=\sum I_{0内}+\dfrac{d\varphi_d}{dt}<br>$$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;力学&quot;&gt;&lt;a href=&quot;#力学&quot; class=&quot;headerlink&quot; title=&quot;力学&quot;&gt;&lt;/a&gt;力学&lt;/h2&gt;&lt;h3 id=&quot;刚体力学&quot;&gt;&lt;a href=&quot;#刚体力学&quot; class=&quot;headerlink&quot; title=&quot;刚体力学&quot;&gt;&lt;/a&gt;刚体力学&lt;/h
      
    
    </summary>
    
    
    
      <category term="Math" scheme="ronpay.xyz/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>离散数学笔记</title>
    <link href="ronpay.xyz/2020/07/31/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    <id>ronpay.xyz/2020/07/31/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2020-07-31T02:31:36.000Z</published>
    <updated>2020-08-07T01:47:55.906Z</updated>
    
    <content type="html"><![CDATA[<p><strong>(公式有点小问题，有空再修改)</strong></p><h3 id="第1章-集合论"><a href="#第1章-集合论" class="headerlink" title="第1章 集合论"></a>第1章 集合论</h3><h4 id="空集"><a href="#空集" class="headerlink" title="空集"></a>空集</h4><ul><li>空集是一切集合的子集。</li><li>空集值是绝对唯一的.</li></ul><h4 id="集合基数"><a href="#集合基数" class="headerlink" title="集合基数"></a>集合基数</h4><p>集合$A$中元素的数目称为集合$A$的基数，记为$|A|$。</p><h4 id="m元子集"><a href="#m元子集" class="headerlink" title="m元子集"></a>m元子集</h4><p>如果一个集合$A$含有$n$个元素，则称集合$A$为$n$元集，称$A$的含有$m$个$(0≤m≤n)$元素的子集为$A$的$m$元子集。</p><h4 id="幂集"><a href="#幂集" class="headerlink" title="幂集"></a>幂集</h4><p>设$A$为任意集合，把$A$的所有不同子集为元素构成的集合叫做$A$的幂集，记为$P(A)$或$2^A$。</p><p>有$|P(A)|＝ 2^{|A|}$</p><h4 id="等势"><a href="#等势" class="headerlink" title="等势"></a>等势</h4><p>设$A，B$是两个集合，若在$A，B$之间存在$1-1$对应的关系：$ψ：A→B$</p><p>则称$A$与$B$是等势的，记为：$A$~$B$。</p><p>凡是与自然数集合等势的集合，均称为可数集合(可列集)。可数集合的基数记为：$\aleph_0$(读作阿列夫零) 。</p><h4 id="不可数集合"><a href="#不可数集合" class="headerlink" title="不可数集合"></a>不可数集合</h4><ul><li>开区间 $(0, 1)$ 称为不可数集合，其基数记为为$\aleph$ (读作阿列夫)；</li><li>凡是与开区间 $(0, 1)$ 等势的集合都是不可数集合。</li></ul><h4 id="集合运算定理"><a href="#集合运算定理" class="headerlink" title="集合运算定理"></a>集合运算定理</h4><p>设$A、B、C$为任意集合，$Ｕ$为全集，$Φ$为空集</p><ul><li>幂等律: $A∪A=A$； $A∩A=A$； </li><li>恒等律: $A∪Φ =A$；$A∩U =A$；    </li><li>零　律: $A∪U=U$；   $A∩Φ=Φ$；</li><li>否定律：$\overline{\overline{A}}=A$；</li><li>矛盾律： $A∩\overline{A}＝Φ$；</li><li>排中律：$A∪\overline{A}＝U$</li><li>交换律:  $A∪B=B∪A$; $A∩B=B∩A$</li><li>吸收律:  $A∩(A∪B)=A$; $A∪(A∩B)=A$；</li><li>DeMorgan律：$\overline{A∪B}=\overline{A}∩\overline{B}$，$\overline{A∩B}=\overline{A}∪\overline{B}$</li><li>结合律：$A∪(B∪C)=(A∪B)∪C$；<br>$A∩(B∩C)=(A∩B)∩C$；</li><li>分配律：$A∩(B∪C)=(A∩B)∪(A∩C)$;$A∪(B∩C)=(A∪B)∩(A∪C)$</li></ul><h3 id="第2章-计数问题"><a href="#第2章-计数问题" class="headerlink" title="第2章 计数问题"></a>第2章 计数问题</h3><h4 id="鸽笼原理"><a href="#鸽笼原理" class="headerlink" title="鸽笼原理"></a>鸽笼原理</h4><p>若有$n+1$只鸽子住进$n$个鸽笼，则有一个鸽笼至少住进$2$只鸽子。</p><h3 id="第3章-命题逻辑"><a href="#第3章-命题逻辑" class="headerlink" title="第3章 命题逻辑"></a>第3章 命题逻辑</h3><h4 id="基本等价公式"><a href="#基本等价公式" class="headerlink" title="基本等价公式"></a>基本等价公式</h4><p>设$G，H，S$是任何的公式，则：</p><ul><li>E1：$G∨(H∨S)＝(G∨H)∨S$  (结合律)</li><li>E2：$G∧(H∧S)＝(G∧H)∧S$</li><li>E3：$G∨H＝H∨G$         (交换律)</li><li>E4：$G∧H＝H∧G$</li><li>E5：$G∨G＝G$          (幂等律)</li><li>E6：$G∧G＝G$</li><li>E7：$G∨(G∧H)＝ G$                      (吸收律)</li><li>E8：$G∧(G∨H)＝ G$</li><li>E9：$G∨(H∧S)＝(G∨H)∧(G∨S)$    (分配律）</li><li>E10：$G∧(H∨S)＝(G∧H)∨(G∧S)$</li><li>E11：$G∨0＝G$                (同一律)</li><li>E12：$G∧1＝G$</li><li>E13：$G∨1＝1$                    (零律)</li><li>E14：$G∧0＝0$</li><li>E15：$G∨┐G ＝  1$                  (排中律)</li><li>E16：$G∧┐G ＝0$                  (矛盾律)</li><li>E17：$┐(┐G)＝G$                (双重否定律)</li><li>E18：$┐(G∨H)＝┐G∧┐H$            (德·摩根律)</li><li>E19：$┐(G∧H)＝┐G∨┐H$</li><li>E20：$G→H＝┐G∨H$             (蕴涵式)</li><li>E21: $G\leftrightarrow H＝(G→H)∧(H→G)$         (等价式)</li><li>E22：$G →H＝┐H→┐G$        (假言易位)</li><li>E23：$G\leftrightarrow H＝┐G\leftrightarrow ┐H$        (等价否定等式)</li><li>E24：$(G →H) ∧(G→┐H)＝┐G$    (归谬论)</li></ul><h3 id="第4章-谓词逻辑"><a href="#第4章-谓词逻辑" class="headerlink" title="第4章 谓词逻辑"></a>第4章 谓词逻辑</h3><h4 id="谓词演算中的基本等价公式"><a href="#谓词演算中的基本等价公式" class="headerlink" title="谓词演算中的基本等价公式"></a>谓词演算中的基本等价公式</h4><ul><li>E25：$(\exists x)G(x) = (\exists y)G(y)$ </li><li>E26：$(\forall x)G(x) = (\forall y)G(y)$             </li><li>E27： $\neg(\exists x)G(x) = (\forall x)\neg G(x)$</li><li>E28：$\neg(\forall x)G(x) = (\exists x)\neg G(x)$ </li><li>E29：$(\forall x)(G(x)∨S) = (\forall x)G(x)∨S$</li><li>E30：$(\forall x)(G(x)∧S) = (\forall x)G(x)∧S$</li><li>E31：$(\exists x)(G(x)∨S) = (\exists x)G(x)∨S$</li><li>E32：$(\exists x)(G(x)∧S) = (\exists x)G(x)∧S$</li><li>E33：$(\forall x)(G(x)∧H(x)) = (\forall x)G(x)∧(\forall x)H(x)$</li><li>E34：$(\exists x)(G(x)∨H(x)) = (\exists x)G(x)∨(\exists x)H(x)$(量词分配律)</li><li>E35：$(\forall x)G(x)∨(\forall x)H(x) = (\forall x)(\forall y)(G(x)∨H(y))$</li><li>E36：$(\exists x)G(x)∧(\exists x)H(x) = (\exists x)(\exists y)(G(x)∧H(y))$     </li></ul><h3 id="第5章-证明技术"><a href="#第5章-证明技术" class="headerlink" title="第5章 证明技术"></a>第5章 证明技术</h3><p>演绎法证明符号：</p><ul><li>P：条件； </li><li>T，，，I：由→推理得到；</li><li>T，，，E：有蕴涵式可得；</li><li>P（附加前提）：附加条件；</li><li>CP：使用附加前提要用CP规则；</li><li>US：去任意量词</li><li>ES：去存在量词</li><li>UG：加任意量词</li><li>EG：加存在量词</li></ul><h4 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h4><h3 id="第6章-二元关系"><a href="#第6章-二元关系" class="headerlink" title="第6章 二元关系"></a>第6章 二元关系</h3><h4 id="自反性和反自反性"><a href="#自反性和反自反性" class="headerlink" title="自反性和反自反性"></a>自反性和反自反性</h4><p>如果对任意$x∈A$，都有$&lt;x, x&gt;∈R$，那么称$R$在$A$上是自反的。</p><p>如果对任意$x∈A$，都有$&lt;x, x&gt;\not\in R$，那么称$R$在$A$上是反自反的。</p><h4 id="对称性和反对称性"><a href="#对称性和反对称性" class="headerlink" title="对称性和反对称性"></a>对称性和反对称性</h4><p>对任意$x, y∈A$，如果$&lt;x, y&gt;∈R$，那么$&lt;y,x&gt; ∈R$，则称关系$R$是对称的。</p><p>对任意$x, y∈A$，如果$&lt;x, y&gt;∈R$且$&lt;y,x&gt;∈R$，那么$x＝y$，则称关系$R$是反对称的。</p><h4 id="传递性"><a href="#传递性" class="headerlink" title="传递性"></a>传递性</h4><p>对任意$x, y, z∈A$，如果$&lt;x, y&gt;∈R$且$&lt;y, z&gt;∈R$，那么$&lt;x, z&gt;∈R$，则称关系$R$是传递的。</p><h4 id="关系性质的保守性"><a href="#关系性质的保守性" class="headerlink" title="关系性质的保守性"></a>关系性质的保守性</h4><p>设$R, S$是定义在$A$上的二元关系，则：</p><p>若$R,S$是自反的，则$R^{-1},R∪S,R∩S,RoS$也是自反的</p><p>若$R, S$是反自反的，则$R^{-1}, R∪S, R∩S, RoS$也是反自反的</p><p>若$R,S$是对称的，则$R^{-1},R∪S,R∩S,RoS$也是对称的</p><p>若$R,S$是反对称的，则$R^{-1}, R∩S, RoS$也是反对称的</p><p>若$R,S$是传递的，则$R^{-1}, R∩S$也是传递的</p><h4 id="关系的闭包"><a href="#关系的闭包" class="headerlink" title="关系的闭包"></a>关系的闭包</h4><p>设$R$是定义在$A$上的关系，若存在$A$上的另一个关系$R′$，使得$R\subseteq R′$，满足：</p><p>1.$R′$是自反的（对称的、或传递的）；</p><p>2.任何自反的（对称的、或传递的）关系$R〞$，如果$R\subseteq R$〞，就有$R′\subseteq R〞$，</p><p>则称$R′$为$R$的自反闭包（对称闭包或传递闭包），分别记为$r(R)$ （$s(R)$或$t(R)$）。</p><p>关系的闭包是增加最少元素，使其具备所需性质的扩充。</p><h3 id="第7章-特殊关系"><a href="#第7章-特殊关系" class="headerlink" title="第7章 特殊关系"></a>第7章 特殊关系</h3><h4 id="等价关系"><a href="#等价关系" class="headerlink" title="等价关系"></a>等价关系</h4><p>设R是定义在非空集合A上的关系，如果R是<strong>自反的、对称的、传递的</strong>，则称R为A上的等价关系。</p><h4 id="等价类"><a href="#等价类" class="headerlink" title="等价类"></a>等价类</h4><p>设$R$是非空集合$A$上的等价关系，对任意$x∈A$，称集合</p><p>$[x]_R = {y|y∈A∧&lt;x,y&gt;∈R}$</p><p>为$x$关于$R$的等价类，其中$x$称为$[x]_R$的生成元 。</p><ul><li>$R$具有自反性意味着对任意$x∈A，[x]_R ≠ Φ$。</li><li>$R$具有对称性意味着对任意$x, y∈A$，若有$y∈[x]R$，则一定有$x∈[y]_R$。</li></ul><h4 id="商集"><a href="#商集" class="headerlink" title="商集"></a>商集</h4><p>设$R$是非空集合$A$上的等价关系，由$R$确定的一切等价类为元素构成的集合，称为集合$A$关于$R$的商集，记为$A/R$，即$A/R = { [x]R | x∈A }$</p><h4 id="等价关系与划分"><a href="#等价关系与划分" class="headerlink" title="等价关系与划分"></a>等价关系与划分</h4><p>给定集合A的一个划分$П = {A1, A2, …, An}$， 则由该划分确定的关系$R = (A1×A1)∪(A2×A2)∪…∪(An×An)$是$A$上的等价关系。我们称该关系$R$为由划分$П$所导出的等价关系。</p><h4 id="拟序关系"><a href="#拟序关系" class="headerlink" title="拟序关系"></a>拟序关系</h4><p>设$R$是非空集合$A$上的关系，如果$R$是<strong>反自反</strong>、<strong>反对称</strong>和<strong>传递</strong>的，则称$R$是$A$上的拟序关系，简称拟序，记为“$＜$”，读作“小于”，并将“$&lt;a, b&gt;∈＜$”记为“$a＜b$”。</p><p>序偶&lt;A, ＜&gt;称为拟序集。<br>拟序“$＜$”的逆关系“$＜^{-1}$”也是拟序，用“$＞$”表示，读作“大于”。</p><h4 id="偏序关系"><a href="#偏序关系" class="headerlink" title="偏序关系"></a>偏序关系</h4><p>设$R$是非空集合$A$上的关系，如果$R$是<strong>自反</strong>的、<strong>反对称</strong>的和<strong>传递</strong>的，则称$R$是$A$上的偏序关系，简称偏序，记为“$≤$”。</p><p>偏序“$≤$”的逆关系“$≤-1$”也是一个偏序，我们用“$≥$”表示，读作“大于等于”；<br>$(≤-I_A)$为$A$上的拟序关系，$(＜∪I_A)$为$A$上的偏序关系。 </p><h4 id="哈斯图"><a href="#哈斯图" class="headerlink" title="哈斯图"></a>哈斯图</h4><ul><li>用小圆圈或点表示A中的元素，省掉关系图中所有的环；                       （因自反性)</li><li>对任意$x, y∈A$，若$x＜y$，则将$x$画在$y$的下方，可省掉关系图中所有边的箭头；（因反对称性）<br>对任意$x, y∈$A，若$x＜y$，且不存在$z∈A$，使得$x＜z,  z＜y$，则$x$与$y$之间用一条线相连，否则无线相连。（因传递性）</li></ul><h4 id="偏序集的特殊元素"><a href="#偏序集的特殊元素" class="headerlink" title="偏序集的特殊元素"></a>偏序集的特殊元素</h4><p>设$&lt;A, ≤&gt;$是偏序集，$B$是$A$的任何一个子集。若存在元素$a∈A$，使得</p><ul><li>对任意$x∈B$，都有$x ≤ a$，则称$a$为$B$的上界；</li><li>对任意$x∈B$，都有$a ≤ x$，则称$a$为$B$的下界；</li><li>若元素$a′∈A$是$B$的上界，元素$a∈A$是$B$的任何一个上界，均有$a′ ≤ a$，则称$a′$为$B$的最小上界或上确界，记为SupB；</li><li>若元素$a′∈A$是$B$的下界，元素$a∈A$是$B$的任何一个下界，均有$a ≤ a′$，则称$a′$为$B$的最大下界或下确界，记为InfB。</li></ul><h4 id="全序关系"><a href="#全序关系" class="headerlink" title="全序关系"></a>全序关系</h4><p>设$&lt;A, ≤ &gt;$为偏序集，若对任意$x, y∈A$，总有$x ≤ y$或$y ≤ x$，二者必居其一，则称关系“$≤$”为全序关系(Total Order Relation)，简称全序，或者线序关系，简称线序。称$&lt;A, ≤ &gt;$为全序集(Total Order Set)，或者线序集，或者链(Chain)。</p><h4 id="良序关系"><a href="#良序关系" class="headerlink" title="良序关系"></a>良序关系</h4><p>设$&lt;A, ≤ &gt;$是一偏序集，若$A$的每个非空子集都有最小元，则称“$≤$”为良序关系，简称良序，此时$&lt;A, ≤ &gt;$称为良序集。<br>良序关系一定是全序关系，反之则不然。</p><h3 id="第8章-函数"><a href="#第8章-函数" class="headerlink" title="第8章 函数"></a>第8章 函数</h3><h4 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h4><p>设$f$是集合$A$到$B$的关系，如果对每个$x∈A$，都存在惟一的$y∈B$，使得$&lt;x, y&gt;∈f$，则称关系f为A到B的函数(Function)(或映射(Mapping)、变换(Transform))，记为$f: A→B$。</p><p>当$&lt;x, y&gt;∈f$时，通常记为$y = f(x)$，这时称$x$为函数$f$的自变量，$y$为$x$在$f$下的函数值(或象)， 也称$x$为$y$在$f$下的原象 。 </p><p>称$A$为函数$f$的定义域，记为$domf$<br>称$f(A) = y| y = f(x), x∈A$为函数 $f$ 的值域，记为$ranf$<br>若$A = B$，则称$f$为$A$上的函数</p><h4 id="函数的类型"><a href="#函数的类型" class="headerlink" title="函数的类型"></a>函数的类型</h4><p>设$f$是从$A$到$B$的函数，对任意$x1, x2∈A$，</p><ul><li>如果$x1 ≠ x2$，有$f(x1) ≠ f(x2)$，则称$f$为从$A$到$B$的单射（不同的$x$对应不同的$y)$</li><li>如果$ranf = B$，则称$f$为从$A$到$B$的满射</li><li>若$f$是满射且是单射，则称$f$为从$A$到$B$的双射</li><li>当$A$上的函数$f$是双射时，称$f$为变换</li></ul><h4 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h4><p>设$A, B$是有限集合，且$|A| = |B|$，$f$是$A$到$B$的函数，则$f$是单射当且仅当$f$是满射。</p><h4 id="函数的运算"><a href="#函数的运算" class="headerlink" title="函数的运算"></a>函数的运算</h4><p>考虑$f: A→B，g: B→C$是两个函数，则 $fog = { &lt;x, z&gt; | x∈A{∧}z∈C{∧}(\exists   y)(y∈B{∧}&lt;x, y&gt;∈f{∧}&lt;y, z&gt;∈g)}$从$A$到$C$的函数，记为$fog: A→C$ ，称为函数$f$与$g$的复合函数。对任意$x∈A，fog(x) = g(f(x))$。</p><h4 id="定理-1"><a href="#定理-1" class="headerlink" title="定理"></a>定理</h4><p>若$f$是$A$到$B$的双射，则$f$的逆函数$f^{-1}$也是$B$到$A$的双射。</p><h3 id="第9章-图"><a href="#第9章-图" class="headerlink" title="第9章 图"></a>第9章 图</h3><h4 id="特殊图"><a href="#特殊图" class="headerlink" title="特殊图"></a>特殊图</h4><ul><li>仅由孤立结点组成的图称为<strong>零图</strong>(Null Graph)</li><li>仅含一个结点的零图称为<strong>平凡图</strong>(Trivial Graph)</li><li>含有n个结点，m条边的图，称为<strong>(n, m)图</strong></li></ul><h4 id="图的分类"><a href="#图的分类" class="headerlink" title="图的分类"></a>图的分类</h4><p>在有向图中，两结点间(包括结点自身间)若有同始点和同终点的几条边，则这几条边称为<strong>平行边</strong>，在无向图中，两结点间(包括结点自身间)若有几条边，则这几条边称为<strong>平行边</strong>。两结点a、b间相互平行的边的条数称为边(a, b)或&lt;a, b&gt;的<strong>重数</strong>(Repeated Number)。</p><ul><li>含有平行边的图称为多重图(Multigraph)</li><li>非多重图称为线图(Line Graph)；</li><li>无环的线图称为简单图(Simple Graph)</li></ul><h4 id="子图和补图"><a href="#子图和补图" class="headerlink" title="子图和补图"></a>子图和补图</h4><ul><li><p>若$V_1 =V$，$E_1$包含于 $E$，则称$G_1$是$G$的<strong>生成子图</strong>(Spanning Subgraph)</p></li><li><p>设$V_2$ 包含于$V$且$V_2$ ≠ 空集，以$V_2$为结点集，以两个端点均在$V_2$中的边的全体为边集的$G$的子图，称为$V_2$导出的$G$的子图，简称$V_2$的<strong>导出子图</strong>(Induced Subgraph)</p></li><li><p>设$G = &lt;V, E&gt;$为一个具有$n$个结点的无向简单图，如果$G$中任意两个结点间都有边相连，则称G为<strong>无向完全图</strong>(Undirected Complete Graph)，简称$G$为完全图(Complete Graph)，记为$K_n$。</p></li><li><p>设$G = &lt;V, E&gt;$为一个具有$n$个结点的有向简单图，如果$G$中任意两个结点间都有两条方向相反的有向边相连，则称$G$为<strong>有向完全图</strong>(directed Complete Graph)，在不发生误解的情况下，也记为$K_n$。    </p></li></ul><h4 id="结点的度数与握手定理"><a href="#结点的度数与握手定理" class="headerlink" title="结点的度数与握手定理"></a>结点的度数与握手定理</h4><p>对于图$G = &lt;V, E&gt;$，度数为$1$的结点称为<strong>悬挂结点</strong>(Hanging Point)，以悬挂结点为端点的边称为<strong>悬挂边</strong>(Hanging Edge)。 </p><h5 id="握手定理"><a href="#握手定理" class="headerlink" title="握手定理"></a>握手定理</h5><p>图中结点度数的总和等于边数的二倍，即设图G $= &lt;V, E&gt;$，则有<br>$$<br>\sum_{v\in V}deg(v)=2|E|<br>$$</p><h5 id="推论"><a href="#推论" class="headerlink" title="推论"></a>推论</h5><p>图中度数为奇数的结点个数为偶数。</p><h3 id="第11章-特殊图"><a href="#第11章-特殊图" class="headerlink" title="第11章 特殊图"></a>第11章 特殊图</h3><h4 id="欧拉图"><a href="#欧拉图" class="headerlink" title="欧拉图"></a>欧拉图</h4><p>设$G$是无孤立结点的图，若存在一条通路(回路)，经过图中每边一次且仅一次，则称此通路(回路)为该图的一条欧拉通路(回路)(Eulerian Entry/Circuit)。具有欧拉回路的图称为欧拉图(Eulerian Graph)。</p><p>规定：平凡图为欧拉图。<br>以上定义既适合无向图，又适合有向图。 </p><h4 id="欧拉图的判定"><a href="#欧拉图的判定" class="headerlink" title="欧拉图的判定"></a>欧拉图的判定</h4><p>定理11.2.1  无向图$G = &lt;V, E&gt;$具有一条欧拉通路，当且仅当$G$是连通的，且仅有零个或两个奇度数结点。规定：平凡图为欧拉图。以上定义既适合无向图，又适合有向图。</p><p>定理11.2.2 有向图$G$具有欧拉通路，当且仅当$G$是连通的，且除了两个结点以外，其余结点的入度等于出度，而这两个例外的结点中，一个结点的入度比出度大1，另一个结点的出度比入度大1。</p><h4 id="欧拉图的算法"><a href="#欧拉图的算法" class="headerlink" title="欧拉图的算法"></a>欧拉图的算法</h4><p>设$G = &lt;V, E&gt;，e∈E$，如果$p(G-e)＞p(G)$,称$e$为$G$的桥(Bridge)或割边(Cut edge)。</p><p>其中，$p$表示连通分量的个数。</p><ol><li>求欧拉图$G = &lt;V, E&gt;$的欧拉回路的Fleury算法：<br>任取$v_0∈V，令P_0 = v_0，i = 0$；</li><li>按下面的方法从$E-{e_1, e_2, …, e_i}$中选取$e_{i+1}$：要求：<br>$e_{i+1}$与$v_i$相关联；<br>除非无别的边可选取，否则$e_{i+1}$不应该为<br>$  G’ = G - {e_1, e_2, …, e_i}$中的桥；</li><li>将边$e_{i+1}$加入通路$P_0$中，令<br>$P_0 = v0e1v1e2…eivie_{i+1}v_{i+1}，   i = i+1$；</li><li>如果$i = |E|$，结束，否则转(2)。</li></ol><p>“<strong>一笔画问题</strong>”本质上就是一个无向图是否存在欧拉通路(回路)的问题。</p><h4 id="哈密顿图的定义"><a href="#哈密顿图的定义" class="headerlink" title="哈密顿图的定义"></a>哈密顿图的定义</h4><p>经过图中每个结点一次且仅一次的通路(回路)称为哈密顿通路(回路)(Hamiltonian Entry/circuit)。存在哈密顿回路的图称为哈密顿图(Hamiltonian Graph)。规定：平凡图为哈密顿图。以上定义既适合无向图，又适合有向图。</p><h4 id="哈密顿图的判定"><a href="#哈密顿图的判定" class="headerlink" title="哈密顿图的判定"></a>哈密顿图的判定</h4><p>定理11.3.1  设无向图$G = &lt;V, E&gt;$是哈密顿图，$V_1$是$V$的任意非空子集，则$p(G-V_1) ≤ |V_1|$</p><p>其中$p(G-V_1)$是从$G$中删除$V_1$后所得到图的连通分支数。</p><p>定理11.3.1在应用中它本身用处不大，但它的逆否命题却非常有用。我们经常利用定理11.3.1的逆否命题来判断某些图不是哈密顿图，即：若存在$V$的某个非空子集$V_1$使得 $p(G-V_1)＞|V_1|$，则$G$不是哈密顿图。 </p><p>(以下为充分条件)</p><p>定理11.3.2  设$G = &lt;V, E&gt;$是具有$n$个结点的简单无向图。如果对任意两个不相邻的结点$u, v∈V$，均有$deg(u) + deg(v) ≥ n - 1$,则$G$中存在哈密顿通路。</p><p>推论11.3.2  设$G = &lt;V, E&gt;$是具有$n$个结点的简单无向图。如果对任意两个不相邻的结点$u, v∈V$，均有$deg(u) + deg(v) ≥ n$,则$G$中存在哈密顿回路。</p><p>推论11.3.3  设$G = &lt;V, E&gt;$是具有$n$个结点的简单无向图，$n ≥ 3$。如果对任意$v∈V$，均有$deg(v) ≥ n/2$，则$G$是哈密顿图。</p><h4 id="偶图"><a href="#偶图" class="headerlink" title="偶图"></a>偶图</h4><p>定义11.4.1  若无向图$G = &lt;V, E&gt;$的结点集$V$能够划分为两个子集$V_1, V_2$，满足$V_1∩V_2 = Φ$，$且V_1∪V_2 = V$，使得$G$中任意一条边的两个端点，一个属于$V_1$，另一个属于$V_2$，则称$G$为偶图(Bipartite Graph)或二分图(Bigraph)。$V_1$和$V_2$称为互补结点子集，偶图通常记为$G=&lt;V_1, E, V_2&gt;$。</p><p>定义11.4.2  在偶图$G = &lt;V_1, E, V_2&gt;$中，若$V_1$中的每个结点与$V_2$中的每个结点都有且仅有一条边相关联，则称偶图$G$为完全偶图(Complete Bipartite Graph)或完全二分图(Complete Bigraph)，记为$K_{i, j}$，其中，$i = |V_1|，j = |V_2|$。（即第一个集合中的所有顶点都与第二个集合中的所有顶点相连）</p><p>偶图的判断</p><p>定理11.4.1  无向图$G = &lt;V, E&gt;$为偶图的充分必要条件是$G$的所有回路的长度均为偶数。</p><p>一般：我们常使用它的逆否命题来判断一个图不是偶图：无向图$G$不是偶图的充分必要条件是$G$中存在长度为奇数的回路。</p><h4 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h4><p>定义11.4.2  在偶图$G = &lt;V_1, E, V_2$&gt;中，$V_1 = {v_1, v_2, …, v_q}$，若存在$E$的子集$E’ = {(v_1, v_1’)，(v_2, v_2’)，…，(v_q, v_q’)}$，其中$v1’, v2’, …, vq’ $是$V2$中的$q$个不同的结点}，则称$G$的子图$G’ = &lt;V_1, E’, V_2&gt;$为从$V_1$到$V_2$的一个完全匹配(Complete Matching)，简称匹配。</p><p>定理11.4.2 (霍尔定理)  偶图$G = &lt;V_1, E, V_2&gt;$中存在从$V_1$到$V_2$的匹配的充分必要条件是$V_1$中任意$k$个结点至少与$V_2$中的$k$个结点相邻，$k = 1, 2, …, |V_1|$.定理11.4.2中的条件通常称为相异性条件(Diversity Condition)。</p><p>定理11.4.3  设$G = &lt;V_1,E,V_2&gt;$是一个偶图。如果满足条件<br>      （1）$V_1$中每个结点至少关联$t$条边；<br>      （2）$V_2$中每个结点至多关联$t$条边；<br>则$G$中存在从$V_1$到$V_2$的匹配。其中$t$为正整数。</p><h4 id="平面图"><a href="#平面图" class="headerlink" title="平面图"></a>平面图</h4><p>如果能把一个无向图$G$的所有结点和边画在平面上，使得任何两边除公共结点外没有其他交叉点，则称$G$为平面图(Plane Graph)，否则称$G$为非平面图(Nonplanar Graph)。</p><h4 id="欧拉公式"><a href="#欧拉公式" class="headerlink" title="欧拉公式"></a>欧拉公式</h4><ul><li>由边所包围的其内部不包含图的结点和边的区域，称为$G$的一个面(Surface)</li><li>包围该面的边所构成的回路称为这个面的边界(Bound)</li><li>面$r$的边界的长度称为该面的次数(Degree)，记为$D(r)$</li><li>区域面积有限的面称为有限面(Finite Surface)，区域面积无限的面称为无限面(Infinite Surface)</li><li>平面图有且仅有一个无限面</li></ul><p>定理11.5.1  平面图中所有面的次数之和等于边数的二倍。怎么理解？每条边会被用两次</p><p>定理11.5.2  设$G = &lt;V, E&gt;$是连通平面图，若它有$n$个结点、$m$条边和$r$个面，则有</p><p>$$<br>n – m + r = 2<br>$$</p><p>推论11.5.1  设$G$是一个$(n, m)$简单连通平面图，若$m＞1$，则有$m ≤ 3n - 6$。</p><p>一般使用逆否命题，即一个简单连通图，若不满足 $m ≤ 3n - 6$，则一定是非平面图。</p><p>推论11.5.2  设$G$是一个$(n, m)$简单连通平面图，若每个面的次数至少为$k (k ≥ 3)$，则有 $m\leq\dfrac{k}{k-2}(n-2)$</p><p>完全图$K_5$，$k_{3,3}$是非平面图。</p><h4 id="库拉托夫斯基定理"><a href="#库拉托夫斯基定理" class="headerlink" title="库拉托夫斯基定理"></a>库拉托夫斯基定理</h4><p>定理11.5.3(库拉托夫斯基定理)  一个图是平面图的充分必要条件是它的任何子图都不可能收缩为$K5$或$K3, 3$。</p><p>推论11.5.3  一个图是非平面图的充分必要条件是它存在一个能收缩为$K_5$或$K_{3, 3}$的子图。</p><p>$K_5$和$K_{3,3}$称为库拉托夫斯基图(Kuratowski Graph)。</p><h2 id="离散数学题型笔记"><a href="#离散数学题型笔记" class="headerlink" title="离散数学题型笔记"></a>离散数学题型笔记</h2><h3 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h3><h3 id="计算题"><a href="#计算题" class="headerlink" title="计算题"></a>计算题</h3><h4 id="主析取范式和主合取范式"><a href="#主析取范式和主合取范式" class="headerlink" title="主析取范式和主合取范式"></a>主析取范式和主合取范式</h4><p>进行化简。</p><p>通过添加P∧P，P∨P，来凑取。</p><p>求得一个可以推下一个。</p><p>确定是析取还是合取。</p><h3 id="证明题"><a href="#证明题" class="headerlink" title="证明题"></a>证明题</h3><h4 id="演绎推理"><a href="#演绎推理" class="headerlink" title="演绎推理"></a>演绎推理</h4><p>通过演绎推理，注意P-&gt;Q 与 P∨Q的区别。</p><p>证明符号：</p><ul><li>P：条件； </li><li>T，序号，序号，I：由→推理得到；</li><li>T，序号，序号，E：有蕴涵式可得；</li><li>P（附加前提）：附加条件；</li><li>CP：使用附加前提要用CP规则；</li><li>US：去任意量词</li><li>ES：去存在量词</li><li>UG：加任意量词</li><li>EG：加存在量词</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;(公式有点小问题，有空再修改)&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;第1章-集合论&quot;&gt;&lt;a href=&quot;#第1章-集合论&quot; class=&quot;headerlink&quot; title=&quot;第1章 集合论&quot;&gt;&lt;/a&gt;第1章 集合论&lt;/h3&gt;&lt;h4 id=&quot;空集&quot;&gt;&lt;
      
    
    </summary>
    
    
    
      <category term="Math" scheme="ronpay.xyz/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>离散数学笔记</title>
    <link href="ronpay.xyz/2020/07/31/%E5%BE%AE%E7%A7%AF%E5%88%86II%E7%AC%94%E8%AE%B0/"/>
    <id>ronpay.xyz/2020/07/31/%E5%BE%AE%E7%A7%AF%E5%88%86II%E7%AC%94%E8%AE%B0/</id>
    <published>2020-07-31T02:31:36.000Z</published>
    <updated>2020-08-07T01:47:53.856Z</updated>
    
    <content type="html"><![CDATA[<p><strong>(公式有点小问题，有空再修改)</strong></p><h3 id="第1章-集合论"><a href="#第1章-集合论" class="headerlink" title="第1章 集合论"></a>第1章 集合论</h3><h4 id="空集"><a href="#空集" class="headerlink" title="空集"></a>空集</h4><ul><li>空集是一切集合的子集。</li><li>空集值是绝对唯一的.</li></ul><h4 id="集合基数"><a href="#集合基数" class="headerlink" title="集合基数"></a>集合基数</h4><p>集合$A$中元素的数目称为集合$A$的基数，记为$|A|$。</p><h4 id="m元子集"><a href="#m元子集" class="headerlink" title="m元子集"></a>m元子集</h4><p>如果一个集合$A$含有$n$个元素，则称集合$A$为$n$元集，称$A$的含有$m$个$(0≤m≤n)$元素的子集为$A$的$m$元子集。</p><h4 id="幂集"><a href="#幂集" class="headerlink" title="幂集"></a>幂集</h4><p>设$A$为任意集合，把$A$的所有不同子集为元素构成的集合叫做$A$的幂集，记为$P(A)$或$2^A$。</p><p>有$|P(A)|＝ 2^{|A|}$</p><h4 id="等势"><a href="#等势" class="headerlink" title="等势"></a>等势</h4><p>设$A，B$是两个集合，若在$A，B$之间存在$1-1$对应的关系：$ψ：A→B$</p><p>则称$A$与$B$是等势的，记为：$A$~$B$。</p><p>凡是与自然数集合等势的集合，均称为可数集合(可列集)。可数集合的基数记为：$\aleph_0$(读作阿列夫零) 。</p><h4 id="不可数集合"><a href="#不可数集合" class="headerlink" title="不可数集合"></a>不可数集合</h4><ul><li>开区间 $(0, 1)$ 称为不可数集合，其基数记为为$\aleph$ (读作阿列夫)；</li><li>凡是与开区间 $(0, 1)$ 等势的集合都是不可数集合。</li></ul><h4 id="集合运算定理"><a href="#集合运算定理" class="headerlink" title="集合运算定理"></a>集合运算定理</h4><p>设$A、B、C$为任意集合，$Ｕ$为全集，$Φ$为空集</p><ul><li>幂等律: $A∪A=A$； $A∩A=A$； </li><li>恒等律: $A∪Φ =A$；$A∩U =A$；    </li><li>零　律: $A∪U=U$；   $A∩Φ=Φ$；</li><li>否定律：$\overline{\overline{A}}=A$；</li><li>矛盾律： $A∩\overline{A}＝Φ$；</li><li>排中律：$A∪\overline{A}＝U$</li><li>交换律:  $A∪B=B∪A$; $A∩B=B∩A$</li><li>吸收律:  $A∩(A∪B)=A$; $A∪(A∩B)=A$；</li><li>DeMorgan律：$\overline{A∪B}=\overline{A}∩\overline{B}$，$\overline{A∩B}=\overline{A}∪\overline{B}$</li><li>结合律：$A∪(B∪C)=(A∪B)∪C$；<br>$A∩(B∩C)=(A∩B)∩C$；</li><li>分配律：$A∩(B∪C)=(A∩B)∪(A∩C)$;$A∪(B∩C)=(A∪B)∩(A∪C)$</li></ul><h3 id="第2章-计数问题"><a href="#第2章-计数问题" class="headerlink" title="第2章 计数问题"></a>第2章 计数问题</h3><h4 id="鸽笼原理"><a href="#鸽笼原理" class="headerlink" title="鸽笼原理"></a>鸽笼原理</h4><p>若有$n+1$只鸽子住进$n$个鸽笼，则有一个鸽笼至少住进$2$只鸽子。</p><h3 id="第3章-命题逻辑"><a href="#第3章-命题逻辑" class="headerlink" title="第3章 命题逻辑"></a>第3章 命题逻辑</h3><h4 id="基本等价公式"><a href="#基本等价公式" class="headerlink" title="基本等价公式"></a>基本等价公式</h4><p>设$G，H，S$是任何的公式，则：</p><ul><li>E1：$G∨(H∨S)＝(G∨H)∨S$  (结合律)</li><li>E2：$G∧(H∧S)＝(G∧H)∧S$</li><li>E3：$G∨H＝H∨G$         (交换律)</li><li>E4：$G∧H＝H∧G$</li><li>E5：$G∨G＝G$          (幂等律)</li><li>E6：$G∧G＝G$</li><li>E7：$G∨(G∧H)＝ G$                      (吸收律)</li><li>E8：$G∧(G∨H)＝ G$</li><li>E9：$G∨(H∧S)＝(G∨H)∧(G∨S)$    (分配律）</li><li>E10：$G∧(H∨S)＝(G∧H)∨(G∧S)$</li><li>E11：$G∨0＝G$                (同一律)</li><li>E12：$G∧1＝G$</li><li>E13：$G∨1＝1$                    (零律)</li><li>E14：$G∧0＝0$</li><li>E15：$G∨┐G ＝  1$                  (排中律)</li><li>E16：$G∧┐G ＝0$                  (矛盾律)</li><li>E17：$┐(┐G)＝G$                (双重否定律)</li><li>E18：$┐(G∨H)＝┐G∧┐H$            (德·摩根律)</li><li>E19：$┐(G∧H)＝┐G∨┐H$</li><li>E20：$G→H＝┐G∨H$             (蕴涵式)</li><li>E21: $G\leftrightarrow H＝(G→H)∧(H→G)$         (等价式)</li><li>E22：$G →H＝┐H→┐G$        (假言易位)</li><li>E23：$G\leftrightarrow H＝┐G\leftrightarrow ┐H$        (等价否定等式)</li><li>E24：$(G →H) ∧(G→┐H)＝┐G$    (归谬论)</li></ul><h3 id="第4章-谓词逻辑"><a href="#第4章-谓词逻辑" class="headerlink" title="第4章 谓词逻辑"></a>第4章 谓词逻辑</h3><h4 id="谓词演算中的基本等价公式"><a href="#谓词演算中的基本等价公式" class="headerlink" title="谓词演算中的基本等价公式"></a>谓词演算中的基本等价公式</h4><ul><li>E25：$(\exists x)G(x) = (\exists y)G(y)$ </li><li>E26：$(\forall x)G(x) = (\forall y)G(y)$             </li><li>E27： $\neg(\exists x)G(x) = (\forall x)\neg G(x)$</li><li>E28：$\neg(\forall x)G(x) = (\exists x)\neg G(x)$ </li><li>E29：$(\forall x)(G(x)∨S) = (\forall x)G(x)∨S$</li><li>E30：$(\forall x)(G(x)∧S) = (\forall x)G(x)∧S$</li><li>E31：$(\exists x)(G(x)∨S) = (\exists x)G(x)∨S$</li><li>E32：$(\exists x)(G(x)∧S) = (\exists x)G(x)∧S$</li><li>E33：$(\forall x)(G(x)∧H(x)) = (\forall x)G(x)∧(\forall x)H(x)$</li><li>E34：$(\exists x)(G(x)∨H(x)) = (\exists x)G(x)∨(\exists x)H(x)$(量词分配律)</li><li>E35：$(\forall x)G(x)∨(\forall x)H(x) = (\forall x)(\forall y)(G(x)∨H(y))$</li><li>E36：$(\exists x)G(x)∧(\exists x)H(x) = (\exists x)(\exists y)(G(x)∧H(y))$     </li></ul><h3 id="第5章-证明技术"><a href="#第5章-证明技术" class="headerlink" title="第5章 证明技术"></a>第5章 证明技术</h3><p>演绎法证明符号：</p><ul><li>P：条件； </li><li>T，，，I：由→推理得到；</li><li>T，，，E：有蕴涵式可得；</li><li>P（附加前提）：附加条件；</li><li>CP：使用附加前提要用CP规则；</li><li>US：去任意量词</li><li>ES：去存在量词</li><li>UG：加任意量词</li><li>EG：加存在量词</li></ul><h4 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h4><h3 id="第6章-二元关系"><a href="#第6章-二元关系" class="headerlink" title="第6章 二元关系"></a>第6章 二元关系</h3><h4 id="自反性和反自反性"><a href="#自反性和反自反性" class="headerlink" title="自反性和反自反性"></a>自反性和反自反性</h4><p>如果对任意$x∈A$，都有$&lt;x, x&gt;∈R$，那么称$R$在$A$上是自反的。</p><p>如果对任意$x∈A$，都有$&lt;x, x&gt;\not\in R$，那么称$R$在$A$上是反自反的。</p><h4 id="对称性和反对称性"><a href="#对称性和反对称性" class="headerlink" title="对称性和反对称性"></a>对称性和反对称性</h4><p>对任意$x, y∈A$，如果$&lt;x, y&gt;∈R$，那么$&lt;y,x&gt; ∈R$，则称关系$R$是对称的。</p><p>对任意$x, y∈A$，如果$&lt;x, y&gt;∈R$且$&lt;y,x&gt;∈R$，那么$x＝y$，则称关系$R$是反对称的。</p><h4 id="传递性"><a href="#传递性" class="headerlink" title="传递性"></a>传递性</h4><p>对任意$x, y, z∈A$，如果$&lt;x, y&gt;∈R$且$&lt;y, z&gt;∈R$，那么$&lt;x, z&gt;∈R$，则称关系$R$是传递的。</p><h4 id="关系性质的保守性"><a href="#关系性质的保守性" class="headerlink" title="关系性质的保守性"></a>关系性质的保守性</h4><p>设$R, S$是定义在$A$上的二元关系，则：</p><p>若$R,S$是自反的，则$R^{-1},R∪S,R∩S,RoS$也是自反的</p><p>若$R, S$是反自反的，则$R^{-1}, R∪S, R∩S, RoS$也是反自反的</p><p>若$R,S$是对称的，则$R^{-1},R∪S,R∩S,RoS$也是对称的</p><p>若$R,S$是反对称的，则$R^{-1}, R∩S, RoS$也是反对称的</p><p>若$R,S$是传递的，则$R^{-1}, R∩S$也是传递的</p><h4 id="关系的闭包"><a href="#关系的闭包" class="headerlink" title="关系的闭包"></a>关系的闭包</h4><p>设$R$是定义在$A$上的关系，若存在$A$上的另一个关系$R′$，使得$R\subseteq R′$，满足：</p><p>1.$R′$是自反的（对称的、或传递的）；</p><p>2.任何自反的（对称的、或传递的）关系$R〞$，如果$R\subseteq R$〞，就有$R′\subseteq R〞$，</p><p>则称$R′$为$R$的自反闭包（对称闭包或传递闭包），分别记为$r(R)$ （$s(R)$或$t(R)$）。</p><p>关系的闭包是增加最少元素，使其具备所需性质的扩充。</p><h3 id="第7章-特殊关系"><a href="#第7章-特殊关系" class="headerlink" title="第7章 特殊关系"></a>第7章 特殊关系</h3><h4 id="等价关系"><a href="#等价关系" class="headerlink" title="等价关系"></a>等价关系</h4><p>设R是定义在非空集合A上的关系，如果R是<strong>自反的、对称的、传递的</strong>，则称R为A上的等价关系。</p><h4 id="等价类"><a href="#等价类" class="headerlink" title="等价类"></a>等价类</h4><p>设$R$是非空集合$A$上的等价关系，对任意$x∈A$，称集合</p><p>$[x]_R = {y|y∈A∧&lt;x,y&gt;∈R}$</p><p>为$x$关于$R$的等价类，其中$x$称为$[x]_R$的生成元 。</p><ul><li>$R$具有自反性意味着对任意$x∈A，[x]_R ≠ Φ$。</li><li>$R$具有对称性意味着对任意$x, y∈A$，若有$y∈[x]R$，则一定有$x∈[y]_R$。</li></ul><h4 id="商集"><a href="#商集" class="headerlink" title="商集"></a>商集</h4><p>设$R$是非空集合$A$上的等价关系，由$R$确定的一切等价类为元素构成的集合，称为集合$A$关于$R$的商集，记为$A/R$，即$A/R = { [x]R | x∈A }$</p><h4 id="等价关系与划分"><a href="#等价关系与划分" class="headerlink" title="等价关系与划分"></a>等价关系与划分</h4><p>给定集合A的一个划分$П = {A1, A2, …, An}$， 则由该划分确定的关系$R = (A1×A1)∪(A2×A2)∪…∪(An×An)$是$A$上的等价关系。我们称该关系$R$为由划分$П$所导出的等价关系。</p><h4 id="拟序关系"><a href="#拟序关系" class="headerlink" title="拟序关系"></a>拟序关系</h4><p>设$R$是非空集合$A$上的关系，如果$R$是<strong>反自反</strong>、<strong>反对称</strong>和<strong>传递</strong>的，则称$R$是$A$上的拟序关系，简称拟序，记为“$＜$”，读作“小于”，并将“$&lt;a, b&gt;∈＜$”记为“$a＜b$”。</p><p>序偶&lt;A, ＜&gt;称为拟序集。<br>拟序“$＜$”的逆关系“$＜^{-1}$”也是拟序，用“$＞$”表示，读作“大于”。</p><h4 id="偏序关系"><a href="#偏序关系" class="headerlink" title="偏序关系"></a>偏序关系</h4><p>设$R$是非空集合$A$上的关系，如果$R$是<strong>自反</strong>的、<strong>反对称</strong>的和<strong>传递</strong>的，则称$R$是$A$上的偏序关系，简称偏序，记为“$≤$”。</p><p>偏序“$≤$”的逆关系“$≤-1$”也是一个偏序，我们用“$≥$”表示，读作“大于等于”；<br>$(≤-I_A)$为$A$上的拟序关系，$(＜∪I_A)$为$A$上的偏序关系。 </p><h4 id="哈斯图"><a href="#哈斯图" class="headerlink" title="哈斯图"></a>哈斯图</h4><ul><li>用小圆圈或点表示A中的元素，省掉关系图中所有的环；                       （因自反性)</li><li>对任意$x, y∈A$，若$x＜y$，则将$x$画在$y$的下方，可省掉关系图中所有边的箭头；（因反对称性）<br>对任意$x, y∈$A，若$x＜y$，且不存在$z∈A$，使得$x＜z,  z＜y$，则$x$与$y$之间用一条线相连，否则无线相连。（因传递性）</li></ul><h4 id="偏序集的特殊元素"><a href="#偏序集的特殊元素" class="headerlink" title="偏序集的特殊元素"></a>偏序集的特殊元素</h4><p>设$&lt;A, ≤&gt;$是偏序集，$B$是$A$的任何一个子集。若存在元素$a∈A$，使得</p><ul><li>对任意$x∈B$，都有$x ≤ a$，则称$a$为$B$的上界；</li><li>对任意$x∈B$，都有$a ≤ x$，则称$a$为$B$的下界；</li><li>若元素$a′∈A$是$B$的上界，元素$a∈A$是$B$的任何一个上界，均有$a′ ≤ a$，则称$a′$为$B$的最小上界或上确界，记为SupB；</li><li>若元素$a′∈A$是$B$的下界，元素$a∈A$是$B$的任何一个下界，均有$a ≤ a′$，则称$a′$为$B$的最大下界或下确界，记为InfB。</li></ul><h4 id="全序关系"><a href="#全序关系" class="headerlink" title="全序关系"></a>全序关系</h4><p>设$&lt;A, ≤ &gt;$为偏序集，若对任意$x, y∈A$，总有$x ≤ y$或$y ≤ x$，二者必居其一，则称关系“$≤$”为全序关系(Total Order Relation)，简称全序，或者线序关系，简称线序。称$&lt;A, ≤ &gt;$为全序集(Total Order Set)，或者线序集，或者链(Chain)。</p><h4 id="良序关系"><a href="#良序关系" class="headerlink" title="良序关系"></a>良序关系</h4><p>设$&lt;A, ≤ &gt;$是一偏序集，若$A$的每个非空子集都有最小元，则称“$≤$”为良序关系，简称良序，此时$&lt;A, ≤ &gt;$称为良序集。<br>良序关系一定是全序关系，反之则不然。</p><h3 id="第8章-函数"><a href="#第8章-函数" class="headerlink" title="第8章 函数"></a>第8章 函数</h3><h4 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h4><p>设$f$是集合$A$到$B$的关系，如果对每个$x∈A$，都存在惟一的$y∈B$，使得$&lt;x, y&gt;∈f$，则称关系f为A到B的函数(Function)(或映射(Mapping)、变换(Transform))，记为$f: A→B$。</p><p>当$&lt;x, y&gt;∈f$时，通常记为$y = f(x)$，这时称$x$为函数$f$的自变量，$y$为$x$在$f$下的函数值(或象)， 也称$x$为$y$在$f$下的原象 。 </p><p>称$A$为函数$f$的定义域，记为$domf$<br>称$f(A) = y| y = f(x), x∈A$为函数 $f$ 的值域，记为$ranf$<br>若$A = B$，则称$f$为$A$上的函数</p><h4 id="函数的类型"><a href="#函数的类型" class="headerlink" title="函数的类型"></a>函数的类型</h4><p>设$f$是从$A$到$B$的函数，对任意$x1, x2∈A$，</p><ul><li>如果$x1 ≠ x2$，有$f(x1) ≠ f(x2)$，则称$f$为从$A$到$B$的单射（不同的$x$对应不同的$y)$</li><li>如果$ranf = B$，则称$f$为从$A$到$B$的满射</li><li>若$f$是满射且是单射，则称$f$为从$A$到$B$的双射</li><li>当$A$上的函数$f$是双射时，称$f$为变换</li></ul><h4 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h4><p>设$A, B$是有限集合，且$|A| = |B|$，$f$是$A$到$B$的函数，则$f$是单射当且仅当$f$是满射。</p><h4 id="函数的运算"><a href="#函数的运算" class="headerlink" title="函数的运算"></a>函数的运算</h4><p>考虑$f: A→B，g: B→C$是两个函数，则 $fog = { &lt;x, z&gt; | x∈A{∧}z∈C{∧}(\exists   y)(y∈B{∧}&lt;x, y&gt;∈f{∧}&lt;y, z&gt;∈g)}$从$A$到$C$的函数，记为$fog: A→C$ ，称为函数$f$与$g$的复合函数。对任意$x∈A，fog(x) = g(f(x))$。</p><h4 id="定理-1"><a href="#定理-1" class="headerlink" title="定理"></a>定理</h4><p>若$f$是$A$到$B$的双射，则$f$的逆函数$f^{-1}$也是$B$到$A$的双射。</p><h3 id="第9章-图"><a href="#第9章-图" class="headerlink" title="第9章 图"></a>第9章 图</h3><h4 id="特殊图"><a href="#特殊图" class="headerlink" title="特殊图"></a>特殊图</h4><ul><li>仅由孤立结点组成的图称为<strong>零图</strong>(Null Graph)</li><li>仅含一个结点的零图称为<strong>平凡图</strong>(Trivial Graph)</li><li>含有n个结点，m条边的图，称为<strong>(n, m)图</strong></li></ul><h4 id="图的分类"><a href="#图的分类" class="headerlink" title="图的分类"></a>图的分类</h4><p>在有向图中，两结点间(包括结点自身间)若有同始点和同终点的几条边，则这几条边称为<strong>平行边</strong>，在无向图中，两结点间(包括结点自身间)若有几条边，则这几条边称为<strong>平行边</strong>。两结点a、b间相互平行的边的条数称为边(a, b)或&lt;a, b&gt;的<strong>重数</strong>(Repeated Number)。</p><ul><li>含有平行边的图称为多重图(Multigraph)</li><li>非多重图称为线图(Line Graph)；</li><li>无环的线图称为简单图(Simple Graph)</li></ul><h4 id="子图和补图"><a href="#子图和补图" class="headerlink" title="子图和补图"></a>子图和补图</h4><ul><li><p>若$V_1 =V$，$E_1$包含于 $E$，则称$G_1$是$G$的<strong>生成子图</strong>(Spanning Subgraph)</p></li><li><p>设$V_2$ 包含于$V$且$V_2$ ≠ 空集，以$V_2$为结点集，以两个端点均在$V_2$中的边的全体为边集的$G$的子图，称为$V_2$导出的$G$的子图，简称$V_2$的<strong>导出子图</strong>(Induced Subgraph)</p></li><li><p>设$G = &lt;V, E&gt;$为一个具有$n$个结点的无向简单图，如果$G$中任意两个结点间都有边相连，则称G为<strong>无向完全图</strong>(Undirected Complete Graph)，简称$G$为完全图(Complete Graph)，记为$K_n$。</p></li><li><p>设$G = &lt;V, E&gt;$为一个具有$n$个结点的有向简单图，如果$G$中任意两个结点间都有两条方向相反的有向边相连，则称$G$为<strong>有向完全图</strong>(directed Complete Graph)，在不发生误解的情况下，也记为$K_n$。    </p></li></ul><h4 id="结点的度数与握手定理"><a href="#结点的度数与握手定理" class="headerlink" title="结点的度数与握手定理"></a>结点的度数与握手定理</h4><p>对于图$G = &lt;V, E&gt;$，度数为$1$的结点称为<strong>悬挂结点</strong>(Hanging Point)，以悬挂结点为端点的边称为<strong>悬挂边</strong>(Hanging Edge)。 </p><h5 id="握手定理"><a href="#握手定理" class="headerlink" title="握手定理"></a>握手定理</h5><p>图中结点度数的总和等于边数的二倍，即设图G $= &lt;V, E&gt;$，则有<br>$$<br>\sum_{v\in V}deg(v)=2|E|<br>$$</p><h5 id="推论"><a href="#推论" class="headerlink" title="推论"></a>推论</h5><p>图中度数为奇数的结点个数为偶数。</p><h3 id="第11章-特殊图"><a href="#第11章-特殊图" class="headerlink" title="第11章 特殊图"></a>第11章 特殊图</h3><h4 id="欧拉图"><a href="#欧拉图" class="headerlink" title="欧拉图"></a>欧拉图</h4><p>设$G$是无孤立结点的图，若存在一条通路(回路)，经过图中每边一次且仅一次，则称此通路(回路)为该图的一条欧拉通路(回路)(Eulerian Entry/Circuit)。具有欧拉回路的图称为欧拉图(Eulerian Graph)。</p><p>规定：平凡图为欧拉图。<br>以上定义既适合无向图，又适合有向图。 </p><h4 id="欧拉图的判定"><a href="#欧拉图的判定" class="headerlink" title="欧拉图的判定"></a>欧拉图的判定</h4><p>定理11.2.1  无向图$G = &lt;V, E&gt;$具有一条欧拉通路，当且仅当$G$是连通的，且仅有零个或两个奇度数结点。规定：平凡图为欧拉图。以上定义既适合无向图，又适合有向图。</p><p>定理11.2.2 有向图$G$具有欧拉通路，当且仅当$G$是连通的，且除了两个结点以外，其余结点的入度等于出度，而这两个例外的结点中，一个结点的入度比出度大1，另一个结点的出度比入度大1。</p><h4 id="欧拉图的算法"><a href="#欧拉图的算法" class="headerlink" title="欧拉图的算法"></a>欧拉图的算法</h4><p>设$G = &lt;V, E&gt;，e∈E$，如果$p(G-e)＞p(G)$,称$e$为$G$的桥(Bridge)或割边(Cut edge)。</p><p>其中，$p$表示连通分量的个数。</p><ol><li>求欧拉图$G = &lt;V, E&gt;$的欧拉回路的Fleury算法：<br>任取$v_0∈V，令P_0 = v_0，i = 0$；</li><li>按下面的方法从$E-{e_1, e_2, …, e_i}$中选取$e_{i+1}$：要求：<br>$e_{i+1}$与$v_i$相关联；<br>除非无别的边可选取，否则$e_{i+1}$不应该为<br>$  G’ = G - {e_1, e_2, …, e_i}$中的桥；</li><li>将边$e_{i+1}$加入通路$P_0$中，令<br>$P_0 = v0e1v1e2…eivie_{i+1}v_{i+1}，   i = i+1$；</li><li>如果$i = |E|$，结束，否则转(2)。</li></ol><p>“<strong>一笔画问题</strong>”本质上就是一个无向图是否存在欧拉通路(回路)的问题。</p><h4 id="哈密顿图的定义"><a href="#哈密顿图的定义" class="headerlink" title="哈密顿图的定义"></a>哈密顿图的定义</h4><p>经过图中每个结点一次且仅一次的通路(回路)称为哈密顿通路(回路)(Hamiltonian Entry/circuit)。存在哈密顿回路的图称为哈密顿图(Hamiltonian Graph)。规定：平凡图为哈密顿图。以上定义既适合无向图，又适合有向图。</p><h4 id="哈密顿图的判定"><a href="#哈密顿图的判定" class="headerlink" title="哈密顿图的判定"></a>哈密顿图的判定</h4><p>定理11.3.1  设无向图$G = &lt;V, E&gt;$是哈密顿图，$V_1$是$V$的任意非空子集，则$p(G-V_1) ≤ |V_1|$</p><p>其中$p(G-V_1)$是从$G$中删除$V_1$后所得到图的连通分支数。</p><p>定理11.3.1在应用中它本身用处不大，但它的逆否命题却非常有用。我们经常利用定理11.3.1的逆否命题来判断某些图不是哈密顿图，即：若存在$V$的某个非空子集$V_1$使得 $p(G-V_1)＞|V_1|$，则$G$不是哈密顿图。 </p><p>(以下为充分条件)</p><p>定理11.3.2  设$G = &lt;V, E&gt;$是具有$n$个结点的简单无向图。如果对任意两个不相邻的结点$u, v∈V$，均有$deg(u) + deg(v) ≥ n - 1$,则$G$中存在哈密顿通路。</p><p>推论11.3.2  设$G = &lt;V, E&gt;$是具有$n$个结点的简单无向图。如果对任意两个不相邻的结点$u, v∈V$，均有$deg(u) + deg(v) ≥ n$,则$G$中存在哈密顿回路。</p><p>推论11.3.3  设$G = &lt;V, E&gt;$是具有$n$个结点的简单无向图，$n ≥ 3$。如果对任意$v∈V$，均有$deg(v) ≥ n/2$，则$G$是哈密顿图。</p><h4 id="偶图"><a href="#偶图" class="headerlink" title="偶图"></a>偶图</h4><p>定义11.4.1  若无向图$G = &lt;V, E&gt;$的结点集$V$能够划分为两个子集$V_1, V_2$，满足$V_1∩V_2 = Φ$，$且V_1∪V_2 = V$，使得$G$中任意一条边的两个端点，一个属于$V_1$，另一个属于$V_2$，则称$G$为偶图(Bipartite Graph)或二分图(Bigraph)。$V_1$和$V_2$称为互补结点子集，偶图通常记为$G=&lt;V_1, E, V_2&gt;$。</p><p>定义11.4.2  在偶图$G = &lt;V_1, E, V_2&gt;$中，若$V_1$中的每个结点与$V_2$中的每个结点都有且仅有一条边相关联，则称偶图$G$为完全偶图(Complete Bipartite Graph)或完全二分图(Complete Bigraph)，记为$K_{i, j}$，其中，$i = |V_1|，j = |V_2|$。（即第一个集合中的所有顶点都与第二个集合中的所有顶点相连）</p><p>偶图的判断</p><p>定理11.4.1  无向图$G = &lt;V, E&gt;$为偶图的充分必要条件是$G$的所有回路的长度均为偶数。</p><p>一般：我们常使用它的逆否命题来判断一个图不是偶图：无向图$G$不是偶图的充分必要条件是$G$中存在长度为奇数的回路。</p><h4 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h4><p>定义11.4.2  在偶图$G = &lt;V_1, E, V_2$&gt;中，$V_1 = {v_1, v_2, …, v_q}$，若存在$E$的子集$E’ = {(v_1, v_1’)，(v_2, v_2’)，…，(v_q, v_q’)}$，其中$v1’, v2’, …, vq’ $是$V2$中的$q$个不同的结点}，则称$G$的子图$G’ = &lt;V_1, E’, V_2&gt;$为从$V_1$到$V_2$的一个完全匹配(Complete Matching)，简称匹配。</p><p>定理11.4.2 (霍尔定理)  偶图$G = &lt;V_1, E, V_2&gt;$中存在从$V_1$到$V_2$的匹配的充分必要条件是$V_1$中任意$k$个结点至少与$V_2$中的$k$个结点相邻，$k = 1, 2, …, |V_1|$.定理11.4.2中的条件通常称为相异性条件(Diversity Condition)。</p><p>定理11.4.3  设$G = &lt;V_1,E,V_2&gt;$是一个偶图。如果满足条件<br>      （1）$V_1$中每个结点至少关联$t$条边；<br>      （2）$V_2$中每个结点至多关联$t$条边；<br>则$G$中存在从$V_1$到$V_2$的匹配。其中$t$为正整数。</p><h4 id="平面图"><a href="#平面图" class="headerlink" title="平面图"></a>平面图</h4><p>如果能把一个无向图$G$的所有结点和边画在平面上，使得任何两边除公共结点外没有其他交叉点，则称$G$为平面图(Plane Graph)，否则称$G$为非平面图(Nonplanar Graph)。</p><h4 id="欧拉公式"><a href="#欧拉公式" class="headerlink" title="欧拉公式"></a>欧拉公式</h4><ul><li>由边所包围的其内部不包含图的结点和边的区域，称为$G$的一个面(Surface)</li><li>包围该面的边所构成的回路称为这个面的边界(Bound)</li><li>面$r$的边界的长度称为该面的次数(Degree)，记为$D(r)$</li><li>区域面积有限的面称为有限面(Finite Surface)，区域面积无限的面称为无限面(Infinite Surface)</li><li>平面图有且仅有一个无限面</li></ul><p>定理11.5.1  平面图中所有面的次数之和等于边数的二倍。怎么理解？每条边会被用两次</p><p>定理11.5.2  设$G = &lt;V, E&gt;$是连通平面图，若它有$n$个结点、$m$条边和$r$个面，则有</p><p>$$<br>n – m + r = 2<br>$$</p><p>推论11.5.1  设$G$是一个$(n, m)$简单连通平面图，若$m＞1$，则有$m ≤ 3n - 6$。</p><p>一般使用逆否命题，即一个简单连通图，若不满足 $m ≤ 3n - 6$，则一定是非平面图。</p><p>推论11.5.2  设$G$是一个$(n, m)$简单连通平面图，若每个面的次数至少为$k (k ≥ 3)$，则有 $m\leq\dfrac{k}{k-2}(n-2)$</p><p>完全图$K_5$，$k_{3,3}$是非平面图。</p><h4 id="库拉托夫斯基定理"><a href="#库拉托夫斯基定理" class="headerlink" title="库拉托夫斯基定理"></a>库拉托夫斯基定理</h4><p>定理11.5.3(库拉托夫斯基定理)  一个图是平面图的充分必要条件是它的任何子图都不可能收缩为$K5$或$K3, 3$。</p><p>推论11.5.3  一个图是非平面图的充分必要条件是它存在一个能收缩为$K_5$或$K_{3, 3}$的子图。</p><p>$K_5$和$K_{3,3}$称为库拉托夫斯基图(Kuratowski Graph)。</p><h2 id="离散数学题型笔记"><a href="#离散数学题型笔记" class="headerlink" title="离散数学题型笔记"></a>离散数学题型笔记</h2><h3 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h3><h3 id="计算题"><a href="#计算题" class="headerlink" title="计算题"></a>计算题</h3><h4 id="主析取范式和主合取范式"><a href="#主析取范式和主合取范式" class="headerlink" title="主析取范式和主合取范式"></a>主析取范式和主合取范式</h4><p>进行化简。</p><p>通过添加P∧P，P∨P，来凑取。</p><p>求得一个可以推下一个。</p><p>确定是析取还是合取。</p><h3 id="证明题"><a href="#证明题" class="headerlink" title="证明题"></a>证明题</h3><h4 id="演绎推理"><a href="#演绎推理" class="headerlink" title="演绎推理"></a>演绎推理</h4><p>通过演绎推理，注意P-&gt;Q 与 P∨Q的区别。</p><p>证明符号：</p><ul><li>P：条件； </li><li>T，序号，序号，I：由→推理得到；</li><li>T，序号，序号，E：有蕴涵式可得；</li><li>P（附加前提）：附加条件；</li><li>CP：使用附加前提要用CP规则；</li><li>US：去任意量词</li><li>ES：去存在量词</li><li>UG：加任意量词</li><li>EG：加存在量词</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;(公式有点小问题，有空再修改)&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;第1章-集合论&quot;&gt;&lt;a href=&quot;#第1章-集合论&quot; class=&quot;headerlink&quot; title=&quot;第1章 集合论&quot;&gt;&lt;/a&gt;第1章 集合论&lt;/h3&gt;&lt;h4 id=&quot;空集&quot;&gt;&lt;
      
    
    </summary>
    
    
    
      <category term="Math" scheme="ronpay.xyz/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>2020嵌入式工作室招新Linux方向招新题</title>
    <link href="ronpay.xyz/2020/07/01/Linux%20Learning/"/>
    <id>ronpay.xyz/2020/07/01/Linux%20Learning/</id>
    <published>2020-07-01T14:32:54.000Z</published>
    <updated>2020-08-01T09:38:43.946Z</updated>
    
    <content type="html"><![CDATA[<p><strong>（因使用外链，部分图片挂了，有空再补）</strong></p><h2 id="第一关：初识Linux"><a href="#第一关：初识Linux" class="headerlink" title="第一关：初识Linux"></a>第一关：初识Linux</h2><h3 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h3><p>Linux是一种自由和开放源码的类UNIX操作系统。</p><p>Linux的优势在于开源，系统的源码是共享的，方便我们自行修改Linux系统，增加或修改所需要的功能，从而得到定制化的系统。服务器端的系统也常常是Linux，使用Linux作为环境，便于软件的调试。Linux 的强大的定制功能和低廉的成本，使得它在嵌入式系统得到广泛的运用。</p><p>因选修课使用过Ubuntu 16.04TLS，因此选择了VMware Workstation 安装 Ubuntu 20.04TLS。选择新版本的原因在于新的Linux版本会采用新的Linux内核。</p><p>首先在软件与更新中，更换软件源，提高下载速度。</p><p>安装chrome,vscode,typora,安装的方式看官网的步骤便可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#install chrome</span></span><br><span class="line">wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb</span><br><span class="line">sudo apt install ./google-chrome-stable_current_amd64.deb</span><br><span class="line">cat /etc/apt/sources.list.d/google-chrome.list</span><br></pre></td></tr></table></figure><p>设置网络代理</p><p>在主机的代理软件（Clash for Windows）上勾选允许LAN连接，然后在Ubuntu的网络代理中，设置手动，对所有的项，将地址设置为主机IP，端口设置为代理软件的端口，从而实现科学上网。</p><h4 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h4><p>安装必要的程序 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install gnome-tweaks</span><br><span class="line">sudo apt install chrome-gnome-shell</span><br></pre></td></tr></table></figure><p>安装gnome的chrome扩展，启用User Theme。</p><p>然后更换主题、图标、鼠标，这些东西我全都选了Mac OS的主题，顺便换了壁纸。</p><p>在gnome主题网站，下载MccainMojave-circle图标、MoMojave主题、McMojave cursors，分别解压缩复制到<code>./~/.themes</code> 和 <code>./~/.icons</code>目录，在优化中，启用相应主题、图标和鼠标。</p><p>在gnome网站上，下载Dash to dock美化dock栏。</p><p>效果如下：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/07/01/2WOjrvJglfI3zsV.png" alt="image-20200630213057555.png" title>                </div>                <div class="image-caption">image-20200630213057555.png</div>            </figure></p><h3 id="加分项"><a href="#加分项" class="headerlink" title="加分项"></a>加分项</h3><p>使用了Github+Hexo博客的搭建方式，使用了Hexo的Next主题。</p><h2 id="第二关：知识积累"><a href="#第二关：知识积累" class="headerlink" title="第二关：知识积累"></a>第二关：知识积累</h2><h3 id="Linux-常用命令"><a href="#Linux-常用命令" class="headerlink" title="Linux 常用命令"></a>Linux 常用命令</h3><ul><li>cd命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">回到上一次目录 cd -</span><br><span class="line">回到要目录 cd &#x2F;</span><br><span class="line">回到home目录 cd ~</span><br></pre></td></tr></table></figure><ul><li><p>mkdir命令</p></li><li><p>ls命令</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">所有文件 </span></span><br><span class="line">ls -a</span><br></pre></td></tr></table></figure><ul><li>mv命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">重命名 mv src dest</span><br><span class="line">移动 mv filename pathname(.&#x2F;表示当前位置，)</span><br></pre></td></tr></table></figure><ul><li>rm命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">删除文件 rm filename</span><br><span class="line">删除文件夹 rm -rf filename</span><br></pre></td></tr></table></figure><ul><li>tar命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">解压 tar -zxvf filename.tar.bz2</span><br></pre></td></tr></table></figure><ul><li>vim命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">进入&#x2F;创造文件 vim filename</span><br></pre></td></tr></table></figure><ul><li>make命令（编译）</li><li>chmod命令（更改访问权限）</li><li>Ctrl+C ，在后面讲述到，其实是通过终端向程序发出<code>SIGINT</code>信号，终止当前的进程。</li><li>ln命令（功能是为某一个文件在另外一个位置建立一个同步的链接）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln [参数][源文件或目录][目标文件或目录]</span><br></pre></td></tr></table></figure><h3 id="Ubuntu常用命令"><a href="#Ubuntu常用命令" class="headerlink" title="Ubuntu常用命令"></a>Ubuntu常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装软件 </span></span><br><span class="line">sudo apt-get install package</span><br><span class="line"><span class="comment">#更新源 </span></span><br><span class="line">sudo apt-get update</span><br><span class="line"><span class="comment">#更新已安装的包 </span></span><br><span class="line">sudo apt-get upgrade</span><br><span class="line"><span class="comment">#安装deb包的方式</span></span><br><span class="line">sudo dpkg -i [deb包]</span><br></pre></td></tr></table></figure><h3 id="GCC-安装及-编译C语言"><a href="#GCC-安装及-编译C语言" class="headerlink" title="GCC 安装及 编译C语言"></a>GCC 安装及 编译C语言</h3><h4 id="安装一般GCC的方法"><a href="#安装一般GCC的方法" class="headerlink" title="安装一般GCC的方法"></a>安装一般GCC的方法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">输入下面的命令，安装想要的 GCC 和 G++ ：</span></span><br><span class="line">sudo apt install gcc-8 g++-8 gcc-9 g++-9 gcc-10 g++-10</span><br><span class="line"><span class="meta">#</span><span class="bash">下面的命令配置每一个版本，并且设置了优先级。默认的版本是拥有最高优先级的那个，在我们的场景中是gcc-10。</span></span><br><span class="line">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-10 100 --slave /usr/bin/g++ g++ /usr/bin/g++-10 --slave /usr/bin/gcov gcov /usr/bin/gcov-10</span><br><span class="line">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 90 --slave /usr/bin/g++ g++ /usr/bin/g++-9 --slave /usr/bin/gcov gcov /usr/bin/gcov-9</span><br><span class="line">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-8 80 --slave /usr/bin/g++ g++ /usr/bin/g++-8 --slave /usr/bin/gcov gcov /usr/bin/gcov-8</span><br><span class="line"><span class="meta">#</span><span class="bash">以后，如果你想修改默认的版本，使用update-alternatives命令：</span></span><br><span class="line">sudo update-alternatives --config gcc</span><br></pre></td></tr></table></figure><h4 id="编译C语言"><a href="#编译C语言" class="headerlink" title="编译C语言"></a>编译C语言</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">编译C语言</span></span><br><span class="line"><span class="meta">#</span><span class="bash">命名为helloworld</span></span><br><span class="line">gcc -o helloworld helloworld.c </span><br><span class="line"><span class="meta">#</span><span class="bash">执行</span></span><br><span class="line">./helloworld</span><br><span class="line"><span class="meta">#</span><span class="bash">自动生成hello.o，但不会生成二进制执行文件，等待后续链接。</span></span><br><span class="line">gcc -c hello.c</span><br></pre></td></tr></table></figure><h4 id="安装特定版本的GCC的方法（编译）"><a href="#安装特定版本的GCC的方法（编译）" class="headerlink" title="安装特定版本的GCC的方法（编译）"></a>安装特定版本的GCC的方法（编译）</h4><p>（去Google上搜相应的方法，十分麻烦都要分别安装依赖项。最后找了一个英文网页，没几行命令，然后再等待几十分钟的编译就行了。）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">下载GCC源码</span></span><br><span class="line">wget https://ftpmirror.gnu.org/gcc/gcc-10.1.0/gcc-10.1.0.tar.xz</span><br><span class="line"><span class="meta">#</span><span class="bash">解压</span></span><br><span class="line">tar -zxvf gcc-10.1.0.tar.xz</span><br><span class="line"><span class="meta">#</span><span class="bash">下载依赖项</span></span><br><span class="line">cd gcc-10.1.0</span><br><span class="line">contrib/download_prerequisites</span><br><span class="line"><span class="meta">#</span><span class="bash">建立编译输出目录</span></span><br><span class="line">mkdir gcc-build</span><br><span class="line"><span class="meta">#</span><span class="bash">进入输出目录，执行命令，生成makefile文件</span></span><br><span class="line">../gcc-10.1.0/configure -v --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu --prefix=/usr/local/gcc-10.1.0 --enable-checking=release --enable-languages=c,c++,fortran --disable-multilib --program-suffix=-10.1</span><br><span class="line"><span class="meta">#</span><span class="bash">编译</span></span><br><span class="line">make -j 4</span><br><span class="line"><span class="meta">#</span><span class="bash">安装</span></span><br><span class="line">sudo make install-strip</span><br></pre></td></tr></table></figure><p>GCC-10.1编译安装效果，如下：（弄了好久也不知道怎么把它当作默认的gcc，估计安装路径有点问题）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/07/01/oEDdeA73VZR1J5n.png" alt="image-20200630213259310.png" title>                </div>                <div class="image-caption">image-20200630213259310.png</div>            </figure><h3 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h3><p><code>sudo apt-get install vim</code>安装vim.</p><h4 id="vi-vim的使用"><a href="#vi-vim的使用" class="headerlink" title="vi/vim的使用"></a>vi/vim的使用</h4><p>刚启动vi/vim时，进入命令模式，输入<code>i</code>，切换输入模式，</p><h5 id="输入模式常见命令"><a href="#输入模式常见命令" class="headerlink" title="输入模式常见命令"></a>输入模式常见命令</h5><ul><li><code>Esc</code>进入命令模式</li></ul><h5 id="底线命令模式常见命令"><a href="#底线命令模式常见命令" class="headerlink" title="底线命令模式常见命令"></a>底线命令模式常见命令</h5><ul><li><code>q</code> 退出程序</li><li><code>q!</code>强制退出不保存</li><li><code>w</code> 保存文件</li><li><code>wq</code> 保存文件并退出程序</li><li>按<code>ESC</code>键退出底线命令模式</li></ul><h4 id="一般命令模式常见命令："><a href="#一般命令模式常见命令：" class="headerlink" title="一般命令模式常见命令："></a>一般命令模式常见命令：</h4><ul><li><code>i,o,a</code>切换到输入模式，以输入字符。</li><li><code>x</code> 向后删除一个字符(del),<code>X</code> 为向前删除一个字符（backspace)</li><li><code>dd</code> 删除整行的字符。</li><li><code>:,/,?</code>切换到底线命令模式，以在最底一行输入命令。</li><li><code>gg</code> 移动到第一行</li><li><code>dG</code>删除光标所在处到最后一行所有数据</li><li><code>(n)yy</code>复制光标那一行(光标往下n行)</li><li><code>u</code>回复前一个操作</li><li><code>ctrl+</code>r重做上一个操作</li><li><code>/word</code>向下寻找word</li><li><code>?word</code>向上寻找word</li><li><code>:sp filename</code> 若打开同一个文件则无需filename。用<code>ctrl+w+</code>上 向上翻，用<code>ctrl+w+</code>下 向下翻</li><li><code>Ctrl x + ctrl n</code>关键词补全</li></ul><h4 id="vim缓存与恢复"><a href="#vim缓存与恢复" class="headerlink" title="vim缓存与恢复"></a>vim缓存与恢复</h4><p>打开不正常结束的vim时会出现缓存警告，可输入<code>o,e,r,d,q,a</code>分别表示只读open，编辑edit，加载缓存recover，删除缓存delete，停止quit，同停止abort。</p><h3 id="vim-美化与插件"><a href="#vim-美化与插件" class="headerlink" title="vim 美化与插件"></a>vim 美化与插件</h3><ol><li>下载 <a href="https://github.com/tomasr/molokai" target="_blank" rel="noopener">molokai 主题</a></li><li>将 <code>colors/molokai.vim</code> 拷贝到 <code>~/.vim/colors/</code></li><li>新建<code>~/.vimrc</code>文件，在 <code>~/.vimrc</code> 中添加：<code>colorscheme molokai</code></li></ol><p>（vim得安装很多插件才能有VSCode的intellisense、代码补全、自动格式化的功能，还不太习惯，不想折腾了，后面就用VSCode写了）</p><p><a href="https://github.com/junegunn/vim-plug" target="_blank" rel="noopener">vim-plug</a>  vim插件管理器，用于安装、管理插件。</p><p><a href="https://github.com/junegunn/vim-plug" target="_blank" rel="noopener">The NERDTree</a>  文件目录可视化的插件，使用vim-plug插件管理器安装，安装方法见vim-plug的GitHub页码。使用方式：在vim命令行形式，输入<code>NERDTree</code>。</p><p>安装教程在如上的Github页面都很详细，就不赘述了。</p><h4 id="vim编写Hello-c和BST-c"><a href="#vim编写Hello-c和BST-c" class="headerlink" title="vim编写Hello.c和BST.c"></a>vim编写Hello.c和BST.c</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/07/01/XleE59UhbJdTWzk.png" alt="image-20200627122923712.png" title>                </div>                <div class="image-caption">image-20200627122923712.png</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/07/01/sCwNdRurTEpnYH8.png" alt="image-20200628113025534.png" title>                </div>                <div class="image-caption">image-20200628113025534.png</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/07/01/PN3KLGZAfjxSnHW.png" alt="image-20200628114709524.png" title>                </div>                <div class="image-caption">image-20200628114709524.png</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/07/01/HDlcnz46kEq1iYG.png" alt="image-20200628114742290.png" title>                </div>                <div class="image-caption">image-20200628114742290.png</div>            </figure><h2 id="第三关：进阶篇"><a href="#第三关：进阶篇" class="headerlink" title="第三关：进阶篇"></a>第三关：进阶篇</h2><h3 id="基础篇-1"><a href="#基础篇-1" class="headerlink" title="基础篇"></a>基础篇</h3><h4 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h4><p>CPU是一个具有特殊功能的芯片，里面含有指令集。内分为两个主要的单元，分别为算术逻辑单元，控制单元。CPU内部含有一些微指令，而指令集的设计分成两种设计理念，分别为两种CPU架构：精简指令集，复杂指令集。我们常用的Intel、AMD所用的便是复杂指令集，基于X86架构。</p><p>CPU频率：每秒钟可以进行的工作次数。（因为指令集、架构、二级缓存及其运算机制的不同、每一此频率可以运行的指令数不同，故不能单纯使用CPU频率来比较CPU性能。</p><p>现在CPU已经没有北桥，其中的内存控制器已经被整合到CPU内部了，使得CPU可以直接与内存、显卡进行通信，提高了效率</p><p>64位、32位的说法来自CPU每次能够处理的数据量，即字长。</p><h4 id="超线程技术"><a href="#超线程技术" class="headerlink" title="超线程技术"></a>超线程技术</h4><p>为何会有这种技术？因CPU命令执行周期太短，CPU内核长时间处于空置状态，同时系统是多任务系统，因此让多个任务使用同一内核，可以提高效率。</p><p>如何实现？把每个内核中的寄存器分成两组，让程序分别使用两组寄存器，从而使得内核数加倍，同时操作系统可以检测刀两倍的内核数，从而使得每个内核逻辑上分离。</p><p>此技术在大多数情况下都可以提高效率，但是其实本质上只有一个运算单元，故性能其实没有改变。</p><h4 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h4><p>有什么用？ 是操作系统的最底层，驱动硬件，提高系统所需要的内核功能，包括防火墙、是否支持LVM等。</p><p>是什么？系统中的一个文件，包括驱动主机各个硬件的检查程序和驱动模块。</p><p>内核模块化？将一些不常见的类似于驱动程序的东西独立出内核，编译成模块。</p><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>pid：process id,进程id</p><p>tid：线程id</p><p>程序被触发，执行者的权限和属性、程序的代码与所需数据会被加载到内存中，操作系统会给予这块内存一个PID，即进程是正在运行的一个程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//获取进程pid</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pthread_t 为 long unsigned int,lu.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">//获取线程tid</span></span><br><span class="line"><span class="function"><span class="keyword">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_equal</span><span class="params">(<span class="keyword">pthread_t</span> tid1,<span class="keyword">pthread_t</span> tid2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *<span class="keyword">restrict</span> tidp,<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *<span class="keyword">restrict</span> attr,<span class="keyword">void</span> *(*start_vin)(<span class="keyword">void</span>),<span class="keyword">void</span> *<span class="keyword">restrict</span> arg)</span></span>;</span><br><span class="line"><span class="comment">//中止线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *status)</span></span>;</span><br><span class="line"><span class="comment">//等待某个线程退出</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> tid,<span class="keyword">void</span> **status)</span></span>;</span><br><span class="line"><span class="comment">//gcc 编译 -pthread不可或缺</span></span><br><span class="line">gcc -pthread filename</span><br></pre></td></tr></table></figure><p><code>pthread_create</code>用于创建一个线程，成功返回0，否则返回Exxx（为正数）。</p><ul><li><code>pthread_t *tid</code>：线程id的类型为<code>thread_t</code>，通常为无符号整型，当调用pthread_create成功时，通过*tid指针返回。</li><li><code>const pthread_attr_t *attr</code>：指定创建线程的属性，如线程优先级、初始栈大小、是否为守护进程等。可以使用NULL来使用默认值，通常情况下我们都是使用默认值。</li><li><code>void *(*func) (void *)</code>：函数指针func，指定当新的线程创建之后，将执行的函数。</li><li><code>void *arg</code>：线程将执行的函数的参数。如果想传递多个参数，请将它们封装在一个结构体中。</li></ul><p><code>pthread_join</code>用于等待某个线程退出，成功返回0，否则返回Exxx（为正数）。</p><ul><li><code>pthread_t tid</code>：指定要等待的线程ID</li><li><code>void ** status</code>：如果不为NULL，那么线程的返回值存储在status指向的空间中（这就是为什么status是二级指针的原因！这种才参数也称为“值-结果”参数）。</li></ul><p><code>pthread_self</code>用于返回当前线程的ID。</p><p><code>pthread_detach</code>用于是指定线程变为<strong>分离</strong>状态，就像进程脱离终端而变为后台进程类似。成功返回0，否则返回Exxx（为正数）。变为分离状态的线程，如果线程退出，它的所有资源将全部释放。而如果不是分离状态，线程必须保留它的线程ID，退出状态直到其它线程对它调用了<code>pthread_join</code>。</p><p><code>pthread_exit</code>用于终止线程，可以指定返回值，以便其他线程通过<code>pthread_join</code>函数获取该线程的返回值。</p><ul><li><code>void *status</code>：指针线程终止的返回值。</li></ul><h4 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h4><p>线程是比进程更小的单位，进程由多个线程组成。</p><p>进程有独立的地址空间，线程没有独立的地址空间。</p><h4 id="尝试一个简单的多线程打印"><a href="#尝试一个简单的多线程打印" class="headerlink" title="尝试一个简单的多线程打印"></a>尝试一个简单的多线程打印</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;//pthread开头的函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;//sleep()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread1</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread2</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"enter main\n"</span>);</span><br><span class="line"><span class="keyword">pthread_t</span> tid1,tid2;</span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">pthread_create(&amp;tid1,<span class="literal">NULL</span>,thread1,<span class="literal">NULL</span>);</span><br><span class="line">pthread_create(&amp;tid2,<span class="literal">NULL</span>,thread2,<span class="literal">NULL</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"leave main\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线程1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread1</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"enter thread1\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"thread1 id is %lu"</span>,pthread_self());</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"leave thread1\n"</span>);</span><br><span class="line">pthread_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread2</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"enter thread2\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"thread2 id is %lu"</span>,pthread_self());</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"leave thread2\n"</span>);</span><br><span class="line">pthread_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行截图如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/07/01/lgkD8wjNquHRm53.png" alt="image-20200630214750801.png" title>                </div>                <div class="image-caption">image-20200630214750801.png</div>            </figure><h4 id="双线程打印ABABABAB（使用互斥锁与条件变量）"><a href="#双线程打印ABABABAB（使用互斥锁与条件变量）" class="headerlink" title="双线程打印ABABABAB（使用互斥锁与条件变量）"></a>双线程打印ABABABAB（使用互斥锁与条件变量）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COUNT 20</span></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//互斥锁宏初始化</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex=PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="comment">//条件变量宏初始化</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> even=PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> uneven=PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程1函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread1</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=COUNT)&#123;</span><br><span class="line">pthread_mutex_lock(&amp;mutex);<span class="comment">//上锁</span></span><br><span class="line"><span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"thread1:A\n"</span>);</span><br><span class="line">i++;</span><br><span class="line">pthread_cond_signal(&amp;uneven);<span class="comment">//发出信号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">pthread_cond_wait(&amp;even,&amp;mutex);<span class="comment">//等待信号</span></span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);<span class="comment">//解锁</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//除条件变量略有不同，其它类似</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread2</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=COUNT)&#123;</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"thread2:B\n"</span>);</span><br><span class="line">i++;</span><br><span class="line">pthread_cond_signal(&amp;even);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">pthread_cond_wait(&amp;uneven,&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> tid1,tid2;</span><br><span class="line">pthread_create(&amp;tid1,<span class="literal">NULL</span>,thread1,<span class="literal">NULL</span>);</span><br><span class="line">pthread_create(&amp;tid2,<span class="literal">NULL</span>,thread2,<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//等待进程退出</span></span><br><span class="line">pthread_join(tid1,<span class="literal">NULL</span>);</span><br><span class="line">pthread_join(tid2,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行截图如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/07/01/SrAv86TecqYdwh9.png" alt="image-20200630214836749.png" title>                </div>                <div class="image-caption">image-20200630214836749.png</div>            </figure><h4 id="内核的模块化设计"><a href="#内核的模块化设计" class="headerlink" title="内核的模块化设计"></a>内核的模块化设计</h4><p>用处？因为Linux内核庞大复杂，内核编译是很麻烦的事情，因此Linux使用模块化设计，将不常用的东西独立出内核，编译成模块。从而使得，在系统运行中，内核可以加载模块。最终提高了扩展性，功能的灵活性。</p><p>意思？模块化设计意思为内核中各个功能模块在代码上彼此独立的，没有变量、函数的相互调用。</p><h4 id="插入模块创建内核线程，打印Hello，World"><a href="#插入模块创建内核线程，打印Hello，World" class="headerlink" title="插入模块创建内核线程，打印Hello，World"></a>插入模块创建内核线程，打印Hello，World</h4><p>helloWorld.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;//printk()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="comment">//使用了linux/init.h中定义的宏init和exit</span></span><br><span class="line"><span class="comment">//内核中打印函数为printk，</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">init_my_module</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">"Hello, World!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">exit_my_module</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">"Bye, World!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//内核加载时执行</span></span><br><span class="line">module_init(init_my_module);</span><br><span class="line"><span class="comment">//内核卸载时执行</span></span><br><span class="line">module_exit(exit_my_module);</span><br></pre></td></tr></table></figure><p>Makefile文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#编译生成可加载模块，即将helloWorld.c编译成hello.ko</span></span><br><span class="line">obj-m += helloWorld.o</span><br><span class="line"><span class="section">all:</span></span><br><span class="line"><span class="comment">#-C 指定内核源码位置，/lib/modules/$(shell uname -r)/build</span></span><br><span class="line"><span class="comment">#M= 指定需要编译的内核源文件地址 [target]:modules(可选)</span></span><br><span class="line">make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ lsmod <span class="comment">#现实所有内核模块</span></span><br><span class="line">$ make</span><br><span class="line">$ sudo insmod helloWorld.ko<span class="comment">#运行内核模块</span></span><br><span class="line">$ dmesg <span class="comment">#查询/var/log/messages，查看打印的信息</span></span><br><span class="line">$ sudo rmmod helloWorld.ko<span class="comment">#卸载模块</span></span><br></pre></td></tr></table></figure><p>运行截图如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/07/01/FHygb1XSpIRxwde.png" alt="image-20200630215108549.png" title>                </div>                <div class="image-caption">image-20200630215108549.png</div>            </figure><h3 id="加分项-1"><a href="#加分项-1" class="headerlink" title="加分项"></a>加分项</h3><h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>在变量修改时间多于一个存储器访问周期的情况下，存储器读写周期会交叉，出现变量不一致的情况。</p><p>为了解决线程同步的问题，所以线程需要使用锁，同一时间只允许一个线程访问变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></span><br><span class="line"><span class="comment">//宏初始化（适用于静态分配的互斥量）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="comment">//操作先加锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> * mptr)</span></span>; </span><br><span class="line"><span class="comment">//操作后解锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> * mptr)</span></span>;</span><br></pre></td></tr></table></figure><p>互斥锁可以让线程按照顺序执行，从而使得一次只执行一次代码。</p><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>如果线程尝试对同一个互斥量加锁两次，本身就会进入死锁状态。</p><p>若两个分别占有一个互斥量的线程，试图锁住对方的互斥量是，就会进入死锁状态。</p><h5 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h5><p>互斥锁总是与条件变量一起使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">//宏初始化</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"> <span class="comment">//等待唤醒</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cptr, <span class="keyword">pthread_mutex_t</span> *mptr)</span></span>; </span><br><span class="line"><span class="comment">//通知</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cptr)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="标准IO与重定向符号的使用"><a href="#标准IO与重定向符号的使用" class="headerlink" title="标准IO与重定向符号的使用"></a>标准IO与重定向符号的使用</h4><p>标准输入、标准输出、标准错误分别为stdin,stdout,stderr。在默认情况下，标准输出和标准输入都是终端。stdin的文件描述符为0，stdout的文件描述符为1，stderrr的文件描述符为2。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">将stdout重定向到file,若追加在file后，运算符为 &gt;&gt;</span></span><br><span class="line">command &gt; file</span><br><span class="line"><span class="meta">#</span><span class="bash">将stderr重定向到file,2为文件描述符。</span></span><br><span class="line">command 2 &gt; file</span><br><span class="line"><span class="meta">#</span><span class="bash">将stdin重定向到file</span></span><br><span class="line">command &lt; file</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">例 输出hello, Linux!的可执行文件</span></span><br><span class="line">.\hello &gt; hello.txt</span><br><span class="line">cat  hello.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">输出</span></span><br><span class="line">hello, Linux!</span><br><span class="line"><span class="meta">#</span><span class="bash">例 比较大小输出最大值的可执行文件 input.txt: 3 5</span></span><br><span class="line">.\fmax &lt; input.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">输出</span></span><br><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="第四关：BOSS"><a href="#第四关：BOSS" class="headerlink" title="第四关：BOSS"></a>第四关：BOSS</h2><h3 id="基础篇-2"><a href="#基础篇-2" class="headerlink" title="基础篇"></a>基础篇</h3><p>信号是一种软中断，信号体制是进程间通信的一种方式，采用异步通信机制。原理是上，一个进程收到信号类似于处理器收到中断请求，故它是在软件层次上对中断机制的一种模拟。</p><p>信号在<code>signal.h</code>头文件中被定义，通过<code>kill -l</code>可以查看编号和信号名的映射关系。对于信号，通常有三种处理方式：忽略；默认动作；捕捉信号。</p><p><code>SIG_IGN,SIG_</code>分别表示忽略某一信号；按默认动作处理。</p><p>一般信号触发可分为几类：在终端通过组合按键触发，然后发送给前台，如<code>Ctrl+C</code>发送<code>SIGINT</code>信号；硬件异常产生信号，通知内核然后发送给进程信号；通过软件层面，如<code>kill(),raise()</code>等函数，或检测到某种软件条件发生产生信号。</p><p><code>signal()</code>函数用于对进程中某个特定信号（signum）注册一个对应的处理函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*<span class="keyword">sighandle_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;<span class="comment">//sighandle_t被定义为指向void()(int)函数类型的指针</span></span><br><span class="line"><span class="function"><span class="keyword">sighandle_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum,<span class="keyword">sighandler_t</span> handler)</span></span>;</span><br></pre></td></tr></table></figure><p><code>kill(),raise()</code>前者用来给指定进程发送信号，后者用来给当前进程发送信号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> signo)</span></span>;</span><br><span class="line">int raise(int signo)；</span><br><span class="line"><span class="comment">//kill(getpid(),signo) equals raise(signo)</span></span><br></pre></td></tr></table></figure><p><code>pause()</code>用来挂起进程，直到信号触发。针对不同的处理行为，表现不同，<code>pause</code>返回不同。若终止进程，则没有返回；若忽略，进程保持挂起状态，没有返回；若有信号处理函数，则调用该函数，返回<code>-1</code>。</p><h3 id="加分项-2"><a href="#加分项-2" class="headerlink" title="加分项"></a>加分项</h3><h4 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h4><p>中断被定义为一种事件，该事件改变处理器执行的指令顺序。中断通常分为同步中断（异常）和异步中断（中断）。同步中断是由CPU产生的，只有在一条指令中止执行后CPU才会产生中断。异步中断是由其它硬件设备依照CPU时钟信号随机产生的。</p><p>在嵌入式中，中断很重要，在几乎所有芯片中都有中断功能。每个外接设备申请一个唯一的中断号，让外设发生中断时，向CPU报告自己的中断号，CPU知道是哪个设备发生中断，然后执行相对应的操作。</p><p>如何处理？发生中断后，CPU暂停执行当前的程序，处理中断，因为中断执行后要恢复之前的额代码，故进入中断后CPU还要保护源程序断点信息，然后从中断控制器中取出中断向量，转到相应的处理程序，对中断进行处理，中断处理完成后返回，继续执行当前的程序。</p><p>好处？提高CPU的利用率，使CPU及时处理各种软硬件故障。若没有中断，CPU需要对设备进行循环的访问，才能得到设备的状态。中断则使得硬件如要与CPU联系，便向CPU发出中断请求信号，从而使得CPU停止当前程序的执行，处理硬件发出的请求。</p><p><strong>中断向量</strong>是中断服务程序的入口地址，即指向中断服务程序的指针。系统维护一份中断向量表，中断向量是其中的元素。当异常产生时，硬件产生一个中断标记，CPU根据中断标记获得相应的中断向量号，在由CPU根据中断向量表的地址和中断向量号去查找中断向量表获得相应中断号的中断程序地址，进一步执行对应的中断处理程序。</p><h4 id="RTC中断程序"><a href="#RTC中断程序" class="headerlink" title="RTC中断程序"></a>RTC中断程序</h4><p>rtc_alarm.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/rtc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;//ioctl()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;//struct rtc_time</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;//perror()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;//exit()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, fd, retval, irqcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> tmp, data;</span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtc_time</span> <span class="title">rtc_tm</span>;</span></span><br><span class="line">    <span class="comment">//打开rtc</span></span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"/dev/rtc"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">"/dev/rtc"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(errno);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//读取RTC</span></span><br><span class="line">    retval = ioctl(fd, RTC_RD_TIME, &amp;rtc_tm);</span><br><span class="line">    <span class="keyword">if</span>(retval==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">"ioctl"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(errno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印当前时间</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Current RTC data/time is %d-%d-%d,%02d:%02d:%02d.\n"</span>,</span><br><span class="line">    rtc_tm.tm_mday, rtc_tm.tm_mon + <span class="number">1</span>, rtc_tm.tm_year + <span class="number">1900</span>,rtc_tm.tm_hour, rtc_tm.tm_min, rtc_tm.tm_sec);</span><br><span class="line">    <span class="comment">//设置10min alarm</span></span><br><span class="line">    rtc_tm.tm_min += <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span>(rtc_tm.tm_sec&gt;=<span class="number">60</span>)&#123;</span><br><span class="line">        rtc_tm.tm_sec %= <span class="number">60</span>;</span><br><span class="line">        rtc_tm.tm_min++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(rtc_tm.tm_min&gt;=<span class="number">60</span>)&#123;</span><br><span class="line">        rtc_tm.tm_min %= <span class="number">60</span>;</span><br><span class="line">        rtc_tm.tm_hour++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(rtc_tm.tm_hour==<span class="number">24</span>)&#123;</span><br><span class="line">        rtc_tm.tm_hour = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置 alarm</span></span><br><span class="line">    retval = ioctl(fd, RTC_ALM_SET, &amp;rtc_tm);</span><br><span class="line">    <span class="keyword">if</span>(retval==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">"ioctl"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(errno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Alarm time now set to %02d:%02d:%02d.\n"</span>,rtc_tm.tm_hour, rtc_tm.tm_min, rtc_tm.tm_sec);</span><br><span class="line"><span class="comment">//启用 alarm</span></span><br><span class="line">    retval = ioctl(fd, RTC_AIE_ON, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(retval==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">"iotle"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(errno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用read()，因rtc不能被两个线程调用，故阻塞直到alarm，从而实现闹钟功能。</span></span><br><span class="line">    retval = <span class="built_in">read</span>(fd, &amp;data, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>));</span><br><span class="line">    <span class="keyword">if</span>(retval==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">"read"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(errno);</span><br><span class="line">    &#125;</span><br><span class="line">    irqcount++;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"okay.Alarm rang.\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行截图如下：（因10min的alarm太久了，故将<code>rtc_tm.tm_min += 10;</code>改为<code>rtc_tm.tm_min += 1;</code>，设置1min的alarm）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/07/01/oZPIyYl1fW32Bwd.png" alt="image-20200630220826329.png" title>                </div>                <div class="image-caption">image-20200630220826329.png</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;（因使用外链，部分图片挂了，有空再补）&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;第一关：初识Linux&quot;&gt;&lt;a href=&quot;#第一关：初识Linux&quot; class=&quot;headerlink&quot; title=&quot;第一关：初识Linux&quot;&gt;&lt;/a&gt;第一关：初识Lin
      
    
    </summary>
    
    
    
      <category term="Linux" scheme="ronpay.xyz/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Git 笔记</title>
    <link href="ronpay.xyz/2020/07/01/Git-%E7%AC%94%E8%AE%B0/"/>
    <id>ronpay.xyz/2020/07/01/Git-%E7%AC%94%E8%AE%B0/</id>
    <published>2020-07-01T14:31:36.000Z</published>
    <updated>2020-07-01T14:32:09.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git笔记"><a href="#Git笔记" class="headerlink" title="Git笔记"></a>Git笔记</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">该命令执行完后会在当前目录生成一个 .git 目录。</span></span><br><span class="line">git init</span><br><span class="line"><span class="meta">#</span><span class="bash">初始化后，会在 newrepo 目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。</span></span><br><span class="line">git init newrepo</span><br><span class="line"><span class="meta">#</span><span class="bash">如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add *.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add README</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">'初始化项目版本'</span></span></span><br></pre></td></tr></table></figure><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">克隆仓库的命令格式为：</span></span><br><span class="line">git clone &lt;repo&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash">如果我们需要克隆到指定的目录，可以使用以下命令格式：</span></span><br><span class="line">git clone &lt;repo&gt; &lt;directory&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash">比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> git://github.com/schacon/grit.git</span></span><br><span class="line"><span class="meta">#</span><span class="bash">如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> git://github.com/schacon/grit.git mygrit</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Git笔记&quot;&gt;&lt;a href=&quot;#Git笔记&quot; class=&quot;headerlink&quot; title=&quot;Git笔记&quot;&gt;&lt;/a&gt;Git笔记&lt;/h1&gt;&lt;h2 id=&quot;基本操作&quot;&gt;&lt;a href=&quot;#基本操作&quot; class=&quot;headerlink&quot; title=&quot;基本操作&quot;
      
    
    </summary>
    
    
    
      <category term="Git" scheme="ronpay.xyz/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Github+Hexo 博客搭建</title>
    <link href="ronpay.xyz/2020/07/01/Github-Hexo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>ronpay.xyz/2020/07/01/Github-Hexo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</id>
    <published>2020-07-01T14:28:50.000Z</published>
    <updated>2020-07-01T14:31:45.726Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Github-Hexo-博客搭建"><a href="#Github-Hexo-博客搭建" class="headerlink" title="Github+Hexo 博客搭建"></a>Github+Hexo 博客搭建</h1><h2 id="必要组件"><a href="#必要组件" class="headerlink" title="必要组件"></a>必要组件</h2><p>安装Node.js，添加国内源<code>npm config set registry https://registry.npm.taobao.org</code></p><p>安装Git，并加入命令提示符</p><h2 id="Github操作"><a href="#Github操作" class="headerlink" title="Github操作"></a>Github操作</h2><p>新建repo，名为：”name.github.io”，并初始化README</p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>右键  <code>Git Bash Here</code>，打开git控制台窗口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装Hexo</span></span><br><span class="line">npm i hexo-cli -g</span><br><span class="line"><span class="meta">#</span><span class="bash">初始化文件夹</span></span><br><span class="line">hexo init</span><br><span class="line"><span class="meta">#</span><span class="bash">安装必要组件</span></span><br><span class="line">npm install</span><br><span class="line"><span class="meta">#</span><span class="bash">生成静态网页</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="meta">#</span><span class="bash">打开本地服务器，在localhost:4000/中预览</span></span><br><span class="line">hexo s</span><br><span class="line"><span class="meta">#</span><span class="bash">关闭本地服务器</span></span><br><span class="line">ctrl+c</span><br></pre></td></tr></table></figure><h2 id="连接Github与本地"><a href="#连接Github与本地" class="headerlink" title="连接Github与本地"></a>连接Github与本地</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">在git控制台窗口</span></span><br><span class="line">git config --global user.name "yourname"</span><br><span class="line">git config --global user.email "youremail"</span><br><span class="line"><span class="meta">#</span><span class="bash">生成密匙SSH key</span></span><br><span class="line">ssh-keygen -t rsa -C "youremail"</span><br><span class="line"><span class="meta">#</span><span class="bash">输入</span></span><br><span class="line">cat ~/.ssh/id_rsa.pub</span><br><span class="line"><span class="meta">#</span><span class="bash">将输出的文件保存在下方的SSH中</span></span><br><span class="line"><span class="meta">#</span><span class="bash">输入</span></span><br><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>打开<a href="https://link.zhihu.com/?target=http%3A//github.com/">github</a>，在头像下面点击<code>settings</code>，再点击<code>SSH and GPG keys</code>，新建一个SSH，名字随便。</p><p>打开博客根目录下的<code>_config.yml</code>文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。</p><p>修改最后一行的配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: https://github.com/yourname/yourname.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h2 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装拓展</span></span><br><span class="line">npm i hexo-deployer-git</span><br><span class="line"><span class="meta">#</span><span class="bash">新建一篇文章</span></span><br><span class="line">hexo new post "article title"</span><br><span class="line"><span class="meta">#</span><span class="bash">生成静态网页</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="meta">#</span><span class="bash">本地浏览</span></span><br><span class="line">hexo s</span><br><span class="line"><span class="meta">#</span><span class="bash">上传到github</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Github-Hexo-博客搭建&quot;&gt;&lt;a href=&quot;#Github-Hexo-博客搭建&quot; class=&quot;headerlink&quot; title=&quot;Github+Hexo 博客搭建&quot;&gt;&lt;/a&gt;Github+Hexo 博客搭建&lt;/h1&gt;&lt;h2 id=&quot;必要组件&quot;&gt;&lt;a 
      
    
    </summary>
    
    
    
      <category term="Hexo" scheme="ronpay.xyz/tags/Hexo/"/>
    
  </entry>
  
</feed>
