<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ronpay&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/21c9991fac13636f56078f411ee9fd11</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="ronpay.xyz/"/>
  <updated>2020-08-01T09:26:23.534Z</updated>
  <id>ronpay.xyz/</id>
  
  <author>
    <name>Ronpay</name>
    <email>365296@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微积分II笔记</title>
    <link href="ronpay.xyz/2020/08/01/%E5%BE%AE%E7%A7%AF%E5%88%86II%E7%AC%94%E8%AE%B0/"/>
    <id>ronpay.xyz/2020/08/01/%E5%BE%AE%E7%A7%AF%E5%88%86II%E7%AC%94%E8%AE%B0/</id>
    <published>2020-08-01T09:13:45.000Z</published>
    <updated>2020-08-01T09:26:23.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微积分II笔记"><a href="#微积分II笔记" class="headerlink" title="微积分II笔记"></a>微积分II笔记</h1><p><strong>(版权所有  禁止转载)</strong></p><p><strong>(版权所有  禁止转载)</strong></p><p><strong>(版权所有  禁止转载)</strong></p><h2 id="重要知识"><a href="#重要知识" class="headerlink" title="重要知识"></a>重要知识</h2><h4 id="积化和差"><a href="#积化和差" class="headerlink" title="积化和差"></a>积化和差</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/.xyz/2020/08//Users\Hong\Documents\Markdown\图片\积化和差.svg" alt title>                </div>                <div class="image-caption"></div>            </figure><p><strong>正余余正，正加正减；</strong></p><p><strong>余余正正，余加负余减。</strong></p><h4 id="和差化积"><a href="#和差化积" class="headerlink" title="和差化积"></a>和差化积</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/.xyz/2020/08//Users\Hong\Documents\Markdown\图片\和差化积.svg" alt title>                </div>                <div class="image-caption"></div>            </figure><p><strong>正加正，正在前；</strong></p><p><strong>正减正，余在前；</strong></p><p><strong>余加余，余并肩；</strong></p><p><strong>余减余，负正弦。</strong></p><h4 id="海伦公式"><a href="#海伦公式" class="headerlink" title="海伦公式"></a>海伦公式</h4><p>$S=\sqrt{p(p-a)(p-b)(p-c)}$</p><p>其中，$p=\dfrac{a+b+c}{2}$。</p><h3 id="微积分知识"><a href="#微积分知识" class="headerlink" title="微积分知识"></a>微积分知识</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/.xyz/2020/08//Users\Hong\Documents\Markdown\图片\clip_image001.png" alt="Image result for 求导公式" title>                </div>                <div class="image-caption">Image result for 求导公式</div>            </figure><p>$n$为奇数时：$\int^\frac{\pi}{2}_0{sin^nx}=\frac{1}{2}\times\frac{3}{4}\times…\times\frac{n-1}{n}$</p><p>$n$为偶数时：$\int^\frac{\pi}{2}_0{sin^nx}=\frac{1}{2}\times\frac{3}{4}\times…\times\frac{n-1}{n}\times\frac{\pi}{2}$</p><p>$\int^\frac{\pi}{2}_0{sinx}$=$\int^\frac{\pi}{2}_0{cosx}$</p><h3 id="常微分方程"><a href="#常微分方程" class="headerlink" title="常微分方程"></a>常微分方程</h3><h4 id="一阶微分方程"><a href="#一阶微分方程" class="headerlink" title="一阶微分方程"></a>一阶微分方程</h4><h5 id="可分离变量的方程"><a href="#可分离变量的方程" class="headerlink" title="可分离变量的方程"></a>可分离变量的方程</h5><p>形如<br>$$<br>\dfrac{dy}{dx}=f(x)g(y)<br>$$<br>的方程，可将方程改写为$\dfrac{dy}{g(y)}=f(x)dx$，再对两端积分即可，略。</p><h5 id="齐次方程"><a href="#齐次方程" class="headerlink" title="齐次方程"></a>齐次方程</h5><p>如方程可变为形如<br>$$<br>\dfrac{dy}{dx}=\varphi(\dfrac{y}{x})<br>$$<br>得方程，则可引入函数$u=\dfrac{y}{x}$，即$y=xu$，有$\dfrac{dy}{dx}=u+x\frac{du}{dx}$，带入方程得到$u+x\dfrac{du}{dx}=\varphi(u)$，再分离变量得$\dfrac{du}{\varphi(u)-u}=\dfrac{dx}{x}$,再对两端积分即可，略。</p><h5 id="一阶线性方程"><a href="#一阶线性方程" class="headerlink" title="一阶线性方程"></a>一阶线性方程</h5><p>可变为形如<br>$$<br>\dfrac{dy}{dx}+P(x)y=Q(x)<br>$$<br>的方程，如果$Q(x)\equiv0$，称为一阶齐次线性微分方程；如果$Q(x)\not\equiv0$，称为一阶非齐次线性微分方程。</p><p>对于，一阶齐次线性方程，可用可分离变量的方程求解，略。</p><p>下面求一阶非齐次线性方程的通解：(常数变易法)</p><p>通解为<br>$$<br>y=e^{-\int{P(x)dx}}[\int Q(x)e^{\int{P(x)}dx}dx+C]<br>$$</p><h5 id="伯努利方程"><a href="#伯努利方程" class="headerlink" title="伯努利方程"></a>伯努利方程</h5><p>形如<br>$$<br>\frac{dy}{dx}+P(x)y=Q(x)y^n(n\not=0,1)<br>$$<br>的方程称为伯努利方程，可通过变换$z=y^{1-n}$转化为一阶线性微分方程，令$z=y^{1-n}$，则$\frac{dz}{dx}=(1-n)y^{-n}\dfrac{dy}{dx}$,即$y^{-n}\dfrac{dy}{dx}=\dfrac{1}{1-n}\dfrac{dz}{dx}$。以$y^n$除以方程两端，得$y^{-n}\dfrac{dy}{dx}+P(x)y^{1-n}=Q(x)$,将上面所求的关系式带入，得$\dfrac{dz}{dx}+(1-n)P(x)z=(1-n)Q(x)$,然后按照一阶线性微分方程得方法求解。</p><h4 id="可降阶的高阶微分方程"><a href="#可降阶的高阶微分方程" class="headerlink" title="可降阶的高阶微分方程"></a>可降阶的高阶微分方程</h4><p>$y^{(n)}=f(x)$型</p><p>连续积分即可。</p><p>$y’’=f(x,y’)$型</p><p>令$p=y’$，然后用一阶微分方程的方法，解出$p$，然后再计算即可。</p><p>$y’’=f(y,y’)$型</p><p>令$p=y’$，然后再将$y’’$化为$p$对$y$的导数，然后用一阶微分方程的方法，解出$p$，然后再计算即可。</p><h4 id="二阶齐次线性方程"><a href="#二阶齐次线性方程" class="headerlink" title="二阶齐次线性方程"></a>二阶齐次线性方程</h4><p>一般形式：<br>$$<br>\dfrac{d^2y}{dx}+P(x)\dfrac{dy}{dx}+Q(x)y=0<br>$$<br>二阶常系数齐次线性方程的解法：</p><p>令$P(x)\equiv p，Q(x)\equiv q$，则其对应的特征方程为：$r^2+pr+q=0$，$r_1,r_2$为特征方程的根，则</p><table><thead><tr><th align="center">特征方程的根</th><th align="center">微分方程的通解</th></tr></thead><tbody><tr><td align="center">两个不等实根$r_1，r_2$</td><td align="center">$y=C_1e^{r_1x}+C_2e^{r_2x}$</td></tr><tr><td align="center">两个相等实根$r_1=r_2$</td><td align="center">$y=(C_1+C_2x)e^{r_1x}$</td></tr><tr><td align="center">一对共轭复根$r_{1,2}=\alpha \pm i\beta$</td><td align="center">$y=e^{\alpha x}(C_1cos{\beta x}+C_2sin\beta x)$</td></tr></tbody></table><h4 id="二阶非齐次线性方程"><a href="#二阶非齐次线性方程" class="headerlink" title="二阶非齐次线性方程"></a>二阶非齐次线性方程</h4><h2 id="第五章-多元函数微分学"><a href="#第五章-多元函数微分学" class="headerlink" title="第五章 多元函数微分学"></a>第五章 多元函数微分学</h2><h3 id="5-1多元函数"><a href="#5-1多元函数" class="headerlink" title="5.1多元函数"></a>5.1多元函数</h3><p>二元函数二重极限是否存在</p><h3 id="5-2偏导数"><a href="#5-2偏导数" class="headerlink" title="5.2偏导数"></a>5.2偏导数</h3><p>偏导数的概念</p><p>在多元函数中，即使$f$在某点对某个变量的偏导数都存在，也不能由此断定$f$在该点连续，甚至不能断定$f$在该点存在极限。</p><h3 id="5-3全微分及其应用"><a href="#5-3全微分及其应用" class="headerlink" title="5.3全微分及其应用"></a>5.3全微分及其应用</h3><p>判断是否可全微分<br>定理：<br>若在点可微，则偏导数必存在，函数必连续。<br>若偏导数在领域存在，且在点连续，则点可微。</p><h3 id="5-4多元复合函数的求导法则"><a href="#5-4多元复合函数的求导法则" class="headerlink" title="5.4多元复合函数的求导法则"></a>5.4多元复合函数的求导法则</h3><h3 id="5-5隐函数求导法"><a href="#5-5隐函数求导法" class="headerlink" title="5.5隐函数求导法"></a>5.5隐函数求导法</h3><h4 id="一个函数的情形"><a href="#一个函数的情形" class="headerlink" title="一个函数的情形"></a>一个函数的情形</h4><p>$$ F_y(x_0,y_0)=0; $$</p><h4 id="方程组的情形"><a href="#方程组的情形" class="headerlink" title="方程组的情形"></a>方程组的情形</h4><p> 推导<br> 记忆方程组的情形的公式</p><h3 id="5-6偏导数在几何上的应用"><a href="#5-6偏导数在几何上的应用" class="headerlink" title="5.6偏导数在几何上的应用"></a>5.6偏导数在几何上的应用</h3><h4 id="空间曲线的切线和法平面"><a href="#空间曲线的切线和法平面" class="headerlink" title="空间曲线的切线和法平面"></a>空间曲线的切线和法平面</h4><h5 id="由参数方程表示的情况"><a href="#由参数方程表示的情况" class="headerlink" title="由参数方程表示的情况"></a>由参数方程表示的情况</h5><p>切向量$\vec{s}=[x’(t_0),y’(t_0),z’(t_0)]$</p><p>在$M_0(x_0,y_0,z_0)$处</p><p>切线：$\dfrac{x-x_0}{x’(t_0)}=\dfrac{y-y_0}{y’(t_0)}=\dfrac{z-z_0}{z’(t_0)}$</p><p>法平面：$x’(t_0)(x-x_0)+y’(t_0)(y-y_0)+z’(t_0)(z-z_0)=0$</p><h5 id="由两个曲面的交线表现的情况"><a href="#由两个曲面的交线表现的情况" class="headerlink" title="由两个曲面的交线表现的情况"></a>由两个曲面的交线表现的情况</h5><p>设空间曲面L的一般方程为$F(x,y,z)=0,G(x,y,z)=0$，则</p><p>切向量：$\vec{s}=(1,y’(x),z’(x))|_{M_0}$</p><p>其中，方程组对$x$求导，得到$y’(x),z’(x)$</p><h4 id="空间曲面的切平面和法线"><a href="#空间曲面的切平面和法线" class="headerlink" title="空间曲面的切平面和法线"></a>空间曲面的切平面和法线</h4><h5 id="由隐式给出的情况"><a href="#由隐式给出的情况" class="headerlink" title="由隐式给出的情况"></a>由隐式给出的情况</h5><p>曲线$S:F(x,y,z)=0$在$M_0(x_0,y_0,z_0)$处的</p><p>切平面：$F_x(M_0)(x-x_0)+F_y(M_0)(y-y_0)+F_z(M_0)(z-z_0)=0$</p><p>法直线：$\dfrac{x-x_0}{F_x(M_0)}=\dfrac{y-y_0}{F_y(M_0)}=\dfrac{z-z_0}{F_z(M_0)}$</p><h5 id="由显式给出的情况"><a href="#由显式给出的情况" class="headerlink" title="由显式给出的情况"></a>由显式给出的情况</h5><p>曲线$z=f(x,y)$</p><p>令$F(x,y,z)=f(x,y)-z$，则</p><p>法向量：$\vec{n}=(f_x(x,y),f_y(x,y),-1)$</p><h3 id="5-7方向导数与梯度"><a href="#5-7方向导数与梯度" class="headerlink" title="5.7方向导数与梯度"></a>5.7方向导数与梯度</h3><p>如果函数$z=f(x,y)$在点$P(x,y)$可全微分，则函数在点$P$沿任意方向$l$的方向导数都存在，且有</p><p>$$<br>\dfrac{\partial f}{\partial l}=\dfrac{\partial f}{\partial x}cos\alpha+\dfrac{\partial f}{\partial y}cos\beta<br>$$</p><p>其中$cos\alpha,cos\beta$为$l$的方向余弦<br>梯度<br>$$<br>gradf=\dfrac{\partial f}{\partial x}i+\dfrac{\partial f}{\partial y}j<br>$$</p><h3 id="5-8二次函数的泰勒公式"><a href="#5-8二次函数的泰勒公式" class="headerlink" title="5.8二次函数的泰勒公式"></a>5.8二次函数的泰勒公式</h3><p>略</p><h3 id="5-9多元函数的极值"><a href="#5-9多元函数的极值" class="headerlink" title="5.9多元函数的极值"></a>5.9多元函数的极值</h3><h4 id="无条件极值"><a href="#无条件极值" class="headerlink" title="无条件极值"></a>无条件极值</h4><h5 id="极值的必要条件"><a href="#极值的必要条件" class="headerlink" title="极值的必要条件"></a>极值的必要条件</h5><p>设$z=f(x,y)$在点$P_0(x_0,y_0)$处具有连续偏导数$f_x,f_y$，且在点$P_0(x_0,y_0)$处取得极值，则<br>$$<br>f_x(x_0,y_0)=0,f_y(x_0,y_0)=0<br>$$</p><h5 id="极值的充分条件"><a href="#极值的充分条件" class="headerlink" title="极值的充分条件"></a>极值的充分条件</h5><p>设设$z=f(x,y)$在点$(x_0,y_0)$处的某一领域内有二阶连续偏导数，且满足<br>$$<br>f_x(x_0,y_0)=0,f_y(x_0,y_0)=0<br>$$<br>令$A=f_{xx}(x_0,y_0),B=f_{yy}(x_0,y_0),C=f_{zz}(x_0,y_0)$，则</p><ul><li>当$AC-B^2&gt;0$时，函数有极值，其中，$A&lt;0$时有极大值，$A&gt;0$时有极小值；</li><li>当$AC-B^2&lt;0$时，函数无极值；</li><li>当$AC-B^2=0$时，未定。</li></ul><h4 id="有界闭区域上函数的最大最小值"><a href="#有界闭区域上函数的最大最小值" class="headerlink" title="有界闭区域上函数的最大最小值"></a>有界闭区域上函数的最大最小值</h4><p>有界闭区域上函数的最大最小值的求解步骤:</p><ol><li>求出$f(x,y)$在$D$内的所有驻点及驻点处的函数值；</li><li>求出$f(x,y)$在在边界上的最大（小）值；</li><li>比较以上各值其最大（小）者为$D$上的最大（小）值。</li></ol><h4 id="条件极值"><a href="#条件极值" class="headerlink" title="条件极值"></a>条件极值</h4><p>设目标函数$u=f(x,y)$，约束条件$\varphi(x,y)=0$，构造拉格朗日函数$F(x,y,\lambda)=f(x,y)+\lambda\mu(x,y)$，其中$\lambda$为某一常数，对三变量$x,y,\lambda$分别求导得，$F_x,F_y,F_\lambda$，求出驻点即可。</p><p>可推广至三元函数，则多加一变量$z$一常数$\lambda_2$。</p><h2 id="第六章-多元数量值函数积分学"><a href="#第六章-多元数量值函数积分学" class="headerlink" title="第六章 多元数量值函数积分学"></a>第六章 多元数量值函数积分学</h2><h3 id="6-1多元数量值函数积分的概念与性质"><a href="#6-1多元数量值函数积分的概念与性质" class="headerlink" title="6.1多元数量值函数积分的概念与性质"></a>6.1多元数量值函数积分的概念与性质</h3><p>估值定理  夹在最小值 最大值 之间，即$m\cdot(\Omega的度量)\leq\int_{\Omega}f(M)d\Omega\leq M\cdot(\Omega的度量)$</p><p>积分中值定理</p><p>取绝对值</p><h4 id="对称性"><a href="#对称性" class="headerlink" title="对称性"></a>对称性</h4><p>当积分区域$\Omega$关于$x=0$对称时，</p><ul><li>$f(M)$关于$x$为奇函数，则$\int_\Omega f(M)d\Omega=0$。</li><li>$f(M)$关于$x$为偶函数，则$\int_\Omega f(M)d\Omega=2\int_{\Omega’} f(M)d\Omega$</li></ul><h3 id="6-2二重积分的计算"><a href="#6-2二重积分的计算" class="headerlink" title="6.2二重积分的计算"></a>6.2二重积分的计算</h3><h4 id="直角坐标系下"><a href="#直角坐标系下" class="headerlink" title="直角坐标系下"></a>直角坐标系下</h4><h4 id="极坐标系下"><a href="#极坐标系下" class="headerlink" title="极坐标系下"></a>极坐标系下</h4><p>$dxdy=rdrd\theta$</p><h5 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h5><p>双纽线：$r^2=2a^2cos2\theta$</p><p>四叶玫瑰线：$r=4sin2\theta$</p><h3 id="6-3三重积分的计算"><a href="#6-3三重积分的计算" class="headerlink" title="6.3三重积分的计算"></a>6.3三重积分的计算</h3><h4 id="在直角坐标系中计算三重积分"><a href="#在直角坐标系中计算三重积分" class="headerlink" title="在直角坐标系中计算三重积分"></a>在直角坐标系中计算三重积分</h4><p>从函数表示的上面到函数表示的下面的累加</p><h4 id="平行截面法计算三重积分"><a href="#平行截面法计算三重积分" class="headerlink" title="平行截面法计算三重积分"></a>平行截面法计算三重积分</h4><p>算一截面的面积，然后对积分上下限常数$z$累加。</p><h5 id="使用范围总结"><a href="#使用范围总结" class="headerlink" title="使用范围总结"></a>使用范围总结</h5><ul><li><p>被积表达式最好仅为$z$的函数</p></li><li><p>截面为规则的图形</p><p>以上两种方法主要是$r$与$z$的不同。</p></li></ul><h4 id="柱坐标系下计算三重积分"><a href="#柱坐标系下计算三重积分" class="headerlink" title="柱坐标系下计算三重积分"></a>柱坐标系下计算三重积分</h4><p>$\iiint f(x,y,z)dV=\iiint f(rcos\theta,rsin\theta,z)rdrd\theta dz$</p><h4 id="球坐标系下计算三重积分"><a href="#球坐标系下计算三重积分" class="headerlink" title="球坐标系下计算三重积分"></a>球坐标系下计算三重积分</h4><p>$\iiint f(x,y,z)dV=\iiint f(\rho sin\varphi cos\theta,\rho sin\varphi sin\theta,\rho cos\varphi)\rho^2 sin\varphi d\rho d\varphi d\theta$</p><h4 id="换元法计算三重积分"><a href="#换元法计算三重积分" class="headerlink" title="换元法计算三重积分"></a>换元法计算三重积分</h4><p>常用式子：</p><p>$\iiint f(x,y,z)dV=\iiint f(a\rho sin\varphi cos\theta,b\rho sin\varphi sin\theta,c\rho cos\varphi)abc\rho^2 sin\varphi d\rho d\varphi d\theta$</p><h3 id="6-4第一类曲线积分的计算"><a href="#6-4第一类曲线积分的计算" class="headerlink" title="6.4第一类曲线积分的计算"></a>6.4第一类曲线积分的计算</h3><h4 id="曲线的弧长"><a href="#曲线的弧长" class="headerlink" title="曲线的弧长"></a>曲线的弧长</h4><p>直角坐标系下：$s=\int^b_a\sqrt{1+[y’(x)]^2}dx $</p><p>其中参数方程表示：$s=\int^\beta_\alpha\sqrt{x’(t)^2+y’(t)^2}dt$</p><p>极坐标系下：$s=\int^\beta_\alpha\sqrt{r^2(\theta)+r’^2(\theta)}d\theta$</p><h4 id="第一类曲线积分"><a href="#第一类曲线积分" class="headerlink" title="第一类曲线积分"></a>第一类曲线积分</h4><p>参数方程的形式：$\int_Lf(x,y)ds=\int^{\beta}_{\alpha}f[x(t),y(t)]\sqrt{x’^2(t)+y’^2(t)}dt$</p><p>特殊情况：$L:y=y(x)$，则</p><p>$\int_Lf(x,y)ds=\int^{b}_{a}f[x,y(x)]\sqrt{1+y’^2(x)}dx$</p><h3 id="6-5第一类曲面积分的计算"><a href="#6-5第一类曲面积分的计算" class="headerlink" title="6.5第一类曲面积分的计算"></a>6.5第一类曲面积分的计算</h3><h4 id="曲面的面积"><a href="#曲面的面积" class="headerlink" title="曲面的面积"></a>曲面的面积</h4><p>若曲面$S$的方程为$z=z(x,y)$，在$xOy$面上的投影为$D_{xy}$面上的投影为$D_{xy}$，则<br>$$<br>S=\iint_{D_{xy}}\sqrt{1+z_x^2(x,y)+z_y^2(x,y)}dxdy<br>$$<br>投影在其它坐标面的情况类似。</p><p><strong>特别地</strong>，对于半球面，$z=\sqrt{R^2-x^2-y^2}$，有<br>$$<br>dS=\sqrt{1+z_x^2+z_y^2}dxdy=\dfrac{R^2}{\sqrt{R^2-x^2-y^2}}dxdy<br>$$</p><h4 id="第一类曲面积分的计算"><a href="#第一类曲面积分的计算" class="headerlink" title="第一类曲面积分的计算"></a>第一类曲面积分的计算</h4><p>若曲面$S$的方程为$z=z(x,y)$，S在$xOy$面上的投影为$D_{xy}$面上的投影为$D_{xy}$，$f(x,y,z)$在$S$上连续，则<br>$$<br>S=\iint_Sf(x,y,z)dS=\iint_{D_{xy}}f[x,y,z(x,y)]\sqrt{1+z_x^2(x,y)+z_y^2(x,y)}dxdy<br>$$</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>确定投影方向，找出曲面$S $的方程及其微分$dS$。</li><li>找出曲面的投影区域。</li><li>利用公式求解。</li></ol><h4 id="参数方程曲面上的第一类曲面积分"><a href="#参数方程曲面上的第一类曲面积分" class="headerlink" title="参数方程曲面上的第一类曲面积分"></a>参数方程曲面上的第一类曲面积分</h4><p><strong>特别地</strong>，对于半径为$R$的球面参数方程，有<br>$$<br>\iint_Sf(x,y,z)dS=\iint_{D_{\phi\theta}}f(\rho sin\varphi cos\theta,\rho sin\varphi sin\theta,\rho cos\varphi)\rho^2 sin\varphi d\rho d\varphi d\theta<br>$$</p><h3 id="6-6积分在物理上的应用"><a href="#6-6积分在物理上的应用" class="headerlink" title="6.6积分在物理上的应用"></a>6.6积分在物理上的应用</h3><h4 id="物体的重心"><a href="#物体的重心" class="headerlink" title="物体的重心"></a>物体的重心</h4><p>当物体均匀时，有质心坐标，<br>$$<br>\bar x=\dfrac{\int_\Omega xd\Omega}{\int_\Omega d\Omega},\bar y=\dfrac{\int_\Omega yd\Omega}{\int_\Omega d\Omega},\bar z=\dfrac{\int_\Omega zd\Omega}{\int_\Omega d\Omega}<br>$$<br>，$y,z$坐标同理可得。</p><p>且有，$\int_\Omega xd\Omega=\bar x\int_\Omega d\Omega$</p><h4 id="转动惯量"><a href="#转动惯量" class="headerlink" title="转动惯量"></a>转动惯量</h4><p>设物体分布在空间几何体$\Omega$上，其密度函数为$\mu(M)$，则物体绕$x,y,z$轴的转动惯量为<br>$$<br>I_x=\int_\Omega(z^2+y^2)\mu(M)d\Omega,<br>I_y=\int_\Omega(x^2+z^2)\mu(M)d\Omega,<br>I_z=\int_\Omega(x^2+y^2)\mu(M)d\Omega<br>$$<br>设物体分布在平面区域$D$上，其密度函数为$\mu(M)$，则物体绕$x,y$轴的转动惯量为<br>$$<br>I_x=\iint_Dy^2\mu(M)dxdy,I_y=\iint_Dx^2\mu(M)dxdy<br>$$<br><strong>注意到，$x,y,z$的对称性。</strong></p><h4 id="引力"><a href="#引力" class="headerlink" title="引力"></a>引力</h4><p>设几何体$\Omega$密度函数为$\mu(P)$，引力$F$在三个坐标轴上的分量$F_x,F_y,F_z$分别为<br>$$<br>F_x=G\int_\Omega\dfrac{\mu(P)(x-x_0)}{r^3}d\Omega,F_x=G\int_\Omega\dfrac{\mu(P)(y-y_0)}{r^3}d\Omega,F_z=G\int_\Omega\dfrac{\mu(P)(z-z_0)}{r^3}d\Omega<br>$$<br>其中，$r=\sqrt{(x-x_0)^2+(y-y_0)^2+(z-z_0)^2}$。</p><h3 id="6-7含参变量的积分"><a href="#6-7含参变量的积分" class="headerlink" title="6.7含参变量的积分"></a>6.7含参变量的积分</h3><h4 id="有限区间上的含参变量积分"><a href="#有限区间上的含参变量积分" class="headerlink" title="有限区间上的含参变量积分"></a>有限区间上的含参变量积分</h4><p>设$f(x,y)$在闭区间$D={(x,y)|a\leq x\leq b,c\leq y\leq d}$上连续，则对$[a,b]$上任一固定的$x$，$f(x,y)$是$y$函数，故$f(x,y)$在$[c,d]$上可积，积分<br>$$<br>\varphi(x)=\int_c^d f(x,y)dy<br>$$<br>称$\varphi(x)$为含参变量$x$的积分，称$x$为参变量。</p><p><strong>莱布尼兹公式</strong><br>$$<br>\varphi’(x)=\dfrac{d}{dx}\int_{\alpha(x)}^{\beta(x)}f(x,y)dy=\int_{\alpha(x)}^{\beta(x)}f_x(x,y)dy+f[x,\beta(x)]\beta’(x)-f[x,\alpha(x)]\alpha’(x)<br>$$<br><strong>各条定理总结</strong>：求导与积分的顺序可对调，</p><p>积分计算的例子：$I=\int_0^1\dfrac{x^b-x^a}{lnx}dx$</p><h4 id="含参变量广义积分"><a href="#含参变量广义积分" class="headerlink" title="含参变量广义积分"></a>含参变量广义积分</h4><p><strong>各条定理总结</strong>：可交换积分顺序</p><p><strong>欧拉-泊松积分</strong>$$J=\int^{+\infty}_0e^{-x^2}dx=\dfrac{\sqrt{\pi}}{2}$$</p><p><strong>菲涅尔积分</strong>$J=\int_0^{+\infty}sinx^2dx=\dfrac{1}{2}\sqrt{\dfrac{\pi}{2}}$</p><h2 id="第七章-多元向量值函数积分学"><a href="#第七章-多元向量值函数积分学" class="headerlink" title="第七章 多元向量值函数积分学"></a>第七章 多元向量值函数积分学</h2><h3 id="7-1第二类曲线积分"><a href="#7-1第二类曲线积分" class="headerlink" title="7.1第二类曲线积分"></a>7.1第二类曲线积分</h3><h4 id="第二类曲线积分的背景"><a href="#第二类曲线积分的背景" class="headerlink" title="第二类曲线积分的背景"></a>第二类曲线积分的背景</h4><p>求变力沿曲线所作的功</p><p>记为$\int_L(F\cdot\tau_0)ds=\int_LF\cdot dr$。</p><h4 id="第二类曲线积分的性质"><a href="#第二类曲线积分的性质" class="headerlink" title="第二类曲线积分的性质"></a>第二类曲线积分的性质</h4><ul><li>$\int_L(k_1F_1+k_2F_2)=k_1\int_LF_1dr+k_2\int_LF_2dr$</li><li>$L=L_1+L_2$，且方向一致，则$\int_LF\cdot dr=\int_{L_1}F\cdot dr+\int_{L_2}F\cdot dr$</li><li>$\int_LF\cdot dr=-\int_{-L}F\cdot dr$</li></ul><p>对坐标的曲线积分：$\int_LF\cdot dr=\int_LF\cdot ds=\int_LP(x,y,z)dx+Q(x,y,z)dy+R(x,y,z)dz$</p><h4 id="第二类曲线积分的计算"><a href="#第二类曲线积分的计算" class="headerlink" title="第二类曲线积分的计算"></a>第二类曲线积分的计算</h4><p>设曲线的参数方程为$x=x(t),y=y(t)$，其实$t:\alpha\to\beta$，则<br>$$<br>\int_LP(x,y)dx+Q(x,y)dy=\int_\alpha^\beta {P[x(t),y(t)]x’(t)+Q[x(t),y(t)]y’(t)}dt<br>$$<br>特殊情况：$L:y=y(x)$，则<br>$$<br>\int_LP(x,y)dx+Q(x,y)dy=\int_\alpha^\beta {P[x,y(x)]dx+Q[x,y(x)]y’(x)}dx<br>$$<br>其它情况类似。</p><h3 id="7-2第二类曲面积分"><a href="#7-2第二类曲面积分" class="headerlink" title="7.2第二类曲面积分"></a>7.2第二类曲面积分</h3><p><strong>第二类曲面积分</strong>(也称对坐标的曲面积分)<br>$$<br>\iint_SF\cdot d\vec{S}=\iint_S(Pcos\alpha+Qcos\beta+Rcos\gamma)dS=\iint_S P(x,y,z) dydz+Q(x,y,z) dzdx+R(x,y,z) dxdy<br>$$</p><h4 id="第二类曲面积分的性质"><a href="#第二类曲面积分的性质" class="headerlink" title="第二类曲面积分的性质"></a>第二类曲面积分的性质</h4><p>与第二类曲线积分的性质类似。</p><h4 id="第二类曲面积分的计算（合一投影）"><a href="#第二类曲面积分的计算（合一投影）" class="headerlink" title="第二类曲面积分的计算（合一投影）"></a>第二类曲面积分的计算（合一投影）</h4><p>若曲面方程为$z=z(x,y),(x,y)\in D_{xy}$，则<br>$$<br>\iint_SF\cdot d\vec{S}=\iint_S P dydz+Q dzdx+Rdxdy=\pm\iint_{D_{x,y}}{F[x,y,z(x,y)]\cdot n(x,y)dxdy}<br>$$</p><p>其中，$n(x,y)=(-z_x,-z_y,1)$。</p><p>曲面取$z$轴的上侧取正，下侧取负。</p><p>当$y=y(z,x),x=(y,z)$的情况类似。</p><p><strong>计算步骤</strong></p><ul><li>定方向</li><li>定向量</li><li>定正负</li><li>定积分</li></ul><h4 id="第二类曲面积分的计算（分面投影）"><a href="#第二类曲面积分的计算（分面投影）" class="headerlink" title="第二类曲面积分的计算（分面投影）"></a>第二类曲面积分的计算（分面投影）</h4><p>利用变量的对等性，$x,y,z$对等，可用一个替代。</p><p>若曲面方程为$z=z(x,y),(x,y)\in D_{xy}$，则<br>$$<br>\iint_SR(x,y,z)dxdy=\pm\iint_{D_{sy}}(0,0,R(x,y,z(x,y)))\cdot (-z_x,-z_y,1)dxdy=\pm\iint_{D_{xy}}R(x,y,z(x,y))dxdy<br>$$<br>当曲面的侧与$z$轴的正向夹角成锐角时取正号，反之钝角取负号。</p><p>当$y=y(z,x),x=(y,z)$的情况类似。</p><h4 id="两类曲面积分之间的联系"><a href="#两类曲面积分之间的联系" class="headerlink" title="两类曲面积分之间的联系"></a>两类曲面积分之间的联系</h4><p>$$<br>{\oiint}{F\cdot d\vec{S}}={\oiint} F\cdot n_0 dS<br>$$</p><p>其中$n_0$为与曲面侧一致的单位法向量。</p><p>$$<br>cos\alpha=\dfrac{\mp z_2}{\sqrt{1+z_x^2+z_y^2}},\iint_SP(x,y,z)dydz=\iint_SP(x,y,z)cos\alpha dS<br>$$</p><p>其它情况类似。</p><h3 id="7-3积分基本定理"><a href="#7-3积分基本定理" class="headerlink" title="7.3积分基本定理"></a>7.3积分基本定理</h3><h4 id="区域连通性的分类"><a href="#区域连通性的分类" class="headerlink" title="区域连通性的分类"></a>区域连通性的分类</h4><p>设$D$为平面区域， 如果$D$内任一闭曲线所围成的部分都属于$D$，则称$D$为<strong>平面单连通区域</strong>， 否则称为<strong>复连通区域</strong>。</p><p>设空间区域$G$，如果$G$内任一闭曲面所围成的区域全属于$G$，则称$G$是<strong>空间二维单连通域</strong>；如果$G$内任一闭曲线总可以张一片完全属于$G$的曲面，则称$G$为<strong>空间一维单连通区域</strong>。</p><p>设$L$为平面区域$D$的边界曲线，当一个人沿着$L$行走，如果$D$的内部区域总位于这个人的左侧，称这个人行走的方向为$L$的正方向，另一方向为负方向。</p><h4 id="格林公式"><a href="#格林公式" class="headerlink" title="格林公式"></a>格林公式</h4><p>定理1：设设闭区域$D$由分段光滑的曲线$L$围成函数，函数$P(x,y),Q(x,y)$在$D$上有<strong>一阶连续偏导数</strong>，则<br>$$<br>\oint_LPdx+Qdy=\iint_D(\dfrac{\partial Q}{\partial x}-\dfrac{\partial P}{\partial y})dxdy<br>$$<br>其中$L$是$D$的正向边界曲线。</p><p>实质：沟通了沿闭合曲线的积分与二重积分之间的联系。</p><p>推论：设$D$是由分段光滑的曲线$L_1$与$L_2$围成的平面复连通区域，函数$P(x,y),Q(x,y)$在$D$上有一阶连续偏导数，则<br>$$<br>\iint_D(\dfrac{\partial Q}{\partial x}-\dfrac{\partial P}{\partial y})dxdy=\oint_{L_1}Pdx+Qdy+\oint_{L_2}Pdx+Qdy<br>$$<br>特别地，当$\dfrac{\partial Q}{\partial x}=\dfrac{\partial P}{\partial y}$时，<br>$$<br>\oint_{L_1}Pdx+Qdy=-\oint_{L_2}Pdx+Qdy=\oint_{L_2-}Pdx+Qdy<br>$$</p><h4 id="高斯公式"><a href="#高斯公式" class="headerlink" title="高斯公式"></a>高斯公式</h4><p>定理1：设空间闭区域$V$是由分片光滑的闭曲线$S$围成，函数$P(x,y,z),Q(x,y,z),R(x,y,z)$是$V$上有<strong>一阶连续偏导数</strong>，则有<br>$$<br>\iiint_V(\dfrac{\partial P}{\partial x}+\dfrac{\partial Q}{\partial y}+\dfrac{\partial R}{\partial z})dV={\oiint}_S Pdydz+Qdzdx+Rdxdy<br>$$<br>其中，$S$为$V$的边界曲面的外侧。</p><p>实质：表达了空间闭区域上的三重积分与其边界曲面上的曲面积分之间的关系。</p><p>高斯公式的使用条件</p><ul><li>曲面S为闭曲面</li><li>曲面S的方向为外侧</li><li>函数P,Q,R在V上一阶连续可导</li></ul><h4 id="斯托克斯公式"><a href="#斯托克斯公式" class="headerlink" title="斯托克斯公式"></a>斯托克斯公式</h4><p>定理：设$\varGamma$是分段光滑的空间有向闭曲线，$S$是以$\varGamma$为界的分片光滑的有向曲面，$\varGamma$的正向与$S$的侧向符合右手法则，函数$P(x,y,z),Q(x,y,z),R(x,y,z)$在包含曲面$S$在内的一个空间区域内具有一阶连续偏导数，则有斯托克斯公式<br>$$<br>\iint_S(\dfrac{\partial R}{\partial y}-\dfrac{\partial Q}{\partial z})dydz+(\dfrac{\partial P}{\partial z}-\dfrac{\partial R}{\partial x})dzdx+(\dfrac{\partial Q}{\partial x}-\dfrac{\partial P}{\partial y})dxdy=\oint_{\varGamma}Pdx+Qdy+Rdz<br>$$<br>实质：斯托克斯公式表达了有向曲面上的曲面积分与其边界曲线上的曲线积分之间的关系。</p><p>斯托克斯公式的特殊情况是格林公式。</p><h3 id="7-4曲线积分与路径无关"><a href="#7-4曲线积分与路径无关" class="headerlink" title="7.4曲线积分与路径无关"></a>7.4曲线积分与路径无关</h3><h4 id="积分与路径无关的定义"><a href="#积分与路径无关的定义" class="headerlink" title="积分与路径无关的定义"></a>积分与路径无关的定义</h4><p>如果在区域$G$内有<br>$$<br>\int_{L_1}Pdx+Qdy=\int_{L_2}Pdx+Qdy<br>$$<br>称曲线积分$\int_{L}Pdx+Qdy$在$G$内与路径无关，否则称积分与路径有关。</p><h4 id="曲线积分与路径无关的条件"><a href="#曲线积分与路径无关的条件" class="headerlink" title="曲线积分与路径无关的条件"></a>曲线积分与路径无关的条件</h4><p>定理1：设$D$为平面上的<strong>单连通区域</strong>，函数$P(x,y),Q(x,y)$在D上有<strong>一阶连续偏导数</strong>，则下四命题等价：</p><ul><li>沿D内任一条闭曲线L，有$\oint_L{P(x,y)dx+Q(x,y)dy}=0。$</li><li>$\int_L{P(x,y)dx+Q(x,y)dy}$在$D$内积分与路径无关。</li><li>${P(x,y)dx+Q(x,y)dy}$为$D$内某函数$u(x,y)$的全微分，$du(x,y)=P(x,y)dx+Q(x,y)dy$。</li><li>在$D$内每一点有$\dfrac{\partial{Q}}{\partial{x}}=\dfrac{\partial{P}}{\partial{y}}$。</li></ul><h4 id="全微分方程"><a href="#全微分方程" class="headerlink" title="全微分方程"></a>全微分方程</h4><p>定义：对于一阶常微分方程$P(x,y)dx+Q(x,y)dy=0$，若存在一函数$u(x,y)$，使$du(x,y)=P(x,y)dx+Q(x,y)dy$，称此方程为全微分方程。</p><p>定理：$u(x,y)=C$为全微分方程$P(x,y)dx+Q(x,y)dy=0$的通解。</p><p>积分因子：对于方程$Pdx+Qdy=0$不是全微分方程，若存在函数$\mu(x,y)$，使$\mu Pdx+\mu Qdy=0$为全微分方程，称$\mu(x,y)$为积分因子。</p><h3 id="7-5场论初步"><a href="#7-5场论初步" class="headerlink" title="7.5场论初步"></a>7.5场论初步</h3><h4 id="场的概念"><a href="#场的概念" class="headerlink" title="场的概念"></a>场的概念</h4><p>分布着某种物理量的平面或空间区域称为<strong>场</strong>。若物理量为数量，称此场为<strong>数量场</strong>。若物理量为向量，称此场为<strong>向量场</strong>。 不随时间变化的场称为<strong>稳定场</strong>。 随时间变化的场称为<strong>不稳定场</strong>。</p><p>梯度：$gradu=\dfrac{\partial u}{\partial x}i+\dfrac{\partial u}{\partial y}j+\dfrac{\partial u}{\partial z}k$</p><p>散度：$divA=\dfrac{\partial P}{\partial x}+\dfrac{\partial Q}{\partial y}+\dfrac{\partial R}{\partial z}$</p><p>旋度：$rotA=(\dfrac{\partial R}{\partial y}-\dfrac{\partial Q}{\partial z})i+(\dfrac{\partial P}{\partial z}-\dfrac{\partial R}{\partial x})j+(\dfrac{\partial Q}{\partial x}-\dfrac{\partial P}{\partial y})k$</p><p>其中，$u=u(x,y,z),A=Pi+Qj+Rk$</p><h2 id="第八章-无穷级数"><a href="#第八章-无穷级数" class="headerlink" title="第八章 无穷级数"></a>第八章 无穷级数</h2><h3 id="8-1常数项级数的概念"><a href="#8-1常数项级数的概念" class="headerlink" title="8.1常数项级数的概念"></a>8.1常数项级数的概念</h3><p>级数的定义：给定数列$u_1,u_2,…,u_n,…,$则由这个数列构成的表达式$u_1+u_2+u_3+…+u_n+…$称为无穷级数，简称级数，记为<br>$$<br>\sum_{n=1}^{\infin}u_n=u_1+u_2+u_3+…+u_n+…<br>$$<br>称每一项$u_n$为常数的级数$\sum_{n=1}^{\infty}u_n$为常数项级数。</p><p>称每一项$u_n$为函数的级数$\sum_{n=1}^{\infty}u_n$为函数项级数。</p><p>称级数$\sum_{n=1}^{\infty}u_n$的前n项之和$S_n$，为级数的部分和。</p><p>常用方法：裂项法</p><h4 id="级数的基本性质"><a href="#级数的基本性质" class="headerlink" title="级数的基本性质"></a>级数的基本性质</h4><p>若级数$\sum_{n=1}^{\infty}u_n$收敛，则$\sum_{n=1}^{\infty}ku_n$也收敛。</p><p>若两收敛级数$s=\sum_{n=1}^{\infty}u_n$,$\sigma=\sum_{n=1}^{\infty}v_n$，则级数$\sum_{n=1}^{\infty}{u_n\pm v_n}$收敛，其和为$s\pm\sigma$。</p><p>等等…</p><h4 id="级数收敛的必要条件"><a href="#级数收敛的必要条件" class="headerlink" title="级数收敛的必要条件"></a>级数收敛的必要条件</h4><p>若$n$无限增大时，他的一般项$u_n$趋于零，即级数$\sum_{n=1}^{\infty}u_n$收敛，则$lim_{n\to \infty}u_n=0$。</p><p>（应用）<strong>即</strong>：若一般项$u_n$不趋于零，则级数发散。</p><h3 id="8-2常数项级数的判别法"><a href="#8-2常数项级数的判别法" class="headerlink" title="8.2常数项级数的判别法"></a>8.2常数项级数的判别法</h3><p>$$<br>\sum_{n=1}^{\infin}\dfrac{1}{n^2}=\dfrac{\pi^2}{6}<br>$$</p><h4 id="正项级数与其审敛法"><a href="#正项级数与其审敛法" class="headerlink" title="正项级数与其审敛法"></a>正项级数与其审敛法</h4><p><strong>定义</strong>：若级数$\sum_{n=1}^{\infty}u_n$中各项均有$u_n\geq 0$，称此级数为正项级数。</p><p><strong>性质</strong>：若$S_n$为有界数列，则$lim_{n\to \infty}S_n=S$，则收敛。</p><p>若$S_n$为无界数列，则$lim_{n\to \infty}S_n=+\infty$，则发散。</p><p><strong>定理</strong>：若$\sum_{n=1}^{\infty}u_n$为正项级数，则级数$\sum_{n=1}^{\infty}u_n$收敛的充分必要条件为它的部分和数列$S_n$有界。</p><h5 id="比较审敛法"><a href="#比较审敛法" class="headerlink" title="比较审敛法"></a>比较审敛法</h5><p>设$\sum_{n=1}^{\infty}u_n$和$\sum_{n=1}^{\infty}v_n$均为正项级数，且$u_n\leq v_n$，若$\sum_{n=1}^{\infty}v_n$收敛，则$\sum_{n=1}^{\infty}u_n$收敛；若$\sum_{n=1}^{\infty}u_n$发散，则$\sum_{n=1}^{\infty}v_n$发散。</p><p>不便：须有参考级数。</p><p>极限形式：</p><p>设$\sum_{n=1}^{\infty}u_n$和$\sum_{n=1}^{\infty}v_n$均为正项级数，$v_n&gt;0$，若$lim_{n\to \infty}\dfrac{u_n}{v_n}=l$，</p><ul><li>当$0&lt;l&lt;+\infty$时，两级数有相同的敛散性。</li><li>当$l=0$时，若$\sum_{n=1}^{\infty}v_n$收敛，则$\sum_{n=1}^{\infty}u_n$收敛。</li><li>当$l=+\infty$时，若$\sum_{n=1}^{\infty}v_n$发散，则$\sum_{n=1}^{\infty}u_n$发散。</li></ul><p><strong>关键之处</strong>：找到合适的比较对象</p><h5 id="3个重要的参考级数"><a href="#3个重要的参考级数" class="headerlink" title="3个重要的参考级数"></a>3个重要的参考级数</h5><ul><li>调和级数：$\sum_{n=1}^{\infty}\dfrac{1}{n}$：发散。</li><li>几何级数：$\sum_{n=1}^{\infty}aq^n$，$|q|\geq1$：发散；$|q|&lt;1$：收敛。</li><li>p-级数：$\sum_{n=1}^{\infty}\dfrac{1}{n^p}$，$q&gt;1$：发散；$q\leq1$：收敛。</li></ul><p>均值不等式：$ab={a^2}+{b^2}$</p><h5 id="比值审敛法（达朗贝尔判别法）"><a href="#比值审敛法（达朗贝尔判别法）" class="headerlink" title="比值审敛法（达朗贝尔判别法）"></a>比值审敛法（达朗贝尔判别法）</h5><p>设$\sum_{n=1}^\infty u_n$为正项级数，$u_n&gt;0$，若$lim_{n\to \infty}\dfrac{u_{n+1}}{u_n}=\rho$，则</p><ul><li>$\rho&lt;1$时级数收敛；</li><li>$\rho&gt;1$时级数发散；</li><li>$\rho=1$时级数敛散性未定。</li></ul><p>注意：</p><ul><li>比值审敛法优点: 不必找参考级数.</li><li>比值审敛法的条件是充分而非必要的.</li></ul><h5 id="根值审敛法（Cauchy判别法）"><a href="#根值审敛法（Cauchy判别法）" class="headerlink" title="根值审敛法（Cauchy判别法）"></a>根值审敛法（Cauchy判别法）</h5><p>设$\sum_{n=1}^\infty u_n$为正项级数，如果$lim_{n\to \infty}\sqrt[n]{u_n}=\rho$，则</p><ul><li>$\rho&lt;1$时级数收敛；</li><li>$\rho&gt;1$时级数发散；</li><li>$\rho=1$时级数敛散性未定。</li></ul><p>注意：</p><ul><li>比值审敛法优点: 不必找参考级数.</li><li>比值审敛法的条件是充分而非必要的.</li></ul><h4 id="交错级数及其审敛法"><a href="#交错级数及其审敛法" class="headerlink" title="交错级数及其审敛法"></a>交错级数及其审敛法</h4><p>定义：称正，负项交替出现的级数为交错级数.</p><h5 id="定理（莱布尼兹判别式）"><a href="#定理（莱布尼兹判别式）" class="headerlink" title="定理（莱布尼兹判别式）"></a>定理（莱布尼兹判别式）</h5><p>若交错级数$\sum_{n=1}^\infty (-1)^{n-1}u_n$满足如下条件：</p><ul><li>$u_n\geq u_{n+1}\geq0$</li><li>$lim_{n\to \infty} u_n=0$</li></ul><p>则级数$\sum_{n=1}^\infty (-1)^{n-1}u_n$收敛，且其和$S\leq u_1$，其余项$R_n$的绝对值$|R_n|\leq u_{n+1}$</p><h4 id="绝对收敛与条件收敛"><a href="#绝对收敛与条件收敛" class="headerlink" title="绝对收敛与条件收敛"></a>绝对收敛与条件收敛</h4><p>任意项级数：正项和负项任意出现的级数。</p><h5 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h5><p>若$\sum_{n=1}^\infty |u_n|$收敛，则$\sum_{n=1}^\infty u_n$，称$\sum_{n=1}^\infty u_n$绝对收敛。</p><p>定理的作用：从任意项级数-&gt;正项级数</p><p><strong>绝对收敛</strong>定义：若$\sum_{n=1}^\infty |u_n|$收敛，称$\sum_{n=1}^\infty u_n$绝对收敛。</p><p><strong>条件收敛</strong>定义：若$\sum_{n=1}^\infty |u_n|$发散，$\sum_{n=1}^\infty u_n$收敛，称$\sum_{n=1}^\infty u_n$条件收敛。</p><h5 id="定理-1"><a href="#定理-1" class="headerlink" title="定理"></a>定理</h5><p>绝对收敛级数的任一重排级数绝对收敛于原级数的和。</p><p>（条件收敛不一定成立）</p><h5 id="黎曼定理"><a href="#黎曼定理" class="headerlink" title="黎曼定理"></a>黎曼定理</h5><p>设级数$\sum_{n=1}^\infty u_n$条件收敛，任给$B$（有穷实数或$\pm\infty$），都有$\sum_{n=1}^\infty u_n$的一个重排$\sum_{n=1}^\infty u_n^<em>$，使得$B=\sum_{n=1}^\infty u_n^</em>$。</p><h4 id="一般项级数的敛散性"><a href="#一般项级数的敛散性" class="headerlink" title="一般项级数的敛散性"></a>一般项级数的敛散性</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/.xyz/2020/08//Users\Hong\Documents\Markdown\图片\一般项级数敛散性的判别过程.png" alt="一般项级数敛散性的判别过程" title>                </div>                <div class="image-caption">一般项级数敛散性的判别过程</div>            </figure><h3 id="8-3幂指数"><a href="#8-3幂指数" class="headerlink" title="8.3幂指数"></a>8.3幂指数</h3><h5 id="收敛点与收敛域"><a href="#收敛点与收敛域" class="headerlink" title="收敛点与收敛域"></a>收敛点与收敛域</h5><p>如果$x_0\in I$，且函数项级数$\sum_{n=1}^\infty u_n(x_0)$收敛，称$x_0$为级数$\sum_{n=1}^\infty u_n(x)$的收敛点，否则称为级数的发散点。级数$\sum_{n=1}^\infty u_n(x)$的所有收敛点的全体称为<strong>收敛域</strong>，所有发散点的全体称为<strong>发散域</strong>。</p><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>称形如$\sum_{n=0}^\infty a_n(x-x_0)^n$的级数为幂函数。</p><h5 id="定理1（Abel定理）"><a href="#定理1（Abel定理）" class="headerlink" title="定理1（Abel定理）"></a>定理1（Abel定理）</h5><p>若级数 $\sum_{n=0}^\infty a_n x^n$在$x=x_0(x_0\not =0)$点收敛，则它在满足不等式$|x|&lt;|x_0|$的一切$x$处绝对收敛；若级数 $\sum_{n=0}^\infty a_n x^n$在$x=x_0(x_0\not =0)$点发散，则它在满足不等式$|x|&gt;|x_0|$的一切$x$处发散。</p><h5 id="定理2"><a href="#定理2" class="headerlink" title="定理2"></a>定理2</h5><p>若级数 $\sum_{n=0}^\infty a_n x^n$的所有系数$a_n\not =0$，设$lim_{n\to\infty}|\dfrac{a_{n+1}}{a_n}|=\rho(lim_{n\to\infty}\sqrt[n]{|a_n|}=\rho)$，则</p><ul><li>当$\rho\not =0$时，$R=\dfrac{1}{\rho}$；</li><li>当$\rho =0$时，$R=+\infty$；</li><li>当$\rho =+\infty$时，$R=0$。</li></ul><h5 id="和函数的分析运算性质"><a href="#和函数的分析运算性质" class="headerlink" title="和函数的分析运算性质"></a>和函数的分析运算性质</h5><ul><li>极限运算与求和运算可交换顺序；</li><li>积分运算与求和运算可交换顺序；</li><li>求导运算与求和运算可交换顺序。</li></ul><h5 id="已知和函数的幂级数"><a href="#已知和函数的幂级数" class="headerlink" title="已知和函数的幂级数"></a>已知和函数的幂级数</h5><ul><li><p>$$<br>\sum_{n=0}^\infin x^n=\dfrac{1}{1-x}<br>$$</p></li><li><p>$$<br>\sum_{n=0}^\infin(-1)^n x^{2n}=\dfrac{1}{1+x^2}<br>$$</p></li><li><p>$$<br>\sum_{n=0}^\infin a x^{2n}=\dfrac{a}{1-x^2}<br>$$</p></li><li><p>$$<br>\sum_{n=0}^\infin\dfrac{x^n}{n!}=e^x<br>$$</p></li><li><p>$$<br>\sum_{n=1}^\infin(-1)^{n-1}\dfrac{x^{2n-1}}{(2n-1)!}=sin{x}<br>$$</p></li><li><p>$$<br>\sum_{n=0}^\infin(-1)^{n-1}\dfrac{x^{2n}}{(2n)!}=cos{x}<br>$$</p></li><li><p>$$<br>\sum_{n=0}^\infin(-1)^n\dfrac{x^{n+1}}{n+1}=ln(1+x)<br>$$</p></li></ul><h3 id="8-4函数展开成幂级数"><a href="#8-4函数展开成幂级数" class="headerlink" title="8.4函数展开成幂级数"></a>8.4函数展开成幂级数</h3><h4 id="泰勒级数"><a href="#泰勒级数" class="headerlink" title="泰勒级数"></a>泰勒级数</h4><h5 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h5><p>设函数$f(x)$ 在$x_0$的某个邻域U$(x_0,\delta_0$)内具有任意阶导数，则函数f(x)在该点邻域内能展开成泰勒级数的充要条件是$f(x)$的泰勒公式中的余项$R_n(x)$满足<br>$$<br>lim_{n\to\infin}R_n(x)=0;\forall x\in N(x_0,\delta_0)<br>$$</p><h5 id="定理2-1"><a href="#定理2-1" class="headerlink" title="定理2"></a>定理2</h5><p>如果$f(x)$在区间$(-R+x_0,R+x_0)$能展开成泰勒级数<br>$$<br>f(x)=\sum_{n=0}^\infin \dfrac{f^{(n)}(x_0)}{n!}(x-x_0)^n<br>$$<br>则右端的幂级数是唯一的。</p><h4 id="函数展开成幂级数"><a href="#函数展开成幂级数" class="headerlink" title="函数展开成幂级数"></a>函数展开成幂级数</h4><ul><li>直接法（泰勒级数法）步骤：求$a_n$，讨论$lim_{n\to\infty}R_n(x)=0$，写出$f(x)$。</li><li>间接法，根据唯一性，利用常见展开式，通过变量代换，四则运算，恒等变形，逐项求导，逐项积分等方法，求展开式。</li></ul><h3 id="8-5幂级数的应用"><a href="#8-5幂级数的应用" class="headerlink" title="8.5幂级数的应用"></a>8.5幂级数的应用</h3><h4 id="欧拉公式"><a href="#欧拉公式" class="headerlink" title="欧拉公式"></a>欧拉公式</h4><p>$$<br>e^{ix}=cosx+isinx<br>$$</p><h3 id="8-6傅里叶级数"><a href="#8-6傅里叶级数" class="headerlink" title="8.6傅里叶级数"></a>8.6傅里叶级数</h3><h4 id="三角级数"><a href="#三角级数" class="headerlink" title="三角级数"></a>三角级数</h4><p>$$<br>\dfrac{a_0}{2}+\sum_{n=1}^\infin(a_ncosnx+b_nsinnx)<br>$$</p><h4 id="函数展开成傅里叶级数"><a href="#函数展开成傅里叶级数" class="headerlink" title="函数展开成傅里叶级数"></a>函数展开成傅里叶级数</h4><p>$$<br>f(x)=\dfrac{a_0}{2}+\sum_{n=1}^\infin(a_ncosnx+b_nsinnx)<br>$$</p><p>其中，<br>$$<br>a_0=\dfrac{1}{\pi}\int_{-\pi}^\pi f(x)dx<br>$$</p><p>$$<br>a_n=\dfrac{1}{\pi}\int_{-\pi}^{\pi}f(x)cos{nx}dx(n=0,1,2,…)<br>$$</p><p>$$<br>b_n=\dfrac{1}{\pi}\int_{-\pi}^{\pi}f(x)sin{nx}dx(n=1,2,…)<br>$$</p><h4 id="狄利克雷收敛定理"><a href="#狄利克雷收敛定理" class="headerlink" title="狄利克雷收敛定理"></a>狄利克雷收敛定理</h4><p>设$f(x)$是以$2\pi$为周期的周期函数，若它在一个周期内连续或只有有限个第一类间断点，且至多有限个极值点，则$f(x)$的傅立叶级数收敛，而且</p><ul><li>当$x$为连续点时，级数收敛于$f(x)$；</li><li>当$x$为间断点时，级数收敛于$\dfrac{f(x-0)+f(x+0)}{2}$；</li><li>当$x=\pm\pi$是，级数收敛于$\dfrac{f(-\pi+0)+f(\pi-0)}{2}$。</li></ul><h3 id="8-7正弦级数和余弦级数"><a href="#8-7正弦级数和余弦级数" class="headerlink" title="8.7正弦级数和余弦级数"></a>8.7正弦级数和余弦级数</h3><h4 id="奇函数和偶函数的傅里叶级数"><a href="#奇函数和偶函数的傅里叶级数" class="headerlink" title="奇函数和偶函数的傅里叶级数"></a>奇函数和偶函数的傅里叶级数</h4><h5 id="定理-2"><a href="#定理-2" class="headerlink" title="定理"></a>定理</h5><p>周期为$2\pi$的奇函数$f(x)$的傅里叶级数的系数为</p><p>$$<br>a_n=0,b_n=\dfrac{2}{\pi}\int_{0}^{\pi}f(x)sin{nx}dx(n=1,2,…),f(x):\sum_{n=1}^\infin b_nsinnx<br>$$<br>为正弦级数。</p><p>周期为$2\pi$的偶函数$f(x)$的傅里叶级数的系数为</p><p>$$<br>a_n=\dfrac{2}{\pi}\int_{0}^{\pi}f(x)cos{nx}dx,b_n=0,(n=1,2,…),f(x):\dfrac{a_0}{2}+\sum_{n=1}^\infin a_ncosnx<br>$$<br>为余弦级数。</p><h4 id="函数展开成正弦级数或余弦级数"><a href="#函数展开成正弦级数或余弦级数" class="headerlink" title="函数展开成正弦级数或余弦级数"></a>函数展开成正弦级数或余弦级数</h4><p>非周期函数的周期延拓</p><p>设$f(x)$定义在[0,$\pi$]上，延拓成以$2\pi$为周期的函数$F(x)$。令<br>$$<br>F(x) = \begin{cases}<br>   f(x) &amp; 0\leq x\leq\pi \<br>   g(x) &amp; -\pi&lt;x&lt;0<br>\end{cases}，且F(x+2\pi)=F(x)<br>$$<br>则有两种情况，奇延拓和偶延拓。</p><h3 id="8-8任意周期函数的傅里叶级数"><a href="#8-8任意周期函数的傅里叶级数" class="headerlink" title="8.8任意周期函数的傅里叶级数"></a>8.8任意周期函数的傅里叶级数</h3><h4 id="以-2l-为周期的傅里叶级数"><a href="#以-2l-为周期的傅里叶级数" class="headerlink" title="以$2l$为周期的傅里叶级数"></a>以$2l$为周期的傅里叶级数</h4><p>若周期为$2l$的周期函数$f(x)$满足收敛定理跳条件，则它的傅里叶级数展开式为<br>$$<br>f(x)=\dfrac{a_0}{2}+\sum_{n=1}^{\infin}(a_ncos\dfrac{n\pi x}{l}+b_nsin\dfrac{n\pi x}{l})<br>$$<br>其中，系数$a_n$,$b_n$为<br>$$<br>a_n=\dfrac{1}{l}\int_{-l}^{l}f(x)cos\dfrac{n\pi x}{l}dx(n=0,1,2,…)<br>$$</p><p>$$<br>b_n=\dfrac{1}{l}\int_{-l}^{l}f(x)sin\dfrac{n\pi x}{l}dx(n=1,2,…)<br>$$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;微积分II笔记&quot;&gt;&lt;a href=&quot;#微积分II笔记&quot; class=&quot;headerlink&quot; title=&quot;微积分II笔记&quot;&gt;&lt;/a&gt;微积分II笔记&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;(版权所有  禁止转载)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(版权所有
      
    
    </summary>
    
    
    
      <category term="Math" scheme="ronpay.xyz/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>离散数学笔记</title>
    <link href="ronpay.xyz/2020/07/31/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    <id>ronpay.xyz/2020/07/31/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2020-07-31T02:31:36.000Z</published>
    <updated>2020-07-31T02:34:29.960Z</updated>
    
    <content type="html"><![CDATA[<h1 id="离散数学笔记"><a href="#离散数学笔记" class="headerlink" title="离散数学笔记"></a>离散数学笔记</h1><h3 id="谓词逻辑"><a href="#谓词逻辑" class="headerlink" title="谓词逻辑"></a>谓词逻辑</h3><p>US ES 去量词</p><p>UG EG 添量词</p><h3 id="第1章-集合论"><a href="#第1章-集合论" class="headerlink" title="第1章 集合论"></a>第1章 集合论</h3><h4 id="空集"><a href="#空集" class="headerlink" title="空集"></a>空集</h4><ul><li>空集是一切集合的子集。</li><li>空集值是绝对唯一的.</li></ul><h4 id="集合基数"><a href="#集合基数" class="headerlink" title="集合基数"></a>集合基数</h4><p>集合$A$中元素的数目称为集合$A$的基数，记为$|A|$。</p><h4 id="m元子集"><a href="#m元子集" class="headerlink" title="m元子集"></a>m元子集</h4><p>如果一个集合$A$含有$n$个元素，则称集合$A$为$n$元集，称$A$的含有$m$个$(0≤m≤n)$元素的子集为$A$的$m$元子集。</p><h4 id="幂集"><a href="#幂集" class="headerlink" title="幂集"></a>幂集</h4><p>设$A$为任意集合，把$A$的所有不同子集为元素构成的集合叫做$A$的幂集，记为$P(A)$或$2^A$。</p><p>有$|P(A)|＝ 2^{|A|}$</p><h4 id="等势"><a href="#等势" class="headerlink" title="等势"></a>等势</h4><p>设$A，B$是两个集合，若在$A，B$之间存在$1-1$对应的关系：$ψ：A→B$</p><p>则称$A$与$B$是等势的，记为：$A$~$B$。</p><p>凡是与自然数集合等势的集合，均称为可数集合(可列集)。可数集合的基数记为：$\aleph_0$(读作阿列夫零) 。</p><h4 id="不可数集合"><a href="#不可数集合" class="headerlink" title="不可数集合"></a>不可数集合</h4><ul><li>开区间 $(0, 1)$ 称为不可数集合，其基数记为为$\aleph$ (读作阿列夫)；</li><li>凡是与开区间 $(0, 1)$ 等势的集合都是不可数集合。</li></ul><h4 id="集合运算定理"><a href="#集合运算定理" class="headerlink" title="集合运算定理"></a>集合运算定理</h4><p>设$A、B、C$为任意集合，$Ｕ$为全集，$Φ$为空集</p><ul><li>幂等律: $A∪A=A$； $A∩A=A$； </li><li>恒等律: $A∪Φ =A$；$A∩U =A$；    </li><li>零　律: $A∪U=U$；   $A∩Φ=Φ$；</li><li>否定律：$\overline{\overline{A}}=A$；</li><li>矛盾律： $A∩\overline{A}＝Φ$；</li><li>排中律：$A∪\overline{A}＝U$</li><li>交换律:  $A∪B=B∪A$; <pre><code>$A∩B=B∩A$</code></pre></li><li>吸收律:  $A∩(A∪B)=A$;<br>$A∪(A∩B)=A$；</li><li>DeMorgAn律：$\overline{A∪B}=\overline{A}∩\overline{B}$，$\overline{A∩B}=\overline{A}∪\overline{B}$</li><li>结合律：$A∪(B∪C)=(A∪B)∪C$；<br>$A∩(B∩C)=(A∩B)∩C$；</li><li>分配律：$A∩(B∪C)=(A∩B)∪(A∩C)$<pre><code>$A∪(B∩C)=(A∪B)∩(A∪C)$</code></pre></li></ul><h3 id="第2章-计数问题"><a href="#第2章-计数问题" class="headerlink" title="第2章 计数问题"></a>第2章 计数问题</h3><h4 id="鸽笼原理"><a href="#鸽笼原理" class="headerlink" title="鸽笼原理"></a>鸽笼原理</h4><p>若有$n+1$只鸽子住进$n$个鸽笼，则有一个鸽笼至少住进$2$只鸽子。</p><h3 id="第3章-命题逻辑"><a href="#第3章-命题逻辑" class="headerlink" title="第3章 命题逻辑"></a>第3章 命题逻辑</h3><h4 id="基本等价公式"><a href="#基本等价公式" class="headerlink" title="基本等价公式"></a>基本等价公式</h4><p>设$G，H，S$是任何的公式，则：</p><ul><li>E1：$G∨(H∨S)＝(G∨H)∨S$  (结合律)</li><li>E2：$G∧(H∧S)＝(G∧H)∧S$</li><li>E3：$G∨H＝H∨G$         (交换律)</li><li>E4：$G∧H＝H∧G$</li><li>E5：$G∨G＝G$          (幂等律)</li><li>E6：$G∧G＝G$</li><li>E7：$G∨(G∧H)＝ G$                      (吸收律)</li><li>E8：$G∧(G∨H)＝ G$</li><li>E9：$G∨(H∧S)＝(G∨H)∧(G∨S)$    (分配律）</li><li>E10：$G∧(H∨S)＝(G∧H)∨(G∧S)$</li><li>E11：$G∨0＝G$                (同一律)</li><li>E12：$G∧1＝G$</li><li>E13：$G∨1＝1$                    (零律)</li><li>E14：$G∧0＝0$</li><li>E15：$G∨┐G ＝  1$                  (排中律)</li><li>E16：$G∧┐G ＝0$                  (矛盾律)</li><li>E17：$┐(┐G)＝G$                (双重否定律)</li><li>E18：$┐(G∨H)＝┐G∧┐H$            (德·摩根律)</li><li>E19：$┐(G∧H)＝┐G∨┐H$</li><li>E20：$G→H＝┐G∨H$             (蕴涵式)</li><li>E21: $G\leftrightarrow H＝(G→H)∧(H→G)$         (等价式)</li><li>E22：$G →H＝┐H→┐G$        (假言易位)</li><li>E23：$G\leftrightarrow H＝┐G\leftrightarrow ┐H$        (等价否定等式)</li><li>E24：$(G →H) ∧(G→┐H)＝┐G$    (归谬论)</li></ul><h3 id="第4章-谓词逻辑"><a href="#第4章-谓词逻辑" class="headerlink" title="第4章 谓词逻辑"></a>第4章 谓词逻辑</h3><h4 id="谓词演算中的基本等价公式"><a href="#谓词演算中的基本等价公式" class="headerlink" title="谓词演算中的基本等价公式"></a>谓词演算中的基本等价公式</h4><ul><li>E25：$(\exists x)G(x) = (\exists y)G(y)$ </li><li>E26：$(\forall x)G(x) = (\forall y)G(y)$             </li><li>E27： $\neg(\exists x)G(x) = (\forall x)\neg G(x)$</li><li>E28：$\neg(\forall x)G(x) = (\exists x)\neg G(x)$ </li><li>E29：$(\forall x)(G(x)∨S) = (\forall x)G(x)∨S$</li><li>E30：$(\forall x)(G(x)∧S) = (\forall x)G(x)∧S$</li><li>E31：$(\exists x)(G(x)∨S) = (\exists x)G(x)∨S$</li><li>E32：$(\exists x)(G(x)∧S) = (\exists x)G(x)∧S$</li><li>E33：$(\forall x)(G(x)∧H(x)) = (\forall x)G(x)∧(\forall x)H(x)$</li><li>E34：$(\exists x)(G(x)∨H(x)) = (\exists x)G(x)∨(\exists x)H(x)$(量词分配律)</li><li>E35：$(\forall x)G(x)∨(\forall x)H(x) = (\forall x)(\forall y)(G(x)∨H(y))$</li><li>E36：$(\exists x)G(x)∧(\exists x)H(x) = (\exists x)(\exists y)(G(x)∧H(y))$     </li></ul><h3 id="第5章-证明技术"><a href="#第5章-证明技术" class="headerlink" title="第5章 证明技术"></a>第5章 证明技术</h3><p>演绎法证明符号：</p><ul><li>P：条件； </li><li>T，，，I：由→推理得到；</li><li>T，，，E：有蕴涵式可得；</li><li>P（附加前提）：附加条件；</li><li>CP：使用附加前提要用CP规则；</li><li>US：去任意量词</li><li>ES：去存在量词</li><li>UG：加任意量词</li><li>EG：加存在量词</li></ul><h4 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h4><h3 id="第6章-二元关系"><a href="#第6章-二元关系" class="headerlink" title="第6章 二元关系"></a>第6章 二元关系</h3><h4 id="自反性和反自反性"><a href="#自反性和反自反性" class="headerlink" title="自反性和反自反性"></a>自反性和反自反性</h4><p>如果对任意$x∈A$，都有$&lt;x, x&gt;∈R$，那么称$R$在$A$上是自反的。</p><p>如果对任意$x∈A$，都有$&lt;x, x&gt;\not\in R$，那么称$R$在$A$上是反自反的。</p><h4 id="对称性和反对称性"><a href="#对称性和反对称性" class="headerlink" title="对称性和反对称性"></a>对称性和反对称性</h4><p>对任意$x, y∈A$，如果$&lt;x, y&gt;∈R$，那么$&lt;y,x&gt; ∈R$，则称关系$R$是对称的。</p><p>对任意$x, y∈A$，如果$&lt;x, y&gt;∈R$且$&lt;y,x&gt;∈R$，那么$x＝y$，则称关系$R$是反对称的。</p><h4 id="传递性"><a href="#传递性" class="headerlink" title="传递性"></a>传递性</h4><p>对任意$x, y, z∈A$，如果$&lt;x, y&gt;∈R$且$&lt;y, z&gt;∈R$，那么$&lt;x, z&gt;∈R$，则称关系$R$是传递的。</p><h4 id="关系性质的保守性"><a href="#关系性质的保守性" class="headerlink" title="关系性质的保守性"></a>关系性质的保守性</h4><p>设$R, S$是定义在$A$上的二元关系，则：</p><p>若$R,S$是自反的，则$R^{-1},R∪S,R∩S,RoS$也是自反的</p><p>若$R, S$是反自反的，则$R^{-1}, R∪S, R∩S, RoS$也是反自反的</p><p>若$R,S$是对称的，则$R^{-1},R∪S,R∩S,RoS$也是对称的</p><p>若$R,S$是反对称的，则$R^{-1}, R∩S, RoS$也是反对称的</p><p>若$R,S$是传递的，则$R{-1}, R∩S$也是传递的</p><h4 id="关系的闭包"><a href="#关系的闭包" class="headerlink" title="关系的闭包"></a>关系的闭包</h4><p>设$R$是定义在$A$上的关系，若存在$A$上的另一个关系$R′$，使得$R\subseteq R′$，满足：</p><p>1.$R′$是自反的（对称的、或传递的）；</p><p>2.任何自反的（对称的、或传递的）关系$R〞$，如果$R\subseteq R$〞，就有$R′\subseteq R〞$，</p><p>则称$R′$为$R$的自反闭包（对称闭包或传递闭包），分别记为$r(R)$ （$s(R)$或$t(R)$）。</p><p>关系的闭包是增加最少元素，使其具备所需性质的扩充。</p><h3 id="第7章-特殊关系"><a href="#第7章-特殊关系" class="headerlink" title="第7章 特殊关系"></a>第7章 特殊关系</h3><h4 id="等价关系"><a href="#等价关系" class="headerlink" title="等价关系"></a>等价关系</h4><p>设R是定义在非空集合A上的关系，如果R是<strong>自反的、对称的、传递的</strong>，则称R为A上的等价关系。</p><h4 id="等价类"><a href="#等价类" class="headerlink" title="等价类"></a>等价类</h4><p>设$R$是非空集合$A$上的等价关系，对任意$x∈A$，称集合</p><p>$[x]_R = {y|y∈A∧&lt;x,y&gt;∈R}$</p><p>为$x$关于$R$的等价类，其中$x$称为$[x]_R$的生成元 。</p><ul><li>$R$具有自反性意味着对任意$x∈A，[x]_R ≠ Φ$。</li><li>$R$具有对称性意味着对任意$x, y∈A$，若有$y∈[x]R$，则一定有$x∈[y]_R$。</li></ul><h4 id="商集"><a href="#商集" class="headerlink" title="商集"></a>商集</h4><p>设$R$是非空集合$A$上的等价关系，由$R$确定的一切等价类为元素构成的集合，称为集合$A$关于$R$的商集，记为$A/R$，即$A/R = { [x]R | x∈A }$</p><h4 id="等价关系与划分"><a href="#等价关系与划分" class="headerlink" title="等价关系与划分"></a>等价关系与划分</h4><p>给定集合A的一个划分$П = {A1, A2, …, An}$， 则由该划分确定的关系$R = (A1×A1)∪(A2×A2)∪…∪(An×An)$是$A$上的等价关系。我们称该关系$R$为由划分$П$所导出的等价关系。</p><h4 id="拟序关系"><a href="#拟序关系" class="headerlink" title="拟序关系"></a>拟序关系</h4><p>设$R$是非空集合$A$上的关系，如果$R$是<strong>反自反</strong>、<strong>反对称</strong>和<strong>传递</strong>的，则称$R$是$A$上的拟序关系，简称拟序，记为“$＜$”，读作“小于”，并将“$&lt;a, b&gt;∈＜$”记为“$a＜b$”。</p><p>序偶&lt;A, ＜&gt;称为拟序集。<br>拟序“$＜$”的逆关系“$＜^{-1}$”也是拟序，用“$＞$”表示，读作“大于”。</p><h4 id="偏序关系"><a href="#偏序关系" class="headerlink" title="偏序关系"></a>偏序关系</h4><p>设$R$是非空集合$A$上的关系，如果$R$是<strong>自反</strong>的、<strong>反对称</strong>的和<strong>传递</strong>的，则称$R$是$A$上的偏序关系，简称偏序，记为“$≤$”。</p><p>偏序“$≤$”的逆关系“$≤-1$”也是一个偏序，我们用“$≥$”表示，读作“大于等于”；<br>$(≤-I_A)$为$A$上的拟序关系，$(＜∪I_A)$为$A$上的偏序关系。 </p><h4 id="哈斯图"><a href="#哈斯图" class="headerlink" title="哈斯图"></a>哈斯图</h4><ul><li>用小圆圈或点表示A中的元素，省掉关系图中所有的环；                       （因自反性)</li><li>对任意$x, y∈A$，若$x＜y$，则将$x$画在$y$的下方，可省掉关系图中所有边的箭头；（因反对称性）<br>对任意$x, y∈$A，若$x＜y$，且不存在$z∈A$，使得</li><li>$x＜z,  z＜y$，则$x$与$y$之间用一条线相连，否则<br>无线相连。（因传递性）</li></ul><h4 id="偏序集的特殊元素"><a href="#偏序集的特殊元素" class="headerlink" title="偏序集的特殊元素"></a>偏序集的特殊元素</h4><p>设$&lt;A, ≤&gt;$是偏序集，$B$是$A$的任何一个子集。若存在元素$a∈A$，使得</p><ul><li>对任意$x∈B$，都有$x ≤ a$，则称$a$为$B$的上界；</li><li>对任意$x∈B$，都有$a ≤ x$，则称$a$为$B$的下界；</li><li>若元素$a′∈A$是$B$的上界，元素$a∈A$是$B$的任何一个上界，均有$a′ ≤ a$，则称$a′$为$B$的最小上界或上确界，记为SupB；</li><li>若元素$a′∈A$是$B$的下界，元素$a∈A$是$B$的任何一个下界，均有$a ≤ a′$，则称$a′$为$B$的最大下界或下确界，记为InfB。</li></ul><h4 id="全序关系"><a href="#全序关系" class="headerlink" title="全序关系"></a>全序关系</h4><p>设$&lt;A, ≤ &gt;$为偏序集，若对任意$x, y∈A$，总有$x ≤ y$或$y ≤ x$，二者必居其一，则称关系“$≤$”为全序关系(Total Order Relation)，简称全序，或者线序关系，简称线序。称$&lt;A, ≤ &gt;$为全序集(Total Order Set)，或者线序集，或者链(Chain)。</p><h4 id="良序关系"><a href="#良序关系" class="headerlink" title="良序关系"></a>良序关系</h4><p>设$&lt;A, ≤ &gt;$是一偏序集，若$A$的每个非空子集都有最小元，则称“$≤$”为良序关系，简称良序，此时$&lt;A, ≤ &gt;$称为良序集。<br>良序关系一定是全序关系，反之则不然。</p><h3 id="第8章-函数"><a href="#第8章-函数" class="headerlink" title="第8章 函数"></a>第8章 函数</h3><h4 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h4><p>设$f$是集合$A$到$B$的关系，如果对每个$x∈A$，都存在惟一的$y∈B$，使得$&lt;x, y&gt;∈f$，则称关系f为A到B的函数(Function)(或映射(Mapping)、变换(Transform))，记为$f: A→B$。</p><p>当$&lt;x, y&gt;∈f$时，通常记为$y = f(x)$，这时称$x$为函数$f$的自变量，$y$为$x$在$f$下的函数值(或象)， 也称$x$为$y$在$f$下的原象 。 </p><p>称$A$为函数$f$的定义域，记为$domf$<br>称$f(A) = y| y = f(x), x∈A$为函数 $f$ 的值域，记为$ranf$<br>若$A = B$，则称$f$为$A$上的函数</p><h4 id="函数的类型"><a href="#函数的类型" class="headerlink" title="函数的类型"></a>函数的类型</h4><p>设$f$是从$A$到$B$的函数，对任意$x1, x2∈A$，</p><ul><li>如果$x1 ≠ x2$，有$f(x1) ≠ f(x2)$，则称$f$为从$A$到$B$的单射（不同的$x$对应不同的$y)$</li><li>如果$ranf = B$，则称$f$为从$A$到$B$的满射</li><li>若$f$是满射且是单射，则称$f$为从$A$到$B$的双射</li><li>当$A$上的函数$f$是双射时，称$f$为变换</li></ul><h4 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h4><p>设$A, B$是有限集合，且$|A| = |B|$，$f$是$A$到$B$的函数，则$f$是单射当且仅当f是满射。</p><h4 id="函数的运算"><a href="#函数的运算" class="headerlink" title="函数的运算"></a>函数的运算</h4><p>考虑$f: A→B，g: B→C$是两个函数，则fog = { &lt;x, z&gt; | x∈A{∧}z∈C{∧}(\exist y)(y∈B{∧}&lt;x, y&gt;∈f{∧}&lt;y, z&gt;∈g)从$A$到$C$的函数，记为$fog: A→C$ ，称为函数$f$与$g$的复合函数。对任意$x∈A，fog(x) = g(f(x))$。</p><h4 id="定理-1"><a href="#定理-1" class="headerlink" title="定理"></a>定理</h4><p>若$f$是$A$到$B$的双射，则$f$的逆函数$f^{-1}$也是$B$到$A$的双射。</p><h3 id="第9章-图"><a href="#第9章-图" class="headerlink" title="第9章 图"></a>第9章 图</h3><h4 id="特殊图"><a href="#特殊图" class="headerlink" title="特殊图"></a>特殊图</h4><ul><li>仅由孤立结点组成的图称为<strong>零图</strong>(Null Graph)</li><li>仅含一个结点的零图称为<strong>平凡图</strong>(Trivial Graph)</li><li>含有n个结点，m条边的图，称为<strong>(n, m)图</strong></li></ul><h4 id="图的分类"><a href="#图的分类" class="headerlink" title="图的分类"></a>图的分类</h4><p>在有向图中，两结点间(包括结点自身间)若有同始点和同终点的几条边，则这几条边称为<strong>平行边</strong>，在无向图中，两结点间(包括结点自身间)若有几条边，则这几条边称为<strong>平行边</strong>。两结点a、b间相互平行的边的条数称为边(a, b)或&lt;a, b&gt;的<strong>重数</strong>(Repeated Number)。</p><ul><li>含有平行边的图称为多重图(Multigraph)</li><li>非多重图称为线图(Line Graph)；</li><li>无环的线图称为简单图(Simple Graph)</li></ul><h4 id="子图和补图"><a href="#子图和补图" class="headerlink" title="子图和补图"></a>子图和补图</h4><ul><li><p>若V1 =V，E1包含于 E，则称G1是G的<strong>生成子图</strong>(Spanning Subgraph)</p></li><li><p>设V2 包含于V且V2 ≠ 空集，以V2为结点集，以两个端点均在V2中的边的全体为边集的G的子图，称为V2导出的G的子图，简称V2的<strong>导出子图</strong>(Induced Subgraph)</p></li><li><p>设$G = &lt;V, E&gt;$为一个具有n个结点的无向简单图，如果G中任意两个结点间都有边相连，则称G为<strong>无向完全图</strong>(Undirected Complete Graph)，简称G为完全图(Complete Graph)，记为Kn。</p></li><li><p>设$G = &lt;V, E&gt;$为一个具有n个结点的有向简单图，如果G中任意两个结点间都有两条方向相反的有向边相连，则称G为<strong>有向完全图</strong>(directed Complete Graph)，在不发生误解的情况下，也记为Kn。    </p></li></ul><h4 id="结点的度数与握手定理"><a href="#结点的度数与握手定理" class="headerlink" title="结点的度数与握手定理"></a>结点的度数与握手定理</h4><p>对于图G = &lt;V, E&gt;，度数为1的结点称为<strong>悬挂结点</strong>(Hanging Point)，以悬挂结点为端点的边称为<strong>悬挂边</strong>(Hanging Edge)。 </p><h5 id="握手定理"><a href="#握手定理" class="headerlink" title="握手定理"></a>握手定理</h5><p>图中结点度数的总和等于边数的二倍，即设图G $= &lt;V, E&gt;$，则有<br>$$<br>\sum_{v\in V}deg(v)=2|E|<br>$$</p><h5 id="推论"><a href="#推论" class="headerlink" title="推论"></a>推论</h5><p>图中度数为奇数的结点个数为偶数。</p><h3 id="第11章-特殊图"><a href="#第11章-特殊图" class="headerlink" title="第11章 特殊图"></a>第11章 特殊图</h3><h4 id="欧拉图"><a href="#欧拉图" class="headerlink" title="欧拉图"></a>欧拉图</h4><p>设G是无孤立结点的图，若存在一条通路(回路)，经过图中每边一次且仅一次，则称此通路(回路)为该图的一条欧拉通路(回路)(Eulerian Entry/Circuit)。具有欧拉回路的图称为欧拉图(Eulerian Graph)。</p><p>规定：平凡图为欧拉图。<br>以上定义既适合无向图，又适合有向图。 </p><h4 id="欧拉图的判定"><a href="#欧拉图的判定" class="headerlink" title="欧拉图的判定"></a>欧拉图的判定</h4><p>定理11.2.1  无向图$G = &lt;V, E&gt;$具有一条欧拉通路，当且仅当$G$是连通的，且仅有零个或两个奇度数结点。规定：平凡图为欧拉图。以上定义既适合无向图，又适合有向图。</p><p>定理11.2.2 有向图$G$具有欧拉通路，当且仅当$G$是连通的，且除了两个结点以外，其余结点的入度等于出度，而这两个例外的结点中，一个结点的入度比出度大1，另一个结点的出度比入度大1。</p><h4 id="欧拉图的算法"><a href="#欧拉图的算法" class="headerlink" title="欧拉图的算法"></a>欧拉图的算法</h4><p>设$G = &lt;V, E&gt;，e∈E$，如果$p(G-e)＞p(G)$,称$e$为$G$的桥(Bridge)或割边(Cut edge)。</p><p>其中，$p$表示连通分量的个数。</p><ol><li>求欧拉图$G = &lt;V, E&gt;$的欧拉回路的Fleury算法：<br>任取$v_0∈V，令P_0 = v_0，i = 0$；</li><li>按下面的方法从$E-{e1, e2, …, ei}$中选取$ei+1$：要求：<br>$ei+1$与$vi$相关联；<br>除非无别的边可选取，否则$ei+1$不应该为<br>$  G’ = G - {e1, e2, …, ei}$中的桥；</li><li>将边$ei+1$加入通路$P0$中，令<br>$P0 = v0e1v1e2…eiviei+1vi+1，   i = i+1$；</li><li>如果$i = |E|$，结束，否则转(2)。</li></ol><p>“<strong>一笔画问题</strong>”本质上就是一个无向图是否存在欧拉通路(回路)的问题。</p><h4 id="哈密顿图的定义"><a href="#哈密顿图的定义" class="headerlink" title="哈密顿图的定义"></a>哈密顿图的定义</h4><p>经过图中每个结点一次且仅一次的通路(回路)称为哈密顿通路(回路)(Hamiltonian Entry/circuit)。存在哈密顿回路的图称为哈密顿图(Hamiltonian Graph)。规定：平凡图为哈密顿图。以上定义既适合无向图，又适合有向图。</p><h4 id="哈密顿图的判定"><a href="#哈密顿图的判定" class="headerlink" title="哈密顿图的判定"></a>哈密顿图的判定</h4><p>定理11.3.1  设无向图$G = &lt;V, E&gt;$是哈密顿图，$V_1$是$V$的任意非空子集，则$p(G-V_1) ≤ |V_1|$</p><p>其中$p(G-V_1)$是从$G$中删除$V_1$后所得到图的连通分支数。</p><p>定理11.3.1在应用中它本身用处不大，但它的逆否命题却非常有用。我们经常利用定理11.3.1的逆否命题来判断某些图不是哈密顿图，即：若存在$V$的某个非空子集$V_1$使得 $p(G-V_1)＞|V_1|$，则$G$不是哈密顿图。 </p><p>(以下为充分条件)</p><p>定理11.3.2  设$G = &lt;V, E&gt;$是具有$n$个结点的简单无向图。如果对任意两个不相邻的结点$u, v∈V$，均有$deg(u) + deg(v) ≥ n - 1$,则$G$中存在哈密顿通路。</p><p>推论11.3.2  设$G = &lt;V, E&gt;$是具有$n$个结点的简单无向图。如果对任意两个不相邻的结点$u, v∈V$，均有$deg(u) + deg(v) ≥ n$,则$G$中存在哈密顿回路。</p><p>推论11.3.3  设$G = &lt;V, E&gt;$是具有$n$个结点的简单无向图，$n ≥ 3$。如果对任意$v∈V$，均有$deg(v) ≥ n/2$，则$G$是哈密顿图。</p><h4 id="偶图"><a href="#偶图" class="headerlink" title="偶图"></a>偶图</h4><p>定义11.4.1  若无向图$G = &lt;V, E&gt;$的结点集$V$能够划分为两个子集$V1, V2$，满足$V1∩V2 = Φ$，$且V1∪V2 = V$，使得$G$中任意一条边的两个端点，一个属于$V1$，另一个属于$V2$，则称$G$为偶图(Bipartite Graph)或二分图(Bigraph)。$V1$和$V2$称为互补结点子集，偶图通常记为$G=&lt;V1, E, V2&gt;$。</p><p>定义11.4.2  在偶图$G = &lt;V1, E, V2&gt;$中，若$V1$中的每个结点与$V2$中的每个结点都有且仅有一条边相关联，则称偶图$G$为完全偶图(Complete Bipartite Graph)或完全二分图(Complete Bigraph)，记为$Ki, j$，其中，$i = |V1|，j = |V2|$。</p><p>偶图的判断</p><p>定理11.4.1  无向图$G = &lt;V, E&gt;$为偶图的充分必要条件是$G$的所有回路的长度均为偶数。</p><p>一般：我们常使用它的逆否命题来判断一个图不是偶图：无向图$G$不是偶图的充分必要条件是$G$中存在长度为奇数的回路。</p><h4 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h4><p>定义11.4.2  在偶图$G = &lt;V1, E, V2$&gt;中，$V1 = {v1, v2, …, vq}$，若存在$E$的子集E’ = {(v1, v1’)，(v2, v2’)，…，(vq, vq’)，其中$v1’, v2’, …, vq’ $是$V2$中的$q$个不同的结点}，则称$G$的子图$G’ = &lt;V1, E’, V2&gt;$为从$V1$到$V2$的一个完全匹配(Complete Matching)，简称匹配。</p><p>定理11.4.2 (霍尔定理)  偶图$G = &lt;V1, E, V2&gt;$中存在从$V1$到$V2$的匹配的充分必要条件是$V1$中任意$k$个结点至少与$V2$中的$k$个结点相邻，$k = 1, 2, …, |V1|$.定理11.4.2中的条件通常称为相异性条件(Diversity Condition)。</p><p>定理11.4.3  设$G = &lt;V1,E,V2&gt;$是一个偶图。如果满足条件<br>      （1）$V1$中每个结点至少关联$t$条边；<br>      （2）$V2$中每个结点至多关联$t$条边；<br>则$G$中存在从$V1$到$V2$的匹配。其中$t$为正整数。</p><h4 id="平面图"><a href="#平面图" class="headerlink" title="平面图"></a>平面图</h4><p>如果能把一个无向图$G$的所有结点和边画在平面上，使得任何两边除公共结点外没有其他交叉点，则称$G$为平面图(Plane Graph)，否则称$G$为非平面图(Nonplanar Graph)。</p><h4 id="欧拉公式"><a href="#欧拉公式" class="headerlink" title="欧拉公式"></a>欧拉公式</h4><ul><li>由边所包围的其内部不包含图的结点和边的区域，称为$G$的一个面(Surface)</li><li>包围该面的边所构成的回路称为这个面的边界(Bound)</li><li>面$r$的边界的长度称为该面的次数(Degree)，记为$D(r)$</li><li>区域面积有限的面称为有限面(Finite Surface)，区域面积无限的面称为无限面(Infinite Surface)</li><li>平面图有且仅有一个无限面</li></ul><p>定理11.5.1  平面图中所有面的次数之和等于边数的二倍。怎么理解？每条边会被用两次</p><p>定理11.5.2  设$G = &lt;V, E&gt;$是连通平面图，若它有$n$个结点、$m$条边和$r$个面，则有</p><p>$$<br>n – m + r = 2<br>$$</p><p>推论11.5.1  设$G$是一个$(n, m)$简单连通平面图，若$m＞1$，则有$m ≤ 3n - 6$。</p><p>一般使用逆否命题，即一个简单连通图，若不满足 $m ≤ 3n - 6$，则一定是非平面图。</p><p>推论11.5.2  设$G$是一个$(n, m)$简单连通平面图，若每个面的次数至少为$k (k ≥ 3)$，则有 $m\leq\dfrac{k}{k-2}(n-2)$</p><p>完全图$K_5$，$k_{3,3}$是非平面图。</p><h4 id="库拉托夫斯基定理"><a href="#库拉托夫斯基定理" class="headerlink" title="库拉托夫斯基定理"></a>库拉托夫斯基定理</h4><p>定理11.5.3(库拉托夫斯基定理)  一个图是平面图的充分必要条件是它的任何子图都不可能收缩为$K5$或$K3, 3$。</p><p>推论11.5.3  一个图是非平面图的充分必要条件是它存在一个能收缩为$K5$或$K3, 3$的子图。</p><p>$K5$和$K3,3$称为库拉托夫斯基图(Kuratowski Graph)。</p><h2 id="离散数学题型笔记"><a href="#离散数学题型笔记" class="headerlink" title="离散数学题型笔记"></a>离散数学题型笔记</h2><h3 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h3><h3 id="计算题"><a href="#计算题" class="headerlink" title="计算题"></a>计算题</h3><h5 id="主析取范式和主合取范式"><a href="#主析取范式和主合取范式" class="headerlink" title="主析取范式和主合取范式"></a>主析取范式和主合取范式</h5><p>进行化简。</p><p>通过添加P∧P，P∨P，来凑取。</p><p>求得一个可以推下一个。</p><p>确定是析取还是合取。</p><h3 id="证明题"><a href="#证明题" class="headerlink" title="证明题"></a>证明题</h3><h5 id="演绎推理"><a href="#演绎推理" class="headerlink" title="演绎推理"></a>演绎推理</h5><p>通过演绎推理，注意P-&gt;Q 与 P∨Q的区别。</p><p>证明符号：</p><ul><li>P：条件； </li><li>T，，，I：由→推理得到；</li><li>T，，，E：有蕴涵式可得；</li><li>P（附加前提）：附加条件；</li><li>CP：使用附加前提要用CP规则；</li><li>US：去任意量词</li><li>ES：去存在量词</li><li>UG：加任意量词</li><li>EG：加存在量词</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;离散数学笔记&quot;&gt;&lt;a href=&quot;#离散数学笔记&quot; class=&quot;headerlink&quot; title=&quot;离散数学笔记&quot;&gt;&lt;/a&gt;离散数学笔记&lt;/h1&gt;&lt;h3 id=&quot;谓词逻辑&quot;&gt;&lt;a href=&quot;#谓词逻辑&quot; class=&quot;headerlink&quot; title=&quot;谓
      
    
    </summary>
    
    
    
      <category term="Math" scheme="ronpay.xyz/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>2020嵌入式工作室招新Linux方向招新题</title>
    <link href="ronpay.xyz/2020/07/01/Linux%20Learning/"/>
    <id>ronpay.xyz/2020/07/01/Linux%20Learning/</id>
    <published>2020-07-01T14:32:54.000Z</published>
    <updated>2020-07-31T02:36:00.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一关：初识Linux"><a href="#第一关：初识Linux" class="headerlink" title="第一关：初识Linux"></a>第一关：初识Linux</h2><h3 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h3><p>Linux是一种自由和开放源码的类UNIX操作系统。</p><p>Linux的优势在于开源，系统的源码是共享的，方便我们自行修改Linux系统，增加或修改所需要的功能，从而得到定制化的系统。服务器端的系统也常常是Linux，使用Linux作为环境，便于软件的调试。Linux 的强大的定制功能和低廉的成本，使得它在嵌入式系统得到广泛的运用。</p><p>因选修课使用过Ubuntu 16.04TLS，因此选择了VMware Workstation 安装 Ubuntu 20.04TLS。选择新版本的原因在于新的Linux版本会采用新的Linux内核。</p><p>首先在软件与更新中，更换软件源，提高下载速度。</p><p>安装chrome,vscode,typora,安装的方式看官网的步骤便可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#install chrome</span></span><br><span class="line">wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb</span><br><span class="line">sudo apt install ./google-chrome-stable_current_amd64.deb</span><br><span class="line">cat /etc/apt/sources.list.d/google-chrome.list</span><br></pre></td></tr></table></figure><p>设置网络代理</p><p>在主机的代理软件（Clash for Windows）上勾选允许LAN连接，然后在Ubuntu的网络代理中，设置手动，对所有的项，将地址设置为主机IP，端口设置为代理软件的端口，从而实现科学上网。</p><h4 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h4><p>安装必要的程序 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install gnome-tweaks</span><br><span class="line">sudo apt install chrome-gnome-shell</span><br></pre></td></tr></table></figure><p>安装gnome的chrome扩展，启用User Theme。</p><p>然后更换主题、图标、鼠标，这些东西我全都选了Mac OS的主题，顺便换了壁纸。</p><p>在gnome主题网站，下载MccainMojave-circle图标、MoMojave主题、McMojave cursors，分别解压缩复制到<code>./~/.themes</code> 和 <code>./~/.icons</code>目录，在优化中，启用相应主题、图标和鼠标。</p><p>在gnome网站上，下载Dash to dock美化dock栏。</p><p>效果如下：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/07/01/2WOjrvJglfI3zsV.png" alt="image-20200630213057555.png" title>                </div>                <div class="image-caption">image-20200630213057555.png</div>            </figure></p><h3 id="加分项"><a href="#加分项" class="headerlink" title="加分项"></a>加分项</h3><p>使用了Github+Hexo博客的搭建方式，使用了Hexo的Next主题。</p><h2 id="第二关：知识积累"><a href="#第二关：知识积累" class="headerlink" title="第二关：知识积累"></a>第二关：知识积累</h2><h3 id="Linux-常用命令"><a href="#Linux-常用命令" class="headerlink" title="Linux 常用命令"></a>Linux 常用命令</h3><ul><li>cd命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">回到上一次目录 cd -</span><br><span class="line">回到要目录 cd &#x2F;</span><br><span class="line">回到home目录 cd ~</span><br></pre></td></tr></table></figure><ul><li><p>mkdir命令</p></li><li><p>ls命令</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">所有文件 </span></span><br><span class="line">ls -a</span><br></pre></td></tr></table></figure><ul><li>mv命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">重命名 mv src dest</span><br><span class="line">移动 mv filename pathname(.&#x2F;表示当前位置，)</span><br></pre></td></tr></table></figure><ul><li>rm命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">删除文件 rm filename</span><br><span class="line">删除文件夹 rm -rf filename</span><br></pre></td></tr></table></figure><ul><li>tar命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">解压 tar -zxvf filename.tar.bz2</span><br></pre></td></tr></table></figure><ul><li>vim命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">进入&#x2F;创造文件 vim filename</span><br></pre></td></tr></table></figure><ul><li>make命令（编译）</li><li>chmod命令（更改访问权限）</li><li>Ctrl+C ，在后面讲述到，其实是通过终端向程序发出<code>SIGINT</code>信号，终止当前的进程。</li><li>ln命令（功能是为某一个文件在另外一个位置建立一个同步的链接）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln [参数][源文件或目录][目标文件或目录]</span><br></pre></td></tr></table></figure><h3 id="Ubuntu常用命令"><a href="#Ubuntu常用命令" class="headerlink" title="Ubuntu常用命令"></a>Ubuntu常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装软件 </span></span><br><span class="line">sudo apt-get install package</span><br><span class="line"><span class="comment">#更新源 </span></span><br><span class="line">sudo apt-get update</span><br><span class="line"><span class="comment">#更新已安装的包 </span></span><br><span class="line">sudo apt-get upgrade</span><br><span class="line"><span class="comment">#安装deb包的方式</span></span><br><span class="line">sudo dpkg -i [deb包]</span><br></pre></td></tr></table></figure><h3 id="GCC-安装及-编译C语言"><a href="#GCC-安装及-编译C语言" class="headerlink" title="GCC 安装及 编译C语言"></a>GCC 安装及 编译C语言</h3><h4 id="安装一般GCC的方法"><a href="#安装一般GCC的方法" class="headerlink" title="安装一般GCC的方法"></a>安装一般GCC的方法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">输入下面的命令，安装想要的 GCC 和 G++ ：</span></span><br><span class="line">sudo apt install gcc-8 g++-8 gcc-9 g++-9 gcc-10 g++-10</span><br><span class="line"><span class="meta">#</span><span class="bash">下面的命令配置每一个版本，并且设置了优先级。默认的版本是拥有最高优先级的那个，在我们的场景中是gcc-10。</span></span><br><span class="line">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-10 100 --slave /usr/bin/g++ g++ /usr/bin/g++-10 --slave /usr/bin/gcov gcov /usr/bin/gcov-10</span><br><span class="line">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 90 --slave /usr/bin/g++ g++ /usr/bin/g++-9 --slave /usr/bin/gcov gcov /usr/bin/gcov-9</span><br><span class="line">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-8 80 --slave /usr/bin/g++ g++ /usr/bin/g++-8 --slave /usr/bin/gcov gcov /usr/bin/gcov-8</span><br><span class="line"><span class="meta">#</span><span class="bash">以后，如果你想修改默认的版本，使用update-alternatives命令：</span></span><br><span class="line">sudo update-alternatives --config gcc</span><br></pre></td></tr></table></figure><h4 id="编译C语言"><a href="#编译C语言" class="headerlink" title="编译C语言"></a>编译C语言</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">编译C语言</span></span><br><span class="line"><span class="meta">#</span><span class="bash">命名为helloworld</span></span><br><span class="line">gcc -o helloworld helloworld.c </span><br><span class="line"><span class="meta">#</span><span class="bash">执行</span></span><br><span class="line">./helloworld</span><br><span class="line"><span class="meta">#</span><span class="bash">自动生成hello.o，但不会生成二进制执行文件，等待后续链接。</span></span><br><span class="line">gcc -c hello.c</span><br></pre></td></tr></table></figure><h4 id="安装特定版本的GCC的方法（编译）"><a href="#安装特定版本的GCC的方法（编译）" class="headerlink" title="安装特定版本的GCC的方法（编译）"></a>安装特定版本的GCC的方法（编译）</h4><p>（去Google上搜相应的方法，十分麻烦都要分别安装依赖项。最后找了一个英文网页，没几行命令，然后再等待几十分钟的编译就行了。）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">下载GCC源码</span></span><br><span class="line">wget https://ftpmirror.gnu.org/gcc/gcc-10.1.0/gcc-10.1.0.tar.xz</span><br><span class="line"><span class="meta">#</span><span class="bash">解压</span></span><br><span class="line">tar -zxvf gcc-10.1.0.tar.xz</span><br><span class="line"><span class="meta">#</span><span class="bash">下载依赖项</span></span><br><span class="line">cd gcc-10.1.0</span><br><span class="line">contrib/download_prerequisites</span><br><span class="line"><span class="meta">#</span><span class="bash">建立编译输出目录</span></span><br><span class="line">mkdir gcc-build</span><br><span class="line"><span class="meta">#</span><span class="bash">进入输出目录，执行命令，生成makefile文件</span></span><br><span class="line">../gcc-10.1.0/configure -v --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu --prefix=/usr/local/gcc-10.1.0 --enable-checking=release --enable-languages=c,c++,fortran --disable-multilib --program-suffix=-10.1</span><br><span class="line"><span class="meta">#</span><span class="bash">编译</span></span><br><span class="line">make -j 4</span><br><span class="line"><span class="meta">#</span><span class="bash">安装</span></span><br><span class="line">sudo make install-strip</span><br></pre></td></tr></table></figure><p>GCC-10.1编译安装效果，如下：（弄了好久也不知道怎么把它当作默认的gcc，估计安装路径有点问题）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/07/01/oEDdeA73VZR1J5n.png" alt="image-20200630213259310.png" title>                </div>                <div class="image-caption">image-20200630213259310.png</div>            </figure><h3 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h3><p><code>sudo apt-get install vim</code>安装vim.</p><h4 id="vi-vim的使用"><a href="#vi-vim的使用" class="headerlink" title="vi/vim的使用"></a>vi/vim的使用</h4><p>刚启动vi/vim时，进入命令模式，输入<code>i</code>，切换输入模式，</p><h5 id="输入模式常见命令"><a href="#输入模式常见命令" class="headerlink" title="输入模式常见命令"></a>输入模式常见命令</h5><ul><li><code>Esc</code>进入命令模式</li></ul><h5 id="底线命令模式常见命令"><a href="#底线命令模式常见命令" class="headerlink" title="底线命令模式常见命令"></a>底线命令模式常见命令</h5><ul><li><code>q</code> 退出程序</li><li><code>q!</code>强制退出不保存</li><li><code>w</code> 保存文件</li><li><code>wq</code> 保存文件并退出程序</li><li>按<code>ESC</code>键退出底线命令模式</li></ul><h4 id="一般命令模式常见命令："><a href="#一般命令模式常见命令：" class="headerlink" title="一般命令模式常见命令："></a>一般命令模式常见命令：</h4><ul><li><code>i,o,a</code>切换到输入模式，以输入字符。</li><li><code>x</code> 向后删除一个字符(del),<code>X</code> 为向前删除一个字符（backspace)</li><li><code>dd</code> 删除整行的字符。</li><li><code>:,/,?</code>切换到底线命令模式，以在最底一行输入命令。</li><li><code>gg</code> 移动到第一行</li><li><code>dG</code>删除光标所在处到最后一行所有数据</li><li><code>(n)yy</code>复制光标那一行(光标往下n行)</li><li><code>u</code>回复前一个操作</li><li><code>ctrl+</code>r重做上一个操作</li><li><code>/word</code>向下寻找word</li><li><code>?word</code>向上寻找word</li><li><code>:sp filename</code> 若打开同一个文件则无需filename。用<code>ctrl+w+</code>上 向上翻，用<code>ctrl+w+</code>下 向下翻</li><li><code>Ctrl x + ctrl n</code>关键词补全</li></ul><h4 id="vim缓存与恢复"><a href="#vim缓存与恢复" class="headerlink" title="vim缓存与恢复"></a>vim缓存与恢复</h4><p>打开不正常结束的vim时会出现缓存警告，可输入<code>o,e,r,d,q,a</code>分别表示只读open，编辑edit，加载缓存recover，删除缓存delete，停止quit，同停止abort。</p><h3 id="vim-美化与插件"><a href="#vim-美化与插件" class="headerlink" title="vim 美化与插件"></a>vim 美化与插件</h3><ol><li>下载 <a href="https://github.com/tomasr/molokai" target="_blank" rel="noopener">molokai 主题</a></li><li>将 <code>colors/molokai.vim</code> 拷贝到 <code>~/.vim/colors/</code></li><li>新建<code>~/.vimrc</code>文件，在 <code>~/.vimrc</code> 中添加：<code>colorscheme molokai</code></li></ol><p>（vim得安装很多插件才能有VSCode的intellisense、代码补全、自动格式化的功能，还不太习惯，不想折腾了，后面就用VSCode写了）</p><p><a href="https://github.com/junegunn/vim-plug" target="_blank" rel="noopener">vim-plug</a>  vim插件管理器，用于安装、管理插件。</p><p><a href="https://github.com/junegunn/vim-plug" target="_blank" rel="noopener">The NERDTree</a>  文件目录可视化的插件，使用vim-plug插件管理器安装，安装方法见vim-plug的GitHub页码。使用方式：在vim命令行形式，输入<code>NERDTree</code>。</p><p>安装教程在如上的Github页面都很详细，就不赘述了。</p><h4 id="vim编写Hello-c和BST-c"><a href="#vim编写Hello-c和BST-c" class="headerlink" title="vim编写Hello.c和BST.c"></a>vim编写Hello.c和BST.c</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/07/01/XleE59UhbJdTWzk.png" alt="image-20200627122923712.png" title>                </div>                <div class="image-caption">image-20200627122923712.png</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/07/01/sCwNdRurTEpnYH8.png" alt="image-20200628113025534.png" title>                </div>                <div class="image-caption">image-20200628113025534.png</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/07/01/PN3KLGZAfjxSnHW.png" alt="image-20200628114709524.png" title>                </div>                <div class="image-caption">image-20200628114709524.png</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/07/01/HDlcnz46kEq1iYG.png" alt="image-20200628114742290.png" title>                </div>                <div class="image-caption">image-20200628114742290.png</div>            </figure><h2 id="第三关：进阶篇"><a href="#第三关：进阶篇" class="headerlink" title="第三关：进阶篇"></a>第三关：进阶篇</h2><h3 id="基础篇-1"><a href="#基础篇-1" class="headerlink" title="基础篇"></a>基础篇</h3><h4 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h4><p>CPU是一个具有特殊功能的芯片，里面含有指令集。内分为两个主要的单元，分别为算术逻辑单元，控制单元。CPU内部含有一些微指令，而指令集的设计分成两种设计理念，分别为两种CPU架构：精简指令集，复杂指令集。我们常用的Intel、AMD所用的便是复杂指令集，基于X86架构。</p><p>CPU频率：每秒钟可以进行的工作次数。（因为指令集、架构、二级缓存及其运算机制的不同、每一此频率可以运行的指令数不同，故不能单纯使用CPU频率来比较CPU性能。</p><p>现在CPU已经没有北桥，其中的内存控制器已经被整合到CPU内部了，使得CPU可以直接与内存、显卡进行通信，提高了效率</p><p>64位、32位的说法来自CPU每次能够处理的数据量，即字长。</p><h4 id="超线程技术"><a href="#超线程技术" class="headerlink" title="超线程技术"></a>超线程技术</h4><p>为何会有这种技术？因CPU命令执行周期太短，CPU内核长时间处于空置状态，同时系统是多任务系统，因此让多个任务使用同一内核，可以提高效率。</p><p>如何实现？把每个内核中的寄存器分成两组，让程序分别使用两组寄存器，从而使得内核数加倍，同时操作系统可以检测刀两倍的内核数，从而使得每个内核逻辑上分离。</p><p>此技术在大多数情况下都可以提高效率，但是其实本质上只有一个运算单元，故性能其实没有改变。</p><h4 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h4><p>有什么用？ 是操作系统的最底层，驱动硬件，提高系统所需要的内核功能，包括防火墙、是否支持LVM等。</p><p>是什么？系统中的一个文件，包括驱动主机各个硬件的检查程序和驱动模块。</p><p>内核模块化？将一些不常见的类似于驱动程序的东西独立出内核，编译成模块。</p><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>pid：process id,进程id</p><p>tid：线程id</p><p>程序被触发，执行者的权限和属性、程序的代码与所需数据会被加载到内存中，操作系统会给予这块内存一个PID，即进程是正在运行的一个程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//获取进程pid</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pthread_t 为 long unsigned int,lu.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">//获取线程tid</span></span><br><span class="line"><span class="function"><span class="keyword">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_equal</span><span class="params">(<span class="keyword">pthread_t</span> tid1,<span class="keyword">pthread_t</span> tid2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *<span class="keyword">restrict</span> tidp,<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *<span class="keyword">restrict</span> attr,<span class="keyword">void</span> *(*start_vin)(<span class="keyword">void</span>),<span class="keyword">void</span> *<span class="keyword">restrict</span> arg)</span></span>;</span><br><span class="line"><span class="comment">//中止线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *status)</span></span>;</span><br><span class="line"><span class="comment">//等待某个线程退出</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> tid,<span class="keyword">void</span> **status)</span></span>;</span><br><span class="line"><span class="comment">//gcc 编译 -pthread不可或缺</span></span><br><span class="line">gcc -pthread filename</span><br></pre></td></tr></table></figure><p><code>pthread_create</code>用于创建一个线程，成功返回0，否则返回Exxx（为正数）。</p><ul><li><code>pthread_t *tid</code>：线程id的类型为<code>thread_t</code>，通常为无符号整型，当调用pthread_create成功时，通过*tid指针返回。</li><li><code>const pthread_attr_t *attr</code>：指定创建线程的属性，如线程优先级、初始栈大小、是否为守护进程等。可以使用NULL来使用默认值，通常情况下我们都是使用默认值。</li><li><code>void *(*func) (void *)</code>：函数指针func，指定当新的线程创建之后，将执行的函数。</li><li><code>void *arg</code>：线程将执行的函数的参数。如果想传递多个参数，请将它们封装在一个结构体中。</li></ul><p><code>pthread_join</code>用于等待某个线程退出，成功返回0，否则返回Exxx（为正数）。</p><ul><li><code>pthread_t tid</code>：指定要等待的线程ID</li><li><code>void ** status</code>：如果不为NULL，那么线程的返回值存储在status指向的空间中（这就是为什么status是二级指针的原因！这种才参数也称为“值-结果”参数）。</li></ul><p><code>pthread_self</code>用于返回当前线程的ID。</p><p><code>pthread_detach</code>用于是指定线程变为<strong>分离</strong>状态，就像进程脱离终端而变为后台进程类似。成功返回0，否则返回Exxx（为正数）。变为分离状态的线程，如果线程退出，它的所有资源将全部释放。而如果不是分离状态，线程必须保留它的线程ID，退出状态直到其它线程对它调用了<code>pthread_join</code>。</p><p><code>pthread_exit</code>用于终止线程，可以指定返回值，以便其他线程通过<code>pthread_join</code>函数获取该线程的返回值。</p><ul><li><code>void *status</code>：指针线程终止的返回值。</li></ul><h4 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h4><p>线程是比进程更小的单位，进程由多个线程组成。</p><p>进程有独立的地址空间，线程没有独立的地址空间。</p><h4 id="尝试一个简单的多线程打印"><a href="#尝试一个简单的多线程打印" class="headerlink" title="尝试一个简单的多线程打印"></a>尝试一个简单的多线程打印</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;//pthread开头的函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;//sleep()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread1</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread2</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"enter main\n"</span>);</span><br><span class="line"><span class="keyword">pthread_t</span> tid1,tid2;</span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">pthread_create(&amp;tid1,<span class="literal">NULL</span>,thread1,<span class="literal">NULL</span>);</span><br><span class="line">pthread_create(&amp;tid2,<span class="literal">NULL</span>,thread2,<span class="literal">NULL</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"leave main\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线程1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread1</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"enter thread1\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"thread1 id is %lu"</span>,pthread_self());</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"leave thread1\n"</span>);</span><br><span class="line">pthread_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread2</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"enter thread2\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"thread2 id is %lu"</span>,pthread_self());</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"leave thread2\n"</span>);</span><br><span class="line">pthread_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行截图如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/07/01/lgkD8wjNquHRm53.png" alt="image-20200630214750801.png" title>                </div>                <div class="image-caption">image-20200630214750801.png</div>            </figure><h4 id="双线程打印ABABABAB（使用互斥锁与条件变量）"><a href="#双线程打印ABABABAB（使用互斥锁与条件变量）" class="headerlink" title="双线程打印ABABABAB（使用互斥锁与条件变量）"></a>双线程打印ABABABAB（使用互斥锁与条件变量）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COUNT 20</span></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//互斥锁宏初始化</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex=PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="comment">//条件变量宏初始化</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> even=PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> uneven=PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程1函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread1</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=COUNT)&#123;</span><br><span class="line">pthread_mutex_lock(&amp;mutex);<span class="comment">//上锁</span></span><br><span class="line"><span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"thread1:A\n"</span>);</span><br><span class="line">i++;</span><br><span class="line">pthread_cond_signal(&amp;uneven);<span class="comment">//发出信号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">pthread_cond_wait(&amp;even,&amp;mutex);<span class="comment">//等待信号</span></span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);<span class="comment">//解锁</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//除条件变量略有不同，其它类似</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread2</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=COUNT)&#123;</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"thread2:B\n"</span>);</span><br><span class="line">i++;</span><br><span class="line">pthread_cond_signal(&amp;even);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">pthread_cond_wait(&amp;uneven,&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> tid1,tid2;</span><br><span class="line">pthread_create(&amp;tid1,<span class="literal">NULL</span>,thread1,<span class="literal">NULL</span>);</span><br><span class="line">pthread_create(&amp;tid2,<span class="literal">NULL</span>,thread2,<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//等待进程退出</span></span><br><span class="line">pthread_join(tid1,<span class="literal">NULL</span>);</span><br><span class="line">pthread_join(tid2,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行截图如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/07/01/SrAv86TecqYdwh9.png" alt="image-20200630214836749.png" title>                </div>                <div class="image-caption">image-20200630214836749.png</div>            </figure><h4 id="内核的模块化设计"><a href="#内核的模块化设计" class="headerlink" title="内核的模块化设计"></a>内核的模块化设计</h4><p>用处？因为Linux内核庞大复杂，内核编译是很麻烦的事情，因此Linux使用模块化设计，将不常用的东西独立出内核，编译成模块。从而使得，在系统运行中，内核可以加载模块。最终提高了扩展性，功能的灵活性。</p><p>意思？模块化设计意思为内核中各个功能模块在代码上彼此独立的，没有变量、函数的相互调用。</p><h4 id="插入模块创建内核线程，打印Hello，World"><a href="#插入模块创建内核线程，打印Hello，World" class="headerlink" title="插入模块创建内核线程，打印Hello，World"></a>插入模块创建内核线程，打印Hello，World</h4><p>helloWorld.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;//printk()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="comment">//使用了linux/init.h中定义的宏init和exit</span></span><br><span class="line"><span class="comment">//内核中打印函数为printk，</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">init_my_module</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">"Hello, World!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">exit_my_module</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">"Bye, World!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//内核加载时执行</span></span><br><span class="line">module_init(init_my_module);</span><br><span class="line"><span class="comment">//内核卸载时执行</span></span><br><span class="line">module_exit(exit_my_module);</span><br></pre></td></tr></table></figure><p>Makefile文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#编译生成可加载模块，即将helloWorld.c编译成hello.ko</span></span><br><span class="line">obj-m += helloWorld.o</span><br><span class="line"><span class="section">all:</span></span><br><span class="line"><span class="comment">#-C 指定内核源码位置，/lib/modules/$(shell uname -r)/build</span></span><br><span class="line"><span class="comment">#M= 指定需要编译的内核源文件地址 [target]:modules(可选)</span></span><br><span class="line">make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ lsmod <span class="comment">#现实所有内核模块</span></span><br><span class="line">$ make</span><br><span class="line">$ sudo insmod helloWorld.ko<span class="comment">#运行内核模块</span></span><br><span class="line">$ dmesg <span class="comment">#查询/var/log/messages，查看打印的信息</span></span><br><span class="line">$ sudo rmmod helloWorld.ko<span class="comment">#卸载模块</span></span><br></pre></td></tr></table></figure><p>运行截图如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/07/01/FHygb1XSpIRxwde.png" alt="image-20200630215108549.png" title>                </div>                <div class="image-caption">image-20200630215108549.png</div>            </figure><h3 id="加分项-1"><a href="#加分项-1" class="headerlink" title="加分项"></a>加分项</h3><h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>在变量修改时间多于一个存储器访问周期的情况下，存储器读写周期会交叉，出现变量不一致的情况。</p><p>为了解决线程同步的问题，所以线程需要使用锁，同一时间只允许一个线程访问变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></span><br><span class="line"><span class="comment">//宏初始化（适用于静态分配的互斥量）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="comment">//操作先加锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> * mptr)</span></span>; </span><br><span class="line"><span class="comment">//操作后解锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> * mptr)</span></span>;</span><br></pre></td></tr></table></figure><p>互斥锁可以让线程按照顺序执行，从而使得一次只执行一次代码。</p><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>如果线程尝试对同一个互斥量加锁两次，本身就会进入死锁状态。</p><p>若两个分别占有一个互斥量的线程，试图锁住对方的互斥量是，就会进入死锁状态。</p><h5 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h5><p>互斥锁总是与条件变量一起使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">//宏初始化</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"> <span class="comment">//等待唤醒</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cptr, <span class="keyword">pthread_mutex_t</span> *mptr)</span></span>; </span><br><span class="line"><span class="comment">//通知</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cptr)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="标准IO与重定向符号的使用"><a href="#标准IO与重定向符号的使用" class="headerlink" title="标准IO与重定向符号的使用"></a>标准IO与重定向符号的使用</h4><p>标准输入、标准输出、标准错误分别为stdin,stdout,stderr。在默认情况下，标准输出和标准输入都是终端。stdin的文件描述符为0，stdout的文件描述符为1，stderrr的文件描述符为2。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">将stdout重定向到file,若追加在file后，运算符为 &gt;&gt;</span></span><br><span class="line">command &gt; file</span><br><span class="line"><span class="meta">#</span><span class="bash">将stderr重定向到file,2为文件描述符。</span></span><br><span class="line">command 2 &gt; file</span><br><span class="line"><span class="meta">#</span><span class="bash">将stdin重定向到file</span></span><br><span class="line">command &lt; file</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">例 输出hello, Linux!的可执行文件</span></span><br><span class="line">.\hello &gt; hello.txt</span><br><span class="line">cat  hello.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">输出</span></span><br><span class="line">hello, Linux!</span><br><span class="line"><span class="meta">#</span><span class="bash">例 比较大小输出最大值的可执行文件 input.txt: 3 5</span></span><br><span class="line">.\fmax &lt; input.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">输出</span></span><br><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="第四关：BOSS"><a href="#第四关：BOSS" class="headerlink" title="第四关：BOSS"></a>第四关：BOSS</h2><h3 id="基础篇-2"><a href="#基础篇-2" class="headerlink" title="基础篇"></a>基础篇</h3><p>信号是一种软中断，信号体制是进程间通信的一种方式，采用异步通信机制。原理是上，一个进程收到信号类似于处理器收到中断请求，故它是在软件层次上对中断机制的一种模拟。</p><p>信号在<code>signal.h</code>头文件中被定义，通过<code>kill -l</code>可以查看编号和信号名的映射关系。对于信号，通常有三种处理方式：忽略；默认动作；捕捉信号。</p><p><code>SIG_IGN,SIG_</code>分别表示忽略某一信号；按默认动作处理。</p><p>一般信号触发可分为几类：在终端通过组合按键触发，然后发送给前台，如<code>Ctrl+C</code>发送<code>SIGINT</code>信号；硬件异常产生信号，通知内核然后发送给进程信号；通过软件层面，如<code>kill(),raise()</code>等函数，或检测到某种软件条件发生产生信号。</p><p><code>signal()</code>函数用于对进程中某个特定信号（signum）注册一个对应的处理函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*<span class="keyword">sighandle_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;<span class="comment">//sighandle_t被定义为指向void()(int)函数类型的指针</span></span><br><span class="line"><span class="function"><span class="keyword">sighandle_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum,<span class="keyword">sighandler_t</span> handler)</span></span>;</span><br></pre></td></tr></table></figure><p><code>kill(),raise()</code>前者用来给指定进程发送信号，后者用来给当前进程发送信号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> signo)</span></span>;</span><br><span class="line">int raise(int signo)；</span><br><span class="line"><span class="comment">//kill(getpid(),signo) equals raise(signo)</span></span><br></pre></td></tr></table></figure><p><code>pause()</code>用来挂起进程，直到信号触发。针对不同的处理行为，表现不同，<code>pause</code>返回不同。若终止进程，则没有返回；若忽略，进程保持挂起状态，没有返回；若有信号处理函数，则调用该函数，返回<code>-1</code>。</p><h3 id="加分项-2"><a href="#加分项-2" class="headerlink" title="加分项"></a>加分项</h3><h4 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h4><p>中断被定义为一种事件，该事件改变处理器执行的指令顺序。中断通常分为同步中断（异常）和异步中断（中断）。同步中断是由CPU产生的，只有在一条指令中止执行后CPU才会产生中断。异步中断是由其它硬件设备依照CPU时钟信号随机产生的。</p><p>在嵌入式中，中断很重要，在几乎所有芯片中都有中断功能。每个外接设备申请一个唯一的中断号，让外设发生中断时，向CPU报告自己的中断号，CPU知道是哪个设备发生中断，然后执行相对应的操作。</p><p>如何处理？发生中断后，CPU暂停执行当前的程序，处理中断，因为中断执行后要恢复之前的额代码，故进入中断后CPU还要保护源程序断点信息，然后从中断控制器中取出中断向量，转到相应的处理程序，对中断进行处理，中断处理完成后返回，继续执行当前的程序。</p><p>好处？提高CPU的利用率，使CPU及时处理各种软硬件故障。若没有中断，CPU需要对设备进行循环的访问，才能得到设备的状态。中断则使得硬件如要与CPU联系，便向CPU发出中断请求信号，从而使得CPU停止当前程序的执行，处理硬件发出的请求。</p><p><strong>中断向量</strong>是中断服务程序的入口地址，即指向中断服务程序的指针。系统维护一份中断向量表，中断向量是其中的元素。当异常产生时，硬件产生一个中断标记，CPU根据中断标记获得相应的中断向量号，在由CPU根据中断向量表的地址和中断向量号去查找中断向量表获得相应中断号的中断程序地址，进一步执行对应的中断处理程序。</p><h4 id="RTC中断程序"><a href="#RTC中断程序" class="headerlink" title="RTC中断程序"></a>RTC中断程序</h4><p>rtc_alarm.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/rtc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;//ioctl()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;//struct rtc_time</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;//perror()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;//exit()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, fd, retval, irqcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> tmp, data;</span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtc_time</span> <span class="title">rtc_tm</span>;</span></span><br><span class="line">    <span class="comment">//打开rtc</span></span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"/dev/rtc"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">"/dev/rtc"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(errno);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//读取RTC</span></span><br><span class="line">    retval = ioctl(fd, RTC_RD_TIME, &amp;rtc_tm);</span><br><span class="line">    <span class="keyword">if</span>(retval==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">"ioctl"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(errno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印当前时间</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Current RTC data/time is %d-%d-%d,%02d:%02d:%02d.\n"</span>,</span><br><span class="line">    rtc_tm.tm_mday, rtc_tm.tm_mon + <span class="number">1</span>, rtc_tm.tm_year + <span class="number">1900</span>,rtc_tm.tm_hour, rtc_tm.tm_min, rtc_tm.tm_sec);</span><br><span class="line">    <span class="comment">//设置10min alarm</span></span><br><span class="line">    rtc_tm.tm_min += <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span>(rtc_tm.tm_sec&gt;=<span class="number">60</span>)&#123;</span><br><span class="line">        rtc_tm.tm_sec %= <span class="number">60</span>;</span><br><span class="line">        rtc_tm.tm_min++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(rtc_tm.tm_min&gt;=<span class="number">60</span>)&#123;</span><br><span class="line">        rtc_tm.tm_min %= <span class="number">60</span>;</span><br><span class="line">        rtc_tm.tm_hour++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(rtc_tm.tm_hour==<span class="number">24</span>)&#123;</span><br><span class="line">        rtc_tm.tm_hour = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置 alarm</span></span><br><span class="line">    retval = ioctl(fd, RTC_ALM_SET, &amp;rtc_tm);</span><br><span class="line">    <span class="keyword">if</span>(retval==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">"ioctl"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(errno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Alarm time now set to %02d:%02d:%02d.\n"</span>,rtc_tm.tm_hour, rtc_tm.tm_min, rtc_tm.tm_sec);</span><br><span class="line"><span class="comment">//启用 alarm</span></span><br><span class="line">    retval = ioctl(fd, RTC_AIE_ON, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(retval==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">"iotle"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(errno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用read()，因rtc不能被两个线程调用，故阻塞直到alarm，从而实现闹钟功能。</span></span><br><span class="line">    retval = <span class="built_in">read</span>(fd, &amp;data, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>));</span><br><span class="line">    <span class="keyword">if</span>(retval==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">"read"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(errno);</span><br><span class="line">    &#125;</span><br><span class="line">    irqcount++;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"okay.Alarm rang.\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行截图如下：（因10min的alarm太久了，故将<code>rtc_tm.tm_min += 10;</code>改为<code>rtc_tm.tm_min += 1;</code>，设置1min的alarm）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/07/01/oZPIyYl1fW32Bwd.png" alt="image-20200630220826329.png" title>                </div>                <div class="image-caption">image-20200630220826329.png</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一关：初识Linux&quot;&gt;&lt;a href=&quot;#第一关：初识Linux&quot; class=&quot;headerlink&quot; title=&quot;第一关：初识Linux&quot;&gt;&lt;/a&gt;第一关：初识Linux&lt;/h2&gt;&lt;h3 id=&quot;基础篇&quot;&gt;&lt;a href=&quot;#基础篇&quot; class=&quot;he
      
    
    </summary>
    
    
    
      <category term="Linux" scheme="ronpay.xyz/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Git 笔记</title>
    <link href="ronpay.xyz/2020/07/01/Git-%E7%AC%94%E8%AE%B0/"/>
    <id>ronpay.xyz/2020/07/01/Git-%E7%AC%94%E8%AE%B0/</id>
    <published>2020-07-01T14:31:36.000Z</published>
    <updated>2020-07-01T14:32:09.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git笔记"><a href="#Git笔记" class="headerlink" title="Git笔记"></a>Git笔记</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">该命令执行完后会在当前目录生成一个 .git 目录。</span></span><br><span class="line">git init</span><br><span class="line"><span class="meta">#</span><span class="bash">初始化后，会在 newrepo 目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。</span></span><br><span class="line">git init newrepo</span><br><span class="line"><span class="meta">#</span><span class="bash">如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add *.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add README</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">'初始化项目版本'</span></span></span><br></pre></td></tr></table></figure><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">克隆仓库的命令格式为：</span></span><br><span class="line">git clone &lt;repo&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash">如果我们需要克隆到指定的目录，可以使用以下命令格式：</span></span><br><span class="line">git clone &lt;repo&gt; &lt;directory&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash">比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> git://github.com/schacon/grit.git</span></span><br><span class="line"><span class="meta">#</span><span class="bash">如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> git://github.com/schacon/grit.git mygrit</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Git笔记&quot;&gt;&lt;a href=&quot;#Git笔记&quot; class=&quot;headerlink&quot; title=&quot;Git笔记&quot;&gt;&lt;/a&gt;Git笔记&lt;/h1&gt;&lt;h2 id=&quot;基本操作&quot;&gt;&lt;a href=&quot;#基本操作&quot; class=&quot;headerlink&quot; title=&quot;基本操作&quot;
      
    
    </summary>
    
    
    
      <category term="Git" scheme="ronpay.xyz/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Github+Hexo 博客搭建</title>
    <link href="ronpay.xyz/2020/07/01/Github-Hexo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>ronpay.xyz/2020/07/01/Github-Hexo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</id>
    <published>2020-07-01T14:28:50.000Z</published>
    <updated>2020-07-01T14:31:45.726Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Github-Hexo-博客搭建"><a href="#Github-Hexo-博客搭建" class="headerlink" title="Github+Hexo 博客搭建"></a>Github+Hexo 博客搭建</h1><h2 id="必要组件"><a href="#必要组件" class="headerlink" title="必要组件"></a>必要组件</h2><p>安装Node.js，添加国内源<code>npm config set registry https://registry.npm.taobao.org</code></p><p>安装Git，并加入命令提示符</p><h2 id="Github操作"><a href="#Github操作" class="headerlink" title="Github操作"></a>Github操作</h2><p>新建repo，名为：”name.github.io”，并初始化README</p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>右键  <code>Git Bash Here</code>，打开git控制台窗口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装Hexo</span></span><br><span class="line">npm i hexo-cli -g</span><br><span class="line"><span class="meta">#</span><span class="bash">初始化文件夹</span></span><br><span class="line">hexo init</span><br><span class="line"><span class="meta">#</span><span class="bash">安装必要组件</span></span><br><span class="line">npm install</span><br><span class="line"><span class="meta">#</span><span class="bash">生成静态网页</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="meta">#</span><span class="bash">打开本地服务器，在localhost:4000/中预览</span></span><br><span class="line">hexo s</span><br><span class="line"><span class="meta">#</span><span class="bash">关闭本地服务器</span></span><br><span class="line">ctrl+c</span><br></pre></td></tr></table></figure><h2 id="连接Github与本地"><a href="#连接Github与本地" class="headerlink" title="连接Github与本地"></a>连接Github与本地</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">在git控制台窗口</span></span><br><span class="line">git config --global user.name "yourname"</span><br><span class="line">git config --global user.email "youremail"</span><br><span class="line"><span class="meta">#</span><span class="bash">生成密匙SSH key</span></span><br><span class="line">ssh-keygen -t rsa -C "youremail"</span><br><span class="line"><span class="meta">#</span><span class="bash">输入</span></span><br><span class="line">cat ~/.ssh/id_rsa.pub</span><br><span class="line"><span class="meta">#</span><span class="bash">将输出的文件保存在下方的SSH中</span></span><br><span class="line"><span class="meta">#</span><span class="bash">输入</span></span><br><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>打开<a href="https://link.zhihu.com/?target=http%3A//github.com/">github</a>，在头像下面点击<code>settings</code>，再点击<code>SSH and GPG keys</code>，新建一个SSH，名字随便。</p><p>打开博客根目录下的<code>_config.yml</code>文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。</p><p>修改最后一行的配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: https://github.com/yourname/yourname.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h2 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装拓展</span></span><br><span class="line">npm i hexo-deployer-git</span><br><span class="line"><span class="meta">#</span><span class="bash">新建一篇文章</span></span><br><span class="line">hexo new post "article title"</span><br><span class="line"><span class="meta">#</span><span class="bash">生成静态网页</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="meta">#</span><span class="bash">本地浏览</span></span><br><span class="line">hexo s</span><br><span class="line"><span class="meta">#</span><span class="bash">上传到github</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Github-Hexo-博客搭建&quot;&gt;&lt;a href=&quot;#Github-Hexo-博客搭建&quot; class=&quot;headerlink&quot; title=&quot;Github+Hexo 博客搭建&quot;&gt;&lt;/a&gt;Github+Hexo 博客搭建&lt;/h1&gt;&lt;h2 id=&quot;必要组件&quot;&gt;&lt;a 
      
    
    </summary>
    
    
    
      <category term="Hexo" scheme="ronpay.xyz/tags/Hexo/"/>
    
  </entry>
  
</feed>
